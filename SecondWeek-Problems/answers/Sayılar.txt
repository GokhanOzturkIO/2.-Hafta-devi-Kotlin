Sayılar

1) Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?
- Sekiz farklı tipte alt sınıf vardır.Bunlar:byte, short, long, int, float, double, char, number. Farklı veri türleri için uygun olan bellek miktarını ve hesaplama karmaşıklığını belirlediği için önemlidir. Hangi alt sınıfı kullanmamız gerektiği, saklamak istediğimiz veri türüne ve ve ihtiyacımız olan hassasiyete bağlıdır.


2) Eğer bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa, Kotlin tip çıkarımını nasıl yapar?
-Kotlin dilinde kullandığımız IDE, herhangi bir değişkene type belirtmeden değer atasak bile bizim verdiğimiz değerden yola çıkarak bunun tipinin ne olduğunu bilir. Buna da "Type Inference" denir.


3) Float değişken oluştururken F ve f harfleri varken, Long değişken oluştururken neden küçük l harfi yoktur?
-F harfi: Float, "floating-point" (kayan nokta) kelimesinin kısaltmasıdır. F harfi, bu tür değişkenlerin ondalık basamakları olduğunu gösterir.
f harfi: Java'dan miras kalan bir gelenektir. Java'da, ondalık sayıları temsil eden primitive tipler float ve double'dır. Float için "f" harfi kullanılırken, double için "d" harfi kullanılır. Kotlin, Java ile uyumluluğu korumak için "f" harfini de kabul etmektedir.
l harfi: Long, "long integer" (uzun tamsayı) kelimesinin kısaltmasıdır. Tarihsel olarak, "long" kelimesi tamsayı türleri için yaygın olarak kullanılmıştır.
Küçük l harfinin olmaması: Teknik bir gerekliliktir. Kotlin'de, değişken isimleri ve anahtar kelimeler büyük ve küçük harflere duyarlıdır. "l" harfi, "1" rakamına benzeyebileceğinden, karışıklık yaratmamak için küçük l harfi kullanılmamıştır.


4)Tek duyarlıklı (Single precision) ve Çift duyarlıklı (Double precision) kavramlarını açıklayın.
-Bu kavramlar, bilgisayarda ondalıklı sayıları temsil etmenin iki farklı yoludur. Bir sayının saklanabildiği basamak sayısını ve dolayısıyla hassasiyetini ifade eder.
Tek duyarlıklı: 32 bit bellek kullanır, daha az hassastır ve yuvarlama hatalarına daha yatkındır. Yaklaşık 7 basamak ondalık basamak saklayabilir. Daha az belllek kullanır ve daha hızlı işlem sağlar.
Çift duyarlıklı: 64 bit bellek kullanır, yaklaşık 15-16 basamak ondalıklı basamak saklayabilir, daha hassastır ve yuvarlama hatalarına daha az yatkındır, daha fazla bellek kullanır ve daha yavaş işlem  sağlar.


5) Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak hangi işaretler kullanılır? Bu ayıraçların kullanımında nelere dikkat etmek gerekir?
-"," ya da "." işaretleri kullanılır. Bu işaretleri kullanırken kodunuzda ondalık ayracı olarak virgül veya nokta kullanmayı seçmeliyiz ve bunu tutarlı bir şekilde kullanmalıyız. Uluslararası standartlarda ondalık ayracı olarak nokta (.) kullanılır. Bu nedenle, kodunuzu farklı dillerde veya platformlarda çalıştırmayı planlıyorsanız, nokta (.) kullanmanız önerilir. Bölgesel ayarlarınıza bağlı olarak, ondalık ayracı farklı bir karakter olabilir. Kodunuzu farklı bölgelerde çalıştırmayı planlıyorsanız, bölgesel ayarlara göre ondalık ayracını ayarlamanız gerekebilir.


6) Double ve Float değişkenler ondalık kısımda kaç basamağa kadar işlem yaparlar? Bu sınırın üzerinde gelen ondalık bilgileri için nasıl davranırlar? Hangi durumlar için Float ve hangi durumlar için Double kullanılmalıdır?
-Float:aklaşık 7 basamak ondalık basamak saklayabilir,daha az hassastır ve yuvarlama hatalarına daha yatkındır, 32 bit (4 byte) bellek kullanır, daha hızlı işlem sağlar.Ondalık basamak sınırı 2^-23'tür (yaklaşık 1.2E-7). Bu sınırdan sonra gelen ondalık basamakları yuvarlanır veya kesilir.
Double:Yaklaşık 15-16 basamak ondalık basamak saklayabilir, daha hassastır ve yuvarlama hatalarına daha az yatkındır, 64 bit (8 byte) bellek kullanır, daha yavaş işlem sağlar. Ondalık basamak sınırı 2^-52'dir (yaklaşık 1.4E-15). Bu sınırdan sonra gelen ondalık basamakları yuvarlanır veya kesilir.Hassasiyet önemliyse: Double , hız önemliyse: Float , bellek kullanımı önemliyse: Float kullanılmalıdır


7) Ondalık(Decimal), Onaltılık (Hexadecimal) ve İkilik (Binary) değişkenleri Kotlin'de nasıl tanımlayabilirsiniz?
-Ondalık değişkenleri : Int, Double , onaltılık değişlenleri: 0x, 0X ön eki ile binary değişkenleri: 0b, 0B ile tanımlayabiliriz.


8) Sekizlik (Octal) değişkenler Java'da nasıl tanımlanır? Kotlin'de Sekizlik değişken tanımlanabilir mi?
-Java'da sekizlik değişkenler, 0 ön eki ile tanımlanır. Kotlinde ise sekizlik değişkenler doğrudan tanımlanamaz. Bunun nedeni, özelliğin eksikliği, dilin sadeliğini ve kullanımı kolaylığını korumak amacıyla kotlin de sekizlik değişkenler doğrudan tanımlanamaz. Ancak, sekizlik sayıları ondalık sayılara dönüştürerek ve ardından uygun tipte bir değişkene atayarak sekizlik değerleri saklayabiliriz.


9) "Geleneksel Notasyon" (Conventional Notation) gösterimi nasıl yapılır?
-Kotlin'de "geleneksel notasyon" terimi, genellikle diğer dillerde olduğu gibi, daha yaygın ve geleneksel olarak kullanılan dil yapılarını ifade eder. Örneğin, bir sınıfın nasıl tanımlanacağı veya bir constructor (kurucu) fonksiyonunun nasıl yazılacağı gibi.
class Ogrenci {
    var ad: String
    var yas: Int

    constructor(ad: String, yas: Int) {
        this.ad = ad
        this.yas = yas
    }

Bu kodda, "class" anahtar kelimesiyle sınıf tanımlanır, ardından sınıfın özellikleri (ad ve yas), constructor fonksiyonu ve bir metodun nasıl tanımlanacağı gösterilir. Bu geleneksel bir yaklaşımdır ve diğer dillerde de benzer şekilde kullanılır.
Ancak, Kotlin'de bu işlemleri daha modern bir şekilde yapmak da mümkündür ve bazen bu yaklaşım tercih edilir çünkü daha kısa ve anlaşılır kodlar yazılmasını sağlar.


10) Sayısal değişkenlerde alt çizgi (underscore) nasıl kullanılır? Kotlin bunu nasıl yorumlar?
-Kotlin'de sayısal değişkenlerde alt çizgi (_), sayıları okunabilir hale getirmek için kullanılabilir. Alt çizgi, sayısal basamakları gruplara ayırmak için kullanılır ve virgüllerin işlevini görür. Kotlin bunu sayısal bir değer ayırıcı olarak yorumlar.  


11) == ile neyi karşılaştırırız? === ile neyi karşılaştırırız?
-" == " operatörü değişkenlerin değerini karşılaştırırken kullanılır.
" === " operatörü memory de ki adreslerini check ederken yani,İki operatörün bellekteki aynı nesneye işaret edip etmediğini kontrol ederken kullanılır.


12) === operatörü ile karşılaştırma yaparken Byte değer aralığı neden önemlidir? Kotlin bu aralığa göre neden özel bir davranış sergiler?
-Taşma veya alt taşma sonucunda byte değeri aralığına giren bir değer, "=== "operatörü ile karşılaştırıldığında eşit kabul edilir. Kotlin, byte değerleri için" === "operatörünün taşma ve alt taşma durumlarını göz ardı etmeyi seçmiştir. Bu, kodun daha tutarlı ve öngörülebilir olmasını sağlar.Bu özel davranış sadece byte değerleri için geçerlidir.Diğer veri tipleri için "=== "operatörü, taşma ve alt taşma durumlarından etkilenmez.
"===" operatörünü byte değerleri ile karşılaştırırken bu özel davranışı göz önünde bulundurmak önemlidir.


13) Sayısal değişkenlerde hangi matematiksel operatörler kullanılabilir?
-Temel Operatörler: Toplama (+), Çıkarma (-), Çarpma (*), Bölme (/), Mod (%) 
Gelişmiş Operatörler: Üs Alma (^), Kök alma (sqrt), Mutlak değer (abs), Yuvarlama (round),Ondalık basamak sayısını ayarlamak (floor, ceil) 
Karşılaştırma Operatörleri: Eşittir (==), Eşit değildir (!=), Büyüktür (>), Küçüktür (<), Büyük veya eşittir (>=), Küçük veya eşittir (<=)


14) Sayısal değişkenlerde hangi karşılaştırma operatörleri kullanılabilir?
-Karşılaştırma Operatörleri: Eşittir (==), Eşit değildir (!=), Büyüktür (>), Küçüktür (<), Büyük veya eşittir (>=), Küçük veya eşittir (<=) operatörleri kullanilabibilir.


15) Bit düzeyinde operatörler (Bitwise operators) nelerdir? Ne amaçla kullanılır? Kotlin'de bunları nasıl kullanabilirsiniz?
-AND (&&) operatörü çarpma işlemine benzemektedir. Bu operatör kullanıldığında yapılan işlemin sonucu true çıkması için tüm verilerin true olması gerekir.
OR (||) operatörü toplama işlemine benzemektedir. Bu operatör kullanıldığında yapılan işlemin sonucu true çıkması için tek bir verinin true olması gerekir.
NOT (!) Mantıksal Değil operatörü boolean tipinde bir sonucun tersini vermektedir.
SHL (<<) Bir sayıyı sola kaydırır. Her bir bit, belirtilen sayıda basamak sola kaydırılır.
SHR (>>) Bir sayıyı sağa kaydırır. Her bir bit, belirtilen sayıda basamak sağa kaydırılır.


16) Kotlin'de büyük sayılarla çalışırken hangi ek türlerden yararlanılır ve bu türlerin sınırları nelerdir?
-BigInteger: Sınırsız büyüklükteki tam sayıları temsil etmektedir. Matematiksel işlemler ve karşılaştırma işlemleri için destek sağlar. Ayrıca, "BigInteger" eklentisi nesneleri ondalık, onaltılık veya ikili sayı dizileri olarak oluşturulabilir.
BigDecimal: Ondalık basamakları da içeren büyük sayıları temsil eder. Matematiksel operatörler ve karşılaştırma operatörleri için destek sağlar. "BigDecimal" nesneleri, ondalık sayılar veya ondalık basamakları olan metin dizileri olarak oluşturulabilir.
UInt: 32 bitlik tamsayıları temsil eder. Int türünün sınırlarını aşan büyük tamsayı değerleri için kullanilanılabilir.
ULong: 64 bitlik tamsayıları temsil eder. Long türünün sınırlarını aşan büyük tamsayı değerleri için kullanilanılabilir.


17) Double ve Float değişkenler kullanılırken "yuvarlama" davranışı nasıldır? Bu nasıl değiştirilebilir?
-Double: 64 bitlik hassasiyete sahiptir. Ondalık sayılar, 15 basamağa kadar tam olarak temsil edilebilir. 15 basamaktan sonra yuvarlama hataları meydana gelebilir.
Float: 32 bitlik hassasiyete sahiptir. Ondalık sayılar, 7 basamağa kadar tam olarak temsil edilebilir. 7 basamaktan sonra yuvarlama hataları meydana gelebilir. Bunu değiştirmek için 4 farklı fonksiyondan uygun olanı kullanabiliriz. 
Math.round() Fonksiyonu: Bir sayıyı en yakın tam sayıya yuvarlar.
Math.floor() Fonksiyonu: Bir sayıyı en yakın alt basamaktaki tam sayıya yuvarlar.
Math.ceil() Fonksiyonu: Bir sayıyı en yakın üst basamaktaki sayıya yuvarlar.