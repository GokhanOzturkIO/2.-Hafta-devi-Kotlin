Temel Türler & Null Güvenliği


Soru 1: val ile var arasındaki fark nedir?

Cevap: Val: Value/Immutable: İlk aldığı değer değiştirilemez olarak bilinen değişkendir.
       Var: Variable: Değişebilir değişkendir.

Çok bilinenin aksine val değişkene immutable yerine ready only denilmelidir.

Performans açısından farklarına bakacak olursak yok denecek kadar azdır.
Eğer akademik level'da bir konu ise ve salt dümdüz bir kodu konuşuyorsak (var) kullanmak daha performanslı ama çok küçük bir performans farkı bu.

Günlük hayat problemlerinde ise (val) kullanmak var'a göre daha avantajlı hale geliyor çünki; Thread işlemlerden dolayı var maliyet ve performansta düşüş yaşatıyor.
--------------------------------------------------------------------------------------
Soru 2:Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

Cevap: Basitçe örnek verecek olursak 

       class Person {

       val name:String = "Sena"
       var surname:String = "GEZER"
       private set 
                     {
Bu senaryoda, surname değişkeni var olarak tanımlanmış ancak set metodu private olarak ayarlanmıştır. Bu, surname değişkeninin sadece sınıf içinde değiştirilebileceği anlamına gelir ve sınıf dışından doğrudan erişim engellenir. Bu durum, değişkenin kontrol altında tutulmasını ve doğrudan erişimin engellenmesini sağlar.

-------------------------------------------------------------------------------------
Soru 3: "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

Cevap: Val değişkenlere genellikle immutable denildiğini duyarız ancak bu yanlıştır çünkü ımmutable derken asla değiştirilemez anlamına gelir. Val değişkenler ise değeri okunabilen yani (ReadOnly) ama değişemez anlamına gelmez, değeri okunup set edilemeyen değişkendir. 

Ama biz basitçe,val değişkeninin değerinin değişebilir olduğunu göstermek için örnek verecek olursak bir classtaki val değişkeninin get fonksiyonuna sabit bir değer değilde değişkenlerden oluşan bir işlemin sonucunu verirsek bu işlemin sonucu değişkenlerin değerine bağlı olarak değişeceği için her seferinde biz available space çağırdığımızda yani bu val değişkeni çağırdığımızda farklı sonuçlar alabiliriz. 
Dolayısıyla immutable değil ReadOnly'dir val değişkenler.
---------------------------------------------------------------------------------------
Soru 4: "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

Cevap: Eşitliğin sağ tarafında bir value varsa siz o değişkenin tipini vermeseniz bile diğer taraftaki değere bakarak değişkenin tipinin ne olacağına karar verir Ide, buna type inference denir. 
Nullable kullanırken yani null değerleriyle çalışırken kesin olarak belirtmesi gereklidir. 

Type inference tanımına ek olarak; sayısal değerler için eğer ki verilen değer integer değer aralığının içindeyse o zaman integer set edilir. Yani byte ve short aralığında olsa bile integer set edilir. Ama integerdan daha büyük bir değer aralığındaysa her zaman long set edilir.
-------------------------------------------------------------------------------------
Soru 5: Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

Cevap: Kotlinde primitive değişken tipleri class olarak görünseler bile yapılan özel optimizasyonlarla bytecode çevrilirken java tarafındaki gerçek primitive tiplere karşılık gelir.
-------------------------------------------------------------------------------------
Soru 6:"Tip Güvenliği" (Type Safety) kavramını açıklayın.

Cevap: Kotlin tip güvenliğini sağlamak için bazı parametreler geliştirmiştir bunlar;

-Tür Belirleme (Type Inference):Kotlin, değişkenlerin türünü otomatik olarak belirleme yeteneğine sahiptir.

-Null Güvenliği (Null Safety):Kotlin, null referanslarını önlemek için güçlü bir null güvenliği sistemine sahiptir. Değişkenlerin varsayılan olarak null olamayacak şekilde tanımlanması ve nullable türlerin açıkça belirtilmesi, null ile ilgili hataları minimize eder.

-Tür Dönüşümleri (Type Casts):Kotlin, tür dönüşümleri sırasında güvenli olmayan işlemleri engellemek için güvenli tür dönüşümlerini destekler. Güvenli bir tür dönüşümü için as? operatörü kullanılır.

Bu parametreler,geliştiricilere programlarını yazarken daha az hata yapma ve daha güvenli bir kod üretme imkanı sağlar.

---------------------------------------------------------------------------------------
Soru 7: Bir değişkeni nullable yapmak için ne yapmalıyız?

Cevap: Bir değişkene null değer ataması yapmak istiyorsak o değişken tipinin sonuna ? koyup = null diyoruz.

Val name:String? =null

Herhangi bir veri dipinin sonuna soru işareti koyarak onu nullayabilirsiniz, her veri tipinde bu yapılabiliyor.
---------------------------------------------------------------------------------------
Soru 8: "Null Güvenliği" (Null Safety) kavramını açıklayın.

Cevap: Kotlin'de "Null Güvenliği" (Null Safety), uygulamalarda null referans hatalarını önlemek ve daha güvenli bir programlama deneyimi sağlamak için tasarlanmış bir özelliktir. Null güvenliği, uygulama kodunda null referanslarının daha etkili bir şekilde yönetilmesini sağlar ve böylece çoğu null referans hatasını önler.

Null güvenliğinin temel özellikleri:
-Nullable Türler(?)
-Güvenli Çağrılar (Safe Calls)
-Elvis Operatörü (Elvis Operator)
-!! Operatörü (Not-Null Assertion Operator)
---------------------------------------------------------------------------------------
Soru 9:Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

Cevap: Eğer bir değişkenin tipini belirtmeden null değer atıyorsanız, kotlin bunun tipini bilmediği için nullable bir "Nothing" şeklinde yorumlar.Nothing genellikle bir işlevin hiçbir şey döndürmediğini belirtmek için kullanılır.
-------------------------------------------------------------------------------------
Soru 10: İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

Cevap: Bellek yönetimi açısından, nullable değişkenlerin bellekte null durumunu temsil etmek için ek bir durum gerektirmesi ve null kontrolü yapma ihtiyacının olması, nullable olmayan değişkenlere göre ekstra bir maliyeti ifade edebilir. 
---------------------------------------------------------------------------------------
Soru 11: Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?

Cevap: Null değer almış bir nullable değişken, bellekte genellikle bir işaretçi (pointer) olarak temsil edilir ve bu işaretçi null olduğunda, gerçek veri için ayrı bir bellek alanı ayrılmaz. Bu nedenle, null değerli değişkenler bellekte genellikle daha az yer kaplar.
Eğer nullable bir değişkenin bir değeri varsa, bu değer bellekte ayrı bir yerde saklanır ve bu durum bellek kullanımını etkiler.
Yani bellekte yer kaplamaz diyemeyiz sadece ayrı bir bellek alanı ayrılmaz farkı vardır.
--------------------------------------------------------------------------------------
Soru 12:Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır?

Cevap: Nullable bir değişkenle çalışırken (!!.) ve (?.) operatörlerini kullanırız.

(?.): Bu operatör, bu değer nullable olabilir ama sen buna daha sonradan bir başka değer atadıysan bu kod çalışsın demek. Yani null hariç başka bir değer aldıysa çalıştır, değeri null ise bu kodu çalıştırma anlamına gelir.

(!!.): Ben vereceğim değerin null olmayacağını garanti ediyorum. Sen değer ne gelirse gelsin bu kodu çalıştır anlamına geliyor.Eğer değeri null gelirse zaten exception hatası veriyor.

!!. Uygulamayı crash yaptığı için çok kritik bölgelerde örn kredi tutarları gibi alanlarda hata görmektense uygulamayı crash et diyebiliriz.

?. Uygulamada sadece hata mesajı bildirir, çok kritik olmayan bölgelerde örn girişte kullanıcı ismini vererek hoşgeldin demediyse bu sorun uygulamayı crash edecek kadar mühim bir sorun olmadığından hata vermesi yeterlidir.

-------------------------------------------------------------------------------------
Sayılar

Soru 1:Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?

Cevap: 
Number sınıfı miras alan değişkenler;
-Byte
-Short
-Int
-Long
-Double
-Float 
Bunların değer aralkları bellekte kapladıkları yer ve hızları bakımından önemlidir.
------------------------------------------------------------------------------------
Soru 2:Eğer bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa, Kotlin tip çıkarımını nasıl yapar?

Cevap:Bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa kotlin tip çıkarımını verilen değere göre yapar.
-------------------------------------------------------------------------------------
Soru 3:Float değişken oluştururken F ve f harfleri varken, Long değişken oluştururken neden küçük l harfi yoktur?

Cevap: Long değişken oluştururken küçük l harfinin olmama sebebi bazı yazı stillerinde küçük l harfinin 1 sayısına benzerliğinden dolayı bir karışıklık olmaması adına yoktur.
--------------------------------------------------------------------------------------
Soru 4: Tek duyarlıklı (Single precision) ve Çift duyarlıklı (Double precision) kavramlarını açıklayın.

Cevap: Tek duyarlıklı (Single Precision) ve Çift duyarlıklı (Double Precision), sayısal hesaplamalarda kullanılan kayan nokta (floating-point) veri türlerini tanımlayan terimlerdir.

Tek Duyarlıklı (Single Precision):
-Tek duyarlıklı, ondalık sayıları temsil etmek için kullanılan bir kayan nokta veri türüdür.
-32 bit uzunluğundadır.
-Tipik olarak float anahtar kelimesiyle ifade edilir.
-Hassasiyet yaklaşık 6-9 basamaklı ondalık sayı hassasiyetine sahiptir.
-Bellekte daha az yer kaplar ve daha hızlı işlemler için kullanılır.

Çift Duyarlıklı (Double Precision):
-Çift duyarlıklı, daha büyük değer aralıklarına ve daha yüksek hassasiyete ihtiyaç duyan uygulamalarda kullanılan bir kayan nokta veri türüdür.
-64 bit uzunluğundadır.
-Tipik olarak double anahtar kelimesiyle ifade edilir.
-Hassasiyet yaklaşık 15-17 basamaklı ondalık sayı hassasiyetine sahiptir.
-Daha fazla bellek alanı kullanır ancak daha yüksek hassasiyet sunar.

Tek ve çift duyarlıklı sayılar, bilimsel ve mühendislik uygulamalarında hassas sayılar üzerinde çalışmak için yaygın olarak kullanılır. Seçim, uygulama gereksinimlerine ve hesaplama hassasiyetine bağlıdır. Çift duyarlıklı genellikle daha yüksek hassasiyet sağlar, ancak bu da daha fazla bellek kullanımına neden olur.
------------------------------------------------------------------------------------
Soru 5:Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak hangi işaretler kullanılır? Bu ayıraçların kullanımında nelere dikkat etmek gerekir?

Cevap: Double ve float değişkenlerinde ondalık sayıları ifade ederken nokta (.) işareti kullanılır. Ayrıca, sayıları biçimlendirirken binlik ayıraç olarak alt çizgi (_) kullanabiliriz. Ancak, ondalık sayıları ifade ederken her zaman nokta kullanılmalıdır.

Dillere de dikkat edilmelidir bu konuda, yani İngilizce ve Türkçeden örnek verelim.

Türkçede;
Ondalık sayıları ifade ederken virgül (,) kullanılır.
Binlik ayıraç olarak genellikle nokta (.) kullanılır.

İngilizcede;
Ondalık sayıları ifade ederken nokta (.) kullanılır.
Binlik ayıraç olarak genellikle virgül (,) kullanılır.

---------------------------------------------------------------------------------------
Soru 6:Double ve Float değişkenler ondalık kısımda kaç basamağa kadar işlem yaparlar? Bu sınırın üzerinde gelen ondalık bilgileri için nasıl davranırlar? Hangi durumlar için Float ve hangi durumlar için Double kullanılmalıdır?

Cevap: 

Float: Float veri türü, yaklaşık olarak 6-9 basamak ondalık sayı hassasiyetine sahiptir. 6-9 basamak ondalık sayıları tam olarak temsil eder. Ancak bu aralığın dışındaki değerler daha düşük hassasiyetle temsil edilir.
Hassasiyet sayıların ondalık kısımlarının ne kadar doğru bir şekilde temsil edileceğini belirler.

Double: Double veri türü, yaklaşık olarak 15-17 basamak ondalık sayı hassasiyetine sahiptir. 15-17 basamak ondalık sayıları tam olarak temsil eder. Yüksek hassasiyet sebebiyle genellikle daha yaygın kullanılır.

Double ve Floatta bu sınırlar dışındaki değerler veri türünün temsil yeteneğinin ötesine geçtiği için "yuvarlama" veya "kırpma" gibi işlemlerle temsil etmeye çalışır.
Buda veri kayıplarına neden olabilir. 

Double ve Float'ın kullanım alanları ise şöyle ayrıştırılabilir;
Float bellek kullanımını azaltmak istendiği durumlarda daha düşük hassasiyetin yeterli olduğu durumlarda. Double ise yüksek hassasiyet gerektiren matematiksel hesaplar veya finansal uygulamalar gibi durumlarda yani standart olarak daha yüksek hassasiyet beklenen durumlarda ve karmaşık matematiksel işlemlerde kullanılır.
Double işlemleri Float'a göre daha hızlıdır ancak bellek kullanımı kritik bir öneme sahipse ve daha düşük hassasiyet yeterliyse float tercih edilebilir.
--------------------------------------------------------------------------------------
Soru 7: Ondalık(Decimal), Onaltılık (Hexadecimal) ve İkilik (Binary) değişkenleri Kotlin'de nasıl tanımlayabilirsiniz?

Cevap: 
Ondalık (Decimal)'de: ondalık sayıları doğrudan tanımlayabiliriz.
val decimalNumber: Int = 12345

Onaltılık (Hexadecimal)'de: "0x" ön ekiyle birlikte onaltılık sayıları tanımlanır.
val hexadecimalNumber: Int = 0xABCD

İkilik (Binary)'de: "0b" ön ekiyle birlikte ikilik sayıları tanımlanır.
val binaryNumber: Int = 0b1010
--------------------------------------------------------------------------------------
Soru 8:Sekizlik (Octal) değişkenler Java'da nasıl tanımlanır? Kotlin'de Sekizlik değişken tanımlanabilir mi?

Cevap: Java'da sekizlik (octal) sayıları tanımlamak için sayıyı 0 ile başlatmak yeterlidir. 

örn: int octalNumber = 0123;

Ancak, Kotlin'de doğrudan bir sekizlik sayı tanımlama yoktur. Kotlin, ondalık, onaltılık ve ikilik sayıları destekler ancak özel bir sekizlik tanımlama olanağı sunmaz.Kotlin'de eğer bir sayıyı sekizlik olarak tanımlamak istiyorsak, onlu bir sayıyı 8'lik bir sayıya dönüştürmek gibi bir yöntemi kullanabiliriz.

örn; val octalNumber: Int = Integer.parseInt("123", 8)

Burada Integer.parseInt("123", 8) ifadesi, "123" sayısını 8'lik bir sayıya dönüştürmektedir. Ancak, bu dönüşüm sonucu bir ondalık sayıya atanabilir, çünkü Kotlin'de doğrudan sekizlik bir sayı tanımlama olanağı yoktur.
------------------------------------------------------------------------------------
Soru 9:"Geleneksel Notasyon" (Conventional Notation) gösterimi nasıl yapılır?

Cevap:Geleneksel Notasyon, belirli bir bağlamda, bir dilde veya bir alanda genel olarak kabul edilmiş veya yaygın olarak kullanılan bir gösterim şeklidir. Bu terim genellikle matematiksel ifadeler, programlama kodları, müzik notaları veya diğer sembolik gösterimler için kullanılabilir.

Örneğin, matematiksel bir ifadeyi ele alalım: y=mx+b   (Geleneksel Notasyon Matematik)

Bu ifade, matematikte bir doğru denklemi olan "y = mx + b" ifadesini temsil eder. Burada, y,m,x ve b sembollerinin kullanımı geleneksel matematik notasyonuna dayanmaktadır.

Yani tekrar özetlemek gerekirse geleneksel Notasyon, belirli bir konsepti, formülü veya ifadeyi açık ve anlaşılır bir şekilde ifade etmek için belirli sembollerin ve kuralların kullanımını içerir. Bu, belirli bir alan veya disiplinde kabul edilmiş standartları ifade eder.
--------------------------------------------------------------------------------------
Soru 10:Sayısal değişkenlerde alt çizgi (underscore) nasıl kullanılır? Kotlin bunu nasıl yorumlar?

Cevap: Sayısal değerlerde alt çizgi (underscore) kullanımı, sayıları daha okunabilir hale getirmek için kullanılır. Alt çizgiler, sayıları gruplamak ve sayıları okurken onları daha anlaşılır kılmak için eklenir.

Alt çizgiler milyarları,ondalık sayıları, telefon numaralarını, kredi kartlarını, Tc kimlik no,bytes daha okunabilir hale getirebilir. İsteğe bağlı kullanılır ve bu alt çizgiler Kotlin tarafından okunmaz sayı değeri neyse o okunur sadece.
-------------------------------------------------------------------------------------
