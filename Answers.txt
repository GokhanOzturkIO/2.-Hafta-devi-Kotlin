 --------Temel Türler & Null Güvenliği--------

1- val ile var arasındaki fark nedir?

- val bir değişkenin değerinin bir kez atanıp sonrasında değiştirilemeyeceği ve sabit olduğu anlamına gelir. değişkenin tipi ve değeri belirlendikten sonra değiştirilemez.
sabit değerler ve değişmesini istemediğimiz verilerde kullanırız.
- var bir değişkenin değerinin herhangi bir zamanda değiştirilebileceği ve bu nedenle değişkenin değerinin değişken olabileceği anlamına gelir. Esneklik sağlar, verilen bir değer sonradan değiştirilebilir.
Performans açısından farka bakarsak val ile var arasındaki performans farkı yok denilecek kadar azdır. val değişkenler var değişkenlere göre daha maliyetlidir, bir if şartı vardır val'da, var daha performanslı val'a göre 
(multi-thread işlemleri saymazsak) performans farkı çok azdır. Salt dümdüz bir kod üzerinde konuşursak var daha performanslı (multi-thread işlemleri yoksa) - günlük hayat problemlerinde val daha performanslı 
kısaca özetlemek gerekirse multi-thread işlemlerde val daha performanslı, multi-thread olmayan işlemlerde var daha performanslıdır.


2- Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

Bir 'var' değişkenin set'ini private yaparak 'val' gibi davranmasını sağlayabiliriz artık var değişkene yeni bir data atanmasının önüne geçmiş oluruz.

var surName = "Ersoyoglu"
    private set

aynı class'ın içinde yine değeri değiştirilebilir ama farklı bir class içerisinde değiştirilemez sadece okunabilirdir.


3- "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

immutable -> hiçbir şekilde değişemez bir değişemez bir değişkendir. bir değişkenin/nesnenin durumu asla ilk değerden farklı olamaz demek.
readonly -> değeri okunabilen set edilemeyen (ilk değer atamasından sonra tekrar değer atanamaz) demektir.
val anahtar kelimesi ile tanımlanan bir değişkenin kendisi değişmez değildir. Örneğin, bir val listesi, listeye yeni öğeler ekleyebilir veya mevcut öğeleri çıkarabilir, ancak val listesi başka bir listeye yönlendirilemez. 
Bu nedenle, val değişkenler aslında “değişmez” değil, “salt okunur” olarak açıklanmalıdır. Bu, val değişkenlerin değerlerinin değiştirilemeyeceği, ancak atıfta bulundukları nesnelerin durumlarının değiştirilebileceği anlamına gelir.


4- "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

değişkenlerin tanımlanması sırasında tip belirtmeden,derleyicinin verdiğimiz değere bakarak değişkeninin türünü çıkartmasıdır diyebiliriz. kısaca bir programlama dilinin, bir değişkenin veya ifadenin türünü otomatik olarak belirlemesine olanak sağlayan bir özelliktir.
val name = "Samet"  // Derleyici 'name' değişkeninin türünü 'String' olarak çıkarır.

Eğerki değikenin değerini direkt olarak atamıyorsak, ilk değer atamasını yapmıyorsak sonradan değerini atıyacaksak bu durumda bunun tipinin ne olacağını IDE'ye belirtmemiz lazım 
bazı durumlardaysa, tip belirtmek kesin olarak gereklidir:
-Değişkenin ilk değeri yoksa: Eğer bir değişken tanımlanırken ilk değer atanmıyorsa, derleyici değişkenin türünü çıkaramaz. Bu durumda, değişkenin türünü açıkça belirtmek gerekir.
var age: Int // 'age' değişkeninin türü açıkça belirtilmiştir.
-Fonksiyon dönüş tiplerinde: Kotlin’de, fonksiyonların dönüş türlerini belirtmek zorunludur (tek istisna, hiçbir şey dönmeyen fonksiyonlardır).
fun add(a: Int, b: Int): Int {
    return a + b
}

Bir başka önemsememiz gereken durum da Number değişkenler için bilmemiz gereken 
 - Tanımladığımız sayı Int değer aralığından büyük değilse veri tipi Int olur.
 - eğer sayı Int değer aralığını geçiyorsa değişken türü Long olur.


5- Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

Kotlinde ki primitive değişken tipleri sınıf(class) gibi görünseler bile yapılan optimizasyonlar ile byte code'a çevirilirken Java tarafında ki gerçek primitive tiplere karşılık gelecektir. Yani özetle kotlinde class gibi gözüken değişken tipleri
(normalde primitive olduğunu bildiğimiz) özel optimizasyonlarla byte code'a çevrilirken yine primitive tip olacak şekilde çevriliyorlar, Çalışma zamanında(runtime) primitive hallerine optimize edilirler. 
(Bu tip dönüşümü değil, arkaplanda Javada ki koda karşlık gelen tipi üretecek).























