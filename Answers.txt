1) val ile var arasındaki fark nedir?

val ->  değeri sonradan değiştirilemeyen değişkendir. Value(sabit) kelimesinin kısaltmasıdır. Genellikle "immutable" olarak bilinsede "immutable" değil "read-only" değişkendir. "read-only" demek ilk değer atamasından sonra tekrar değer atanamaz demektir. "immutable" ise bir değişkenin veya nesnenin durumu ilk değerden farklı olamaz demektir.
var -> değeri sonradan değiştirilebilen değişkendir. Variable(değişken) kelimesinin kısaltmasıdır.

örn :
var a = 12
a = 14 // değerini sonradan değiştirebildik

val b = 12
b = 14 // hata alacaktır değeri sonradan değiştirilemez

**immutable değilde read-only denilen durum için
-> fullname'i val olarak tanımlasakta get fonk sabit bir değere değilde değişebilen parametrelere bağlı olduğu için farklı değerler için farklı sonuçlar üretebildi.

class Person {
    var name = "Cansel"
    var surname = "Değdaş"

    val fullName : String
        get() {
            return name + surname
        }
}

fun getFullNameOfPerson() {
    val person = Person()
    person.name = "İlyas"
    person.surname = "Yüregir"
    print(person.fullName) // sonucu İlyas Yüregir olarak print eder

    val person = Person()
    person.name = "Seher"
     person.surname = "Değdaş"
     print(person.fullName) // sonucu Seher Değdaş olarak print eder
}

2) Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

Değişkenin set fonksiyonunu private yaparak val gibi davranmasını sağlayabiliriz. Çünkü bir değişkene değer atamamızı sağlayan değişkenin set fonksiyonuna bağlıdır. var değişkenin set fonksiyonunu private yapıp "show kotlin bytecode" ile decompile ettiğimizde set fonklsiyonu oluşturmadığına bakabiliriz.

Val kullanmak yerine bunu neden kullanmak isteriz sorusuna cevap olarak, değişkeni ilgili class içerisinde değiştirmek isteyipte dışarıdan başka bir class veya fonk içerisinde değiştirilmesine izin vermek istemiyorsak kullanabiliriz.

örn:

Elimizde bir kullanıcı ismi var ve private set olarak ayarlandı ve sadece belirli bir validasyon ile değiştirilmesi isteniyor, bunu dışarıdan direkt erişim verirsek validasyona bağlı olmaksızın istemediğimiz şekilde değiştirilebilir. Bu yüzden private set yaparsak kullanıcı adı ilgili classta bu validasyonu sağladığı dıurumda güncellenmesi sağlanır.

class User(private var _username: String) {
    var username: String
        get() = _username
        private set(value) {
            if (validateUsername(value)) {
                _username = value
            }
        }

    private fun validateUsername(username: String): Boolean {
        // Kullanıcı adı geçerlilik kontrolü (örneğin minimum uzunluk vs.)
        return username.length >= 5
    }

    fun updateUsername(newUsername: String) {
        if (validateUsername(newUsername)) {
            _username = newUsername
        }
    }
}

fun main() {
    val user = User("JohnDoe")
    println(user.username)  // JohnDoe

    // user.username = "NewName" // Dışarıdan değiştirme yapılamaz (compile error)

    user.updateUsername("NewName")
    println(user.username)  // NewName
}


3) "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

 "read-only" -> bir değişkene değer atamasından sonra tekrar değer atanamaz demektir.
 "immutable" -> bir değişkenin veya nesnenin durumu ilk değerden farklı olamaz demektir.

 -> fullname'i val olarak tanımlasakta get fonk sabit bir değere değilde değişebilen parametrelere bağlı olduğu için farklı değerler için farklı sonuçlar üretebildi.

 class Person {
     var name = "Cansel"
     var surname = "Değdaş"

     val fullName : String
         get() {
             return name + surname
         }
 }

 fun getFullNameOfPerson() {
     val person = Person()
     person.name = "İlyas"
     person.surname = "Yüregir"
     print(person.fullName) // sonucu İlyas Yüregir olarak print eder

     val person = Person()
     person.name = "Seher"
      person.surname = "Değdaş"
      print(person.fullName) // sonucu Seher Değdaş olarak print eder
 }

 4) "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

 Bir değişkenin tanımlandığı anda açıkça(explicit) tip belirtilmediğinde atanan değer doğrultusunda ide'nin değişkenin tipini belirlemesidir.

 Eğer bir değişken tanımlandığı anda değer ataması yapılmayacaksa tip belirtmek gerekir. Çünkü ide'nin değişkeni tanımlayabilmesi ve ram'de uygun yer ayırabilmesi için değişkenin tipine ihtiyacı vardır. Tip'e göre ram'de ayrılan yerin boyutu değişiklik gösterir.



 5) Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

 Kotlinde değişken tipleri sınıf olarak bulunsalarda çalışma zamanda yapılan özel optimizasyonlarla javadaki primitive tiplere karşılık gelirler. Show kotlin Byte kod ile bakıldığında gözlemlenebilir.

 örn:
 Kotlin -> val a: Int = 10 bu koda show kotlin byte kod ile decompile ettiğimizde aşağıdaki gibi javada olan primitive karşılığını göreceğiz.
 Java -> int a = 10



6) "Tip Güvenliği" (Type Safety) kavramını açıklayın.

 Her değişkenin ve ifadenin yalnızca belirli bir türle çalışmasını garanti altına alan bir kavramdır.

 örn:
 var name: String = "Kotlin"
 name = 123 // bu şekilde atama yaptığımızda name String tipinde olduğı halde int tipinde bir değer ataması olduğu için derleme zamanında hata verir.



 7) Bir değişkeni nullable yapmak için ne yapmalıyız?

 Bir değişkeni null yapmak için değişken tipinin sonuna ? işaretini koymamız gerekir.

 örn:  nullable bir değişken hem null hem de değere sahip olabilir demektir.
 var number1: Int? = 10
 number1 = null


 8) "Null Güvenliği" (Null Safety) kavramını açıklayın.

 Bir değişkenin veya nesnenin null olmasından dolayı oluşabilecek hataları önlemek için özelliktir. Bir değişkenin veya nesnenin null olup olmadığını kontrol etmeden üzerinde işlem yapmaya çalıştığımızda meydana gelir. Java da null safety olmadığı için en çok hatalardan biri NullPointerException hatasıdır.



 9) Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

 Ide tarafından boş bir class olan Nothing? tipinde bir tip ataması yapılır. Bu, değişkenin yalnızca null olabileceği anlamına gelir.

 örn:

 val example = null  // Türü Nothing?



 10) İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

 Normalde Kotlin de ilkel tipler birer class olsada yapılan özel optimizasyonlar ile primitive typelara çevrilir. Fakat primitive bir tipi nullable yaparsak artık referans tipli bir değişken haline gelir. Bu durum kritik bir öneme sahiptir. Gereksiz yere ? kullanmamaya dikkat etmemiz gerekir.

 - değişkenin kapladığı alanı
 - erişebilirliği
 - yapabildiği işe
 - hızına

 etki eder. Primitive tipler daha az alan kaplar, daha kolay erişebilir, daha az iş yapar ve daha hızlıdır.

 Nullable olmayan ilkel tipler, bellek yönetimi açısından daha verimli ve hızlıdır çünkü doğrudan makine seviyesinde işlenir ve sabit boyutta veri tipleriyle temsil edilir.
 Nullable ilkel tipler, ilkel veri tiplerinin nesne olarak sarılması (boxing) nedeniyle daha fazla bellek kullanır ve performans açısından daha maliyetlidir, çünkü her işlemde boxing/unboxing işlemleri yapılabilir.



 11) Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?

 Null bir değişken  hiç yer kaplamaz diyemeyiz. Değişkenin kendisi bellekte yer tutmaya devam eder, ancak referans edilen bir nesne olmadığı için veri kısmı bellekte kullanılmaz. Yani, null bir referans, değere sahip bir nesneden çok daha az bellek kullanır, ancak tamamen sıfır bellek tükettiğini söylemek mümkün değildir.



 12) Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır?

 Nullable değişkenlerle çalışırken 3 farklı operatör kullanabiliriz.

 Safe Call Operator (?.) -> Bu operatör, nullable bir değişkenin null olup olmadığını kontrol eder. Eğer null değilse, ardından gelen işlemi gerçekleştirir.
 Not-null Assertion Operator (!!.) -> Bu operatör, nullable bir değişkenin kesinlikle null olmadığını varsayar. Eğer değişken null ise, NullPointerException fırlatır.
 Elvis Operator (?:) -> Bu operatör, nullable bir değerin null olup olmadığını kontrol eder ve null ise varsayılan bir değer döner.


 ** eğer bir değişkenin null olması kritik bir öneme sahip değilse null olsa bile kullanıcı işlemleri doğru bir şekilde ilerletebiliyorsa ?. kullanılabilir.
  Ama bir değişkenin değerinin null olması yapılan bir hesaplama vs etkiliyor ise !!. kullanmak daha sağlıklı olacaktır.
  Elimizde verebileceğimiz bir varsayılan değer var ise ?: elvis operatörünü kullanabiliriz.


 örn :
 ?: -> var nullableValue: String? = null
       val value = nullableValue ?: "Varsayılan Değer"

 !!. -> var nullableValue: String? = "Merhaba"
        val value = nullableValue!! // value "Merhaba" olacak

 ?. -> var nullableValue: String? = null
       val length = nullableValue?.length // length değeri null olacak


 13) Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?

 Byte, Short, Int, Long, Float, Double olmak üzere 6 alt sınıf vardır.
 Değer aralıkları bellek kullanımını ve performans açısından önemlidir. Daha küçük değer aralığına sahip tipler(Byte, Short) daha az bellek tüketir. Kullanılacak veriye göre doğru veri tipini kullanmak performs açısından önemlidir.



14) Eğer bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa, Kotlin tip çıkarımını nasıl yapar?

Değişkenin verilen değer f veya F olarak belirtildiyse Float, L olarak belirtildiyse veya verilen değer Long değer aralığında ise Long, ondalıklı sayı olarak belirtildiyse Double, bunlardan hiçbiri belirtilmediyse tipi optimal olarak Int olarak belirlenir.

örn:

var number1 = 10L // tipi Long olarak belirlenir
var number2 = 1000f // tipi Float olarak belirlenir
var number3 = 55F // tipi Float olarak belirlenir
var number4 = 3.14 // tipi Double olaral belirlenir
var number5 = 90 // tipi Int olaral belirlenir


15) Float değişken oluştururken F ve f harfleri varken, Long değişken oluştururken neden küçük l harfi yoktur?

Bazı fontlarda l ile 1 birbirine çok benzediği için l harfi yoktur.



16) Tek duyarlıklı (Single precision) ve Çift duyarlıklı (Double precision) kavramlarını açıklayın.

Tek duyarlıklı (Single precision) -> Float ile temsil edilir. 32 bitlik alan kullanılır. Daha küçük bellek alanı kullandığı için hassasiyeti daha düşüktür ve daha büyük sayılarla çalışırken doğruluk kaybına neden olabilir.

Çift duyarlıklı (Double precision) -> Double ile temsil edilir. 64 bitlik alan kullanılır. Daha geniş bellek alanı kullandığı için çok daha büyük ya da çok daha küçük sayılarla çalışırken daha doğru sonuçlar elde edilir.

Sonuç olarak ;

Float daha az bellek kullanır, ancak hassasiyeti düşüktür.
Double daha fazla bellek kullanır, ancak daha yüksek hassasiyet ve geniş bir değer aralığı sunar.



17) Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak hangi işaretler kullanılır? Bu ayıraçların kullanımında nelere dikkat etmek gerekir?

Bazı dillerde ondalık ayracı .(nokta) iken bazı dillerde ,(virgül) kullanılmaktadır. Bu yüzden bu ayıraçlara göre herhangi bir işlem(split vs) yapılıyorsa , veya . kullanımına dikkat edilmesi gerekir.



18) Double ve Float değişkenler ondalık kısımda kaç basamağa kadar işlem yaparlar? Bu sınırın üzerinde gelen ondalık bilgileri için nasıl davranırlar? Hangi durumlar için Float ve hangi durumlar için Double kullanılmalıdır?

Float -> 6-7 basamağa kadar işlem yaparlar, Daha küçük bellek alanı kullandığı için hassasiyeti daha düşüktür ve daha büyük sayılarla çalışırken doğruluk kaybına neden olabilir.
Double -> 15-16 basamağa kadar işlem yaparlar, Daha geniş bellek alanı kullandığı için çok daha büyük ya da çok daha küçük sayılarla çalışırken daha doğru sonuçlar elde edilir.

Float ve Double basamak sınırı dışına çıkıldığında, basamakları yuvarlayarak veya keserek kaybeder. Bu nedenle daha büyük sayılarda doğruluk kaybı yaşanır.

örn:

val num: Float = 3.1415926535F
println(num)  // Çıktı: 3.1415927

val num: Double = 3.14159265358979323846
println(num)  // Çıktı: 3.141592653589793



19) Ondalık(Decimal), Onaltılık (Hexadecimal) ve İkilik (Binary) değişkenleri Kotlin'de nasıl tanımlayabilirsiniz?

Ondalık(Decimal) -> Ondalık sayılar, 0-9 arasındaki rakamlarla ifade edilir.

Onaltılık (Hexadecimal) -> Onaltılık sayılar, 0-9 ve A-F harfleri ile ifade edilir. A, B, C, D, E, F harfleri sırasıyla 10, 11, 12, 13, 14 ve 15 rakamlarına karşılık gelir. Kotlin’de onaltılık sayılar 0x veya 0X önekiyle tanımlanır.

İkilik (Binary) -> 	İkilik sayılar sadece 0 ve 1 rakamlarını kullanır. Kotlin’de ikilik sayılar 0b veya 0B öneki ile tanımlanır.

örn:
val decimalNumber = 255  // Ondalık sistemde 255
val hexNumber = 0xFF  // Onaltılık sistemde FF, ondalık sistemde 255'e eşittir
val hexNumber2 = 0x1A3  // Onaltılık sistemde 1A3, ondalıkta 419'a eşittir
val binaryNumber = 0b101010  // İkilik sistemde 101010, ondalık sistemde 42'ye eşittir
val binaryNumber2 = 0b1101  // İkilik sistemde 1101, ondalıkta 13'e eşittir


20) Sekizlik (Octal) değişkenler Java'da nasıl tanımlanır? Kotlin'de Sekizlik değişken tanımlanabilir mi?

Kotlin’de doğrudan sekizlik (octal) sayılar için bir destek yoktur. Kotlin, ondalık (decimal), onaltılık (hexadecimal) ve ikilik (binary) sayılar için yerleşik destek sağlasa da sekizlik sayılar için özel bir önek (Java’daki gibi 0) sunmaz.

örn:
int octalNumber = 0757;



21) "Geleneksel Notasyon" (Conventional Notation) gösterimi nasıl yapılır?

Kotlin’de, bilimsel notasyon (conventional notation) kullanarak sayıları tanımlamak için E veya e (exponent) sembolü kullanılır. Bu, sayıların 10’un üsleriyle ifade edilmesini sağlar. Bu notasyon sayesinde çok büyük ya da çok küçük sayılar daha kolay ifade edilebilir ve sayıların okunabilirliğini arttırır.

örn:
val largeNumber = 3.6e6  // 3.6 x 10^6
val smallNumber = 4.5e-5 // 4.5 x 10^-5



22) Sayısal değişkenlerde alt çizgi (underscore) nasıl kullanılır? Kotlin bunu nasıl yorumlar?

Büyük sayıları daha okunabilir hale getirmek için kullanılabilir. Bu, özellikle çok haneli sayılarda veya karmaşık ondalık sayılarda büyük kolaylık sağlar. Kotlin’de alt çizgi, sayıların değeri üzerinde hiçbir etkisi yoktur. Derleme aşamasında Kotlin, alt çizgileri yok sayar.

örn:
val largeNumber = 1_000_000  // 1 milyon
val creditCardNumber = 1234_5678_9012_3456  // Kredi kartı numarası gibi uzun sayılar
val pi = 3.1415_9265_3589  // Pi sayısının okunabilirliği artar
val binaryNumber = 0b1101_0101_1110_0001  // İkilik sayılar için daha anlaşılır
val hexNumber = 0xFF_EC_DE_5E  // Onaltılık sayılarda daha iyi okunabilirlik


23) == ile neyi karşılaştırırız? === ile neyi karşılaştırırız?

== ile değişkenlerin değerini,

=== ile değişkenlerin referansını karşılaştırırız.



24) === operatörü ile karşılaştırma yaparken Byte değer aralığı neden önemlidir? Kotlin bu aralığa göre neden özel bir davranış sergiler?

=== operatörü, iki değişkenin referanslarını karşılaştırmak için kullanılır. Yani, iki değişkenin bellekte aynı yeri işaret edip etmediğini kontrol eder. Kotlin, Byte türündeki sayılar için belirli bir aralıkta (değer aralığı: -128 ile 127) bulunan değerleri cache’ler (ön bellekte tutar). Bu optimizasyon, sık kullanılan küçük sayıların tekrar tekrar bellekte yer kaplamasını önlemek ve performansı artırmak amacıyla yapılır.

örn:
val a: Byte = 127
val b: Byte = 127
val c: Byte = -128
val d: Byte = -128
val e: Byte = 128.toByte()

println(a === b)  // true, çünkü a ve b -128 ile 127 aralığında
println(c === d)  // true, çünkü c ve d -128 ile 127 aralığında
println(a == b)   // true, çünkü == değeri karşılaştırır, referansı değil
println(e === 128.toByte())  // false, çünkü 128 aralığın dışında ve farklı referanslar kullanılıyor


25) Sayısal değişkenlerde hangi matematiksel operatörler kullanılabilir?

Aritmetik operatörler -> +, -, /, *, %

Atama operatörler -> =, +=, -=, /=, *=, %=

Artırma ve Azaltma operatörler -> ++, --



26) Sayısal değişkenlerde hangi karşılaştırma operatörleri kullanılabilir?

Eşitlik Karşılaştırma Operatörleri -> ==, =!

Büyüklük Karşılaştırma Operatörleri -> >, <, <=, >=

örn:
    val a = 5
    val b = 3

    println(a == b)       // false
    println(a != b)       // true
    println(a > b)        // true
    println(a < b)        // false
    println(a >= b)       // true
    println(a <= b)       // false



27) Bit düzeyinde operatörler (Bitwise operators) nelerdir? Ne amaçla kullanılır? Kotlin'de bunları nasıl kullanabilirsiniz?



43) "val b: Byte = 1 ile val i: Int = b ve son olarak print(b == i) gibi bir kod yazıldığında çıktı ne olur? Neden böyle bir çıktı aldığınızı açıklayın.

Çıktı olarak type mismatch hatası alırız. Kotlinde kapalı tür dönüşümü olmadığı için byte tipinde bir değeri int tipinde bir değere atayabilmek için açıkça tür dönüşümü yapmamız gerekir.

val i: Int = b.toInt() dersek bu kodu düzeltmiş oluruz, bu şekilde düzelttiğimizde == değer karşılaştırması yaptığı için i ve b değerleri eşit olduğu için true çıktısını alırız



44) "val b: Byte = 1 ile val i: Int = b.toInt() ve son olarak print(b == i) gibi bir kod yazıldığında çıktı ne olur? Neden böyle bir çıktı aldığınızı açıklayın.

Açıkça tür dönüşümü olduğu için byte değeri int değişkenine doğru bir şekilde atanmış olur.  == değer karşılaştırması yaptığı için i ve b değerleri eşit ve 1 olduğu için true çıktısını alırız.



45) Sayısal değişkenlerde açık dönüşüm (Explicit Type Conversion) yaparken hangi fonksiyonları kullanabilirsiniz?

toByte(), toShort(), toInt(), toFloat(), toDouble(), toLong(), toChar() fonksiyonlarını kullanabiliriz.

örn :
val i: Int = 100
val b: Byte = i.toByte()
val s: Short = i.toShort()
val l: Long = i.toLong()
val f: Float = i.toFloat()
val d: Double = i.toDouble()
val charValue = i.toChar() // unicode karakterini d harfidir
