Temel Türler & Null Güvenliği

1-val ile var arasındaki fark nedir? Sorusunun Cevabı:

-->val(value),değeri sonradan değiştirilemez anlamındadır.Ek olarak get edilebilir fakat set edilemez.
-->var(variable),değeri sonradan değiştirilebilir anlamındadır. Get ve set işlemi yapılabilmektedir.
-->Bilinenin aksine val "immutable değil read-only'dir".Şimdi bunların ne olduğuna değinelim:
-->Read-only: Bir nesnenin durumunun değiştirilemez olduğu, yalnızca okunabilir olduğu anlamına gelir. Bu durumda, nesnenin içeriği değiştirilemez, ancak nesne referansı değiştirilebilir olabilir. Örneğin, bir liste "read-only" olabilir, yani listenin içeriği değiştirilemez, ancak listenin kendisi başka bir listeyle değiştirilebilir.
-->Immutable: Bir nesnenin durumunun hem içeriği hem de referansı değiştirilemez olduğu anlamına gelir. Yalnızca okunabilir ve değiştirilemez bir nesne olduğu söylenebilir. Örneğin, bir "immutable" liste, hem listenin içeriği hem de referansı değiştirilemez.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin. Sorusunun Cevabı:

-->Bir var değişkenini val gibi davranmasını sağlamak için, değişkenin erişim düzeyini private yapabilir ve ayrıca set erişim belirleyicisini private olarak tanımlayabiliriz. 
-->Bu şekilde, değişkenin değeri sadece sınıf içinde atanabilir ve dışarıdan değiştirilemez hale gelir.
-->Bu yöntemi kullanmak, değişkenin sadece başlangıçta atanıp daha sonra değiştirilmemesi gerektiği durumlarda faydalı olabilir. Örneğin, bir sınıf içindeki bir değişkenin değerinin sadece sınıfın içinde kontrol edilerek değiştirilmesini istiyorsak, bu yöntemi kullanabiliriz.

Örnek Senaryo:
class User {
    private var _name: String = ""

    var name: String
        get() = _name
        private set(value) {
            _name = value
        }

    init {
        // Başlangıçta sadece atanabilir
        name = "John"
        println("User name set to: $name")
        
        // Dışarıdan değiştirilemez
        // name = "Doe" // Hata!
    }

    fun changeName(newName: String) {
        // Dışarıdan değiştirilemez
        // _name = newName // Hata!
        
        name = newName
        println("User name changed to: $name")
    }
}

fun main() {
    val user = User()
    user.changeName("Alice")
}

-->Bu örnekte, name değişkeni başlangıçta sadece sınıf içinde atanabilir ve dışarıdan değiştirilemez. changeName fonksiyonu ile name değişkeninin değeri sınıf içinde değiştirilebilir, ancak dışarıdan doğrudan _name değişkenine erişim mümkün değildir. Bu sayede, name değişkeni val gibi davranmış olur.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-"Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır? Sorusunun Cevabı:

-->1.Sorunun cevabında bu kavramları açıklamıştık,tekrardan gözden geçirelim:
-->Read-only: Bir nesnenin durumunun değiştirilemez olduğu, yalnızca okunabilir olduğu anlamına gelir. Bu durumda, nesnenin içeriği değiştirilemez, ancak nesne referansı değiştirilebilir olabilir. Örneğin, bir liste "read-only" olabilir, yani listenin içeriği değiştirilemez, ancak listenin kendisi başka bir listeyle değiştirilebilir.
-->Immutable: Bir nesnenin durumunun hem içeriği hem de referansı değiştirilemez olduğu anlamına gelir. Yalnızca okunabilir ve değiştirilemez bir nesne olduğu söylenebilir. Örneğin, bir "immutable" liste, hem listenin içeriği hem de referansı değiştirilemez.

-->Val değişkenlerinin neden "değişmez" yerine "salt okunur" olarak açıklanması gerektiğini anlamak için, Kotlin'in dil tasarımı ve kullanım amacını anlamak önemlidir.

-->Kotlin'de val değişkenleri bir kez değer atandıktan sonra yeniden atanamaz, yani değiştirilemezler. Ancak, bu değişkenin içindeki verinin kendisi değişebilir. Örneğin, bir val değişkeni olan bir liste, liste elemanlarını değiştirebilir, ancak liste başka bir liste ile değiştirilemez.

-->Bu nedenle, "değişmez" kelimesi val değişkenlerini açıklamak için tam olarak doğru değildir, çünkü değişkenlerin içindeki veri değişebilir. "Salt okunur" terimi daha doğru bir açıklama sağlar, çünkü val değişkenleri sadece bir kez atanabilir ve değerleri okunabilir, ancak yeniden atanamazlar. Bu, değişkenin kendisinin değişmez olduğu anlamına gelmez, sadece içindeki verinin değişmez olduğu anlamına gelir.

-->Özetle, val değişkenlerinin "salt okunur" olarak açıklanması, değişkenin kendisinin değişmez olduğu yanılgısını önler ve değişkenin sadece bir kez atanabileceği ve değerlerinin okunabileceği gerçeğini vurgular. Bu, Kotlin'in dil tasarımı ve kullanım paradigmasıyla daha uyumludur.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

4-"Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir? sorusunun cevabı:

-->"Tip Çıkarımı" (type inference), değişkenin veya ifadenin tipini derleyicinin otomatik olarak belirlemesini ifade eder. Bu, genellikle değişkenin tipini açıkça belirtmek zorunda kalmadan daha kısa ve daha okunabilir kod yazmanızı sağlar.

--> val number = 42 Burada, number değişkeninin tipi belirtilmemiştir, ancak Kotlin derleyicisi bu değişkenin bir Int olduğunu anlar.

Tip belirtmenin kesin olarak gerektiği durumlar şunlardır:
-->Karşılaştırma Operatörleri: ==, !=, ===, !== gibi operatörlerde tip uyumluluğu kontrol edilirken tip belirtilmesi gerekebilir.
-->Null Değerleri: Kotlin'de null değerleriyle çalışırken bazen tip belirtmek gerekebilir, özellikle null değerlerle ilgili hataların önlenmesi için.
-->Genel Tipler: Bazı durumlarda, genel bir tip yerine belirli bir tip kullanmak isterseniz tip belirtmeniz gerekebilir.
-->İşlem Sonuçları: Karmaşık ifadeler veya işlemler sonucunda elde edilen değerlerin tipini belirlemek için tip belirtmek gerekebilir.
-->Fonksiyonlar ve Dönüş Tipleri: Fonksiyonların dönüş tiplerini belirlemek için tip belirtmek gerekebilir.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

5-"Tip Güvenliği" (Type Safety) kavramını açıklayın. Sorusunun Cevabı:

-->Type Safety, bir programlama dilinde, değişkenlerin ve ifadelerin veri tiplerine uygun olarak kullanılmasını ve tip uyumsuzluklarının önlenmesini sağlayan bir özelliktir.

--> // Tip uyumsuzluğu
val text: String = "Hello"
val number: Int = text // Hata! String bir değişkeni Int'e atamak mümkün değil

// Tip uyumlu
val number: Int = 42

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


6-Bir değişkeni nullable yapmak için ne yapmalıyız? Sorusunun Cevabı:

-->Bir değişkeni nullable yapmak için değişkenin tipinin sonuna ? işareti eklenir. Bu sayede değişken null değerini alabilir hale gelir. Örneğin, bir String değişkeni nullable yapmak için şu şekilde yapabiliriz:

--> val nullableString: String? = null

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

7-"Null Güvenliği" (Null Safety) kavramını açıklayın. Sorusunun Cevabı:

-->"Null Güvenliği" (Null Safety), bir programlama dilinde veya bir programda, null referans hatalarını önlemek için alınan önlemleri ifade eder. Bu kavram, bir değişkenin veya nesnenin null olabileceği durumları dikkate alarak programlama yapmayı ve bu durumları kontrol altına almaya yönelik bir yaklaşımı temsil eder.

-->var nullableString: String? = null
val length = nullableString?.length // Eğer nullableString null değilse, uzunluğunu al. Null ise null döndür.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

8-Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar? Sorusunun Cevabı:

-->Kotlin'de bir değişkene null değer atanırsa ve tip belirtilmezse, Kotlin bu durumu otomatik olarak nullable bir tipe atar. Yani, değişken null olabilecek şekilde tanımlanmış olur. Bu durum, değişkenin kullanımında null check (null kontrolü) yapılmasını gerektirir ve böylece null referans hatalarının önlenmesine yardımcı olur.

-->var nullableString = null

Bu durumda, nullableString değişkeni nullable bir tipe atanır. 
Bu değişkeni kullanırken null check yapmadan doğrudan erişmeye çalışırsanız, derleme zamanında hata alırsınız:

-->val length = nullableString.length // Hata! nullableString null olabilir, null check yapılmalı

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9-İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır? Sorusunun Cevabı:

-->Nullable Olmayan Değişkenler: İlkel bir değişken null değer alamaz. Bu durumda, derleyici değişkenin değerini null olarak atamaya çalıştığınızda hata verir. Bellek yönetimi açısından, bu tür değişkenlerin değerleri derleme zamanında belirlenir ve bellekte sabit bir alan kaplarlar.

-->Nullable Değişkenler: Nullable bir değişken null değer alabilir. Bu durumda, bellekte bu değişkenin değerinin null olabileceği durum da göz önünde bulundurulur. Nullable değişkenler, bellekte ekstra bir işaretçi (pointer) veya işaretçiye ek bir alan kullanır. Bu ekstra işaretçi, değişkenin null olup olmadığını belirtir. Bu nedenle, nullable değişkenler bellekte biraz daha fazla yer kaplar ve bellek yönetimi açısından ekstra bir durumu kontrol etmek gerekebilir.

Bu farklar, nullable olmayan ve nullable değişkenler arasında bellek yönetimi açısından önemli farklar olduğunu gösterir. Nullable değişkenler kullanılırken, ekstra bellek kullanımı ve null değer kontrolü gibi durumlar göz önünde bulundurulmalıdır.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

10-Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?
Sorusunun Cevabı:

-->Değere Sahip Olması: Nullable bir değişkenin bir değere sahip olması durumunda, bellekte bu değeri tutacak kadar alan ayrılır ve değişkenin değeri burada saklanır. Bellekte, değişkenin değerini temsil eden bir veri bulunur.

-->Null Olması: Nullable bir değişken null değer aldığında, bellekte ayrı bir alan ayrılmaz. Null, değişkenin hiçbir değere sahip olmadığını belirtir ve bu durumda değişkenin bellekte bir temsil edilişi olmaz. Dolayısıyla, null değer almış bir değişkenin bellekte bir yer kapladığını söylemek doğru değildir.

Özetle, nullable bir değişkenin bir değere sahip olması durumunda bellekte bu değeri temsil eden bir alan ayrılırken, null olması durumunda ayrı bir alan ayrılmaz ve değişkenin bellekte bir temsil edilişi olmaz. Bu nedenle, null değer almış bir değişkenin bellekte yer kaplamadığını söyleyebiliriz.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

11-Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır? Sorusunun Cevabı:

-->!!: Bu operatör, nullable bir değişkenin null olmadığını garanti etmek için kullanılır. Eğer değişken null ise, NullPointerException hatası fırlatılır. 

Örneğin: 
val nullableString: String? = null
val length = nullableString!!.length // nullableString null olduğu için NullPointerException hatası fırlatır

Bu operatörü kullanırken dikkatli olmak gerekir, çünkü null olabilecek bir değişkenin !! operatörü ile erişilmeye çalışılması hata riskini artırabilir.

-->?.: Bu operatör, nullable bir değişkene güvenli bir şekilde erişmek için kullanılır. Eğer değişken null ise, operatörün sağ tarafı çalışmaz ve sonuç null olur. 

Örneğin:
val nullableString: String? = null
val length = nullableString?.length // length null olarak atanır, NullPointerException hatası oluşmaz

-->Bu operatör, null değer kontrolü yapmak için kullanışlıdır ve genellikle nullable değişkenlere erişirken tercih edilir.
Hangi operatörü kullanmanın daha anlamlı olduğu, duruma ve kullanım senaryosuna bağlıdır. Genel olarak, null olabilecek bir değişkene erişirken ?. operatörünü kullanmak daha güvenlidir, çünkü null değer kontrolü yapılmasını sağlar ve potansiyel NullPointerException hatalarını önler. !! operatörü ise, null olmadığından emin olduğumuz durumlarda kullanılabilir, ancak bu durumda dikkatli olmak ve null olma ihtimalini göz ardı etmemek önemlidir.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Sayılar 

1-Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir? Sorusunun Cevabı:

-->"Number" sınıfını miras alan alt sınıfların sayısı programlama diline bağlı olarak değişebilir. Örneğin, Java programlama dilinde "Number" sınıfını miras alan alt sınıflar arasında "Byte", "Short", "Integer", "Long", "Float" ve "Double" gibi altı tane temel sayı sınıfı bulunmaktadır.

-->Bu alt sınıfların değer aralıkları önemlidir çünkü her bir alt sınıf farklı veri tiplerini temsil eder ve bu veri tiplerinin tutabileceği değer aralıkları farklıdır. Örneğin, "Byte" sınıfı 8 bitlik bir tamsayı değerini temsil ederken, "Integer" sınıfı 32 bitlik bir tamsayı değerini temsil eder. Dolayısıyla, bir değerin hangi alt sınıf tarafından temsil edileceğine karar verirken değerin beklenen değer aralığı önemli bir faktördür.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-






