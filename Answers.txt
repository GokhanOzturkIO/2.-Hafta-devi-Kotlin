#Answers#

1. - `val` ile `var` arasındaki fark nedir?

Cevap: 

Kotlin'de `val` ve `var` arasındaki farklar şunlardır:

### `val` (Değişmez Değerler)
- **Tanım**: `val`, sabit bir değişken tanımlar. Bir `val` değişkeninin değeri ilk atandıktan sonra değiştirilemez.
- **Örnek**: Bir `val` ile değişken tanımlandığında, bu değişkenin değeri yalnızca bir kez atanabilir ve sonrasında değiştirilemez.

  ```kotlin
  val pi = 3.14
  // pi = 3.14159 // Bu satır derleme hatasına neden olur çünkü `pi` bir `val`'dir.
  ```

- **Kullanım Durumları**: `val`, değeri bir kez atanıp değişmeyecekse veya sabit olmasını istiyorsan kullanılır. Özellikle bir nesneye referansın değişmemesi gerektiğinde veya sabit verileri temsil eden değişkenlerde tercih edilir.

### `var` (Değişebilir Değerler)
- **Tanım**: `var`, değiştirilebilir bir değişken tanımlar. Bir `var` değişkeninin değeri program çalıştığı sürece değiştirilebilir.
- **Örnek**: Bir `var` ile değişken tanımladığında, bu değişkenin değeri programın herhangi bir yerinde değiştirilebilir.

  ```kotlin
  var age = 25
  age = 26 // Bu geçerlidir çünkü `age` bir `var`'dır.
  ```

- **Kullanım Durumları**: `var`, değeri değiştirilebilir olan değişkenlerde kullanılır. Değişkenin değerinin farklı durumlarda veya çeşitli işlemler sonucunda değişmesi gerekiyorsa `var` tercih edilir.

### Özet

- **`val`**: Bir kez atandıktan sonra değişmeyen (sabit) değerler için kullanılır.
- **`var`**: Değeri programın herhangi bir yerinde değiştirilebilen değişkenler için kullanılır.

Kotlin'de `val` kullanarak kodunu daha güvenilir ve hatasız hale getirebilirsin, çünkü değişkenin değerinin değişmeyeceğini garanti edersin. `var` ise daha esneklik sağlar ancak değişkenin değerinin beklenmedik bir şekilde değişmesine neden olabilir, bu yüzden kullanım yerlerini dikkatle seçmek gerekir.

### Not: 'val' ile 'var' arasında maliyet farkı var mıdır? şeklinde soru geldiğinde; performans olarak fark yok denecek kadar azdır. 

'val' Value yani değer demektir.
'var' Variable yani değişken demektir.

=================================================================================

2. - Bir `var` değişkeni `val` gibi davranmasını nasıl sağlayabiliriz `val` kelimesini kullanmadan?

Cevap: Bir `var` değişkeninin `val` gibi davranmasını sağlamak, genellikle bir değişkenin değerinin değişmeyeceğini garanti etmek için uygulanabilecek çeşitli yöntemleri içerir. Bununla birlikte, `val` anahtar kelimesini kullanmadan bir `var` değişkenini `val` gibi davranmasını sağlamak için aşağıdaki yöntemlerden bazılarını kullanabilirsin:

### 1. **Kapsülleme (Encapsulation) Kullanarak**
Kapsülleme, bir değişkenin değerinin sadece belirli bir şekilde değişmesini sağlar. Bu, genellikle getter ve setter'lar aracılığıyla yapılır. 

```kotlin
class MyClass {
    private var _value: Int = 0

    val value: Int
        get() = _value

    fun updateValue(newValue: Int) {
        _value = newValue
    }
}
```

Burada `_value` değişkeni `var` olarak tanımlanmıştır, ancak dışarıdan sadece `value` ile erişim sağlanır ve bu erişim sadece okunabilir (sadece getter kullanılır). `updateValue` fonksiyonu ise değeri güncelleyebilir.

### 2. **Özel Bir Setter Kullanarak**
Eğer bir `var` değişkeninin değerinin dışarıdan değiştirilemez olmasını istiyorsan, değişkeni `var` olarak tanımlayıp özel bir setter kullanarak bu davranışı sağlayabilirsin.

```kotlin
class MyClass {
    private var _value: Int = 0

    var value: Int
        get() = _value
        private set(value) {
            _value = value
        }
}
```

Burada `value` değişkeni `private set` ile tanımlanmıştır, yani sadece sınıfın içinde değiştirilebilir.

### 3. **Fonksiyonlar Kullanarak**
Bir değişkenin değerini doğrudan değiştiremezsin, ancak onu bir fonksiyon aracılığıyla değiştirebilirsin. Bu, değişkenin dışarıdan erişimini ve değiştirilmesini kısıtlar.

```kotlin
class MyClass {
    private var _value: Int = 0

    fun getValue(): Int {
        return _value
    }

    fun updateValue(newValue: Int) {
        _value = newValue
    }
}
```

Burada `_value` değişkenine sadece `updateValue` fonksiyonu aracılığıyla erişim sağlanır. `getValue` fonksiyonu ise değerini okur.

### 4. **Immutable Koleksiyonlar Kullanarak**
Eğer bir `List`, `Set` veya `Map` gibi koleksiyon türlerinde değerleri değiştiremeyen bir yapı istiyorsan, immutable koleksiyonlar kullanabilirsin.

```kotlin
class MyClass {
    private val _items: List<String> = listOf("item1", "item2", "item3")

    val items: List<String>
        get() = _items
}
```

Bu durumda, `_items` koleksiyonu değiştirilemez (immutable) ve dışarıdan sadece okunabilir.

### 5. **Delegates Kullanarak**
Kotlin’in `by` anahtar kelimesini kullanarak değişkenler için delegate özellikleri tanımlayabilirsin. Bu, değişkenlerin erişim ve değişim davranışını özelleştirmene olanak tanır.

```kotlin
import kotlin.properties.Delegates

class MyClass {
    var value: Int by Delegates.observable(0) { _, old, new ->
        println("Value changed from $old to $new")
    }
}
```

Burada `Delegates.observable` kullanarak bir `var` değişkenine get/set davranışı eklenmiş olur.

### Özet

`val` kelimesini kullanmadan bir `var` değişkeninin `val` gibi davranmasını sağlamak için:

- **Kapsülleme** yaparak `var` değişkenine dışarıdan sadece okunabilir erişim sağla.
- **Özel Setter** kullanarak değişkeni dışarıdan değiştirilemez hale getir.
- **Fonksiyonlar** kullanarak değişkenin değerini kontrol altına al.
- **Immutable Koleksiyonlar** kullanarak değiştirilemez veri yapıları oluştur.
- **Delegates** kullanarak değişkenlerin erişim ve değişim davranışlarını özelleştir.

Bu yöntemler, değişkenlerinizi kontrol altında tutmanıza ve beklenmedik değişikliklerden korumanıza yardımcı olur.

### Not: kısaca private set(value) yaparak işlemi sağlıyabiliriz.

================================================================================= 

3. - "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. `val` değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

Cevap: Kotlin'de `val` ve `var` değişkenleri arasında önemli farklar vardır ve bu farklar genellikle "değişmez" (immutable) ve "salt okunur" (read-only) kavramlarıyla açıklanır. İşte bu kavramların açıklamaları ve neden `val` değişkenlerin "değişmez" değil, "salt okunur" olarak açıklanması gerektiği:

### 1. **Değişmez (Immutable) Kavramı**

**Değişmez (immutable)** bir nesne, oluşturulduktan sonra herhangi bir durumda değiştirilemeyen bir nesnedir. Değişmezlik, nesnenin durumunun değişmez olduğunu ifade eder. Bu, nesneye atanan değerlerin ve içeriğin sabit kalacağı anlamına gelir. Değişmez nesneler, genellikle uygulama durumunu daha öngörülebilir ve hatasız hale getirmek için kullanılır.

- **Örnek**: Kotlin'de `String` sınıfı bir değişmez nesnedir. Bir `String` nesnesi oluşturulduğunda, bu nesnenin içeriği değiştirilemez. Ancak, yeni bir `String` nesnesi oluşturulabilir.

  ```kotlin
  val str = "Hello"
  val newStr = str + " World"
  // str hala "Hello", newStr ise "Hello World" olur
  ```

### 2. **Salt Okunur (Read-Only) Kavramı**

**Salt okunur (read-only)** bir değişken, bir kez atandıktan sonra değiştirilemez, yani yalnızca okunabilir. Bu, değişkenin değerinin dışarıdan değiştirilemez olduğu anlamına gelir, ancak değişkenin referansının kendisi değiştirilebilir. 

- **Örnek**: Kotlin'de `val` anahtar kelimesi ile tanımlanan değişkenler salt okunur olarak kabul edilir. Bu, değişkenin değerinin atandıktan sonra değiştirilemeyeceği anlamına gelir. Ancak, `val` ile tanımlanan bir değişken, değişkenin referansının kendisi değiştirilebilir.

  ```kotlin
  val list = mutableListOf("item1", "item2")
  list.add("item3")
  // list'in referansı değişmez, ama içeriği değişebilir.
  ```

### 3. **`val` Değişkenler Neden "Salt Okunur" Olarak Açıklanmalıdır?**

Kotlin'deki `val` anahtar kelimesi bir değişkenin salt okunur olduğunu belirtir, yani değişkenin değeri bir kez atandıktan sonra değiştirilemez. Ancak, bu değişkenin referansının kendisi değişmez. Bu nedenle, `val` değişkenler aslında tamamen değişmez (immutable) değildir, çünkü:

- **Nesne Referansları Değişmez**: `val` değişkeninin değeri değiştirilemez, ancak bu değişken bir nesneye referans gösteriyorsa, nesnenin içeriği değiştirilebilir. Örneğin, `val` ile tanımlanan bir `List` değişkeni, bir `mutableListOf` nesnesini referans alıyorsa, listenin içeriği değiştirilebilir.

- **Yalnızca Referansın Değişmezliği**: `val` değişkenleri yalnızca referansın değiştirilemezliğini garanti eder. Eğer değişken bir değişken türü (örneğin, bir liste veya bir nesne) referans alıyorsa, bu referansın gösterdiği nesnenin içeriği değişebilir.

  ```kotlin
  val myList = mutableListOf("apple", "banana")
  myList.add("cherry") // myList'in içeriği değişti, referansı değişmedi
  ```

### Özet

- **Değişmez (Immutable)**: Bir nesnenin oluşturulduktan sonra değişmez olduğunu ifade eder. `String` gibi bazı sınıflar bu özelliğe sahiptir.
- **Salt Okunur (Read-Only)**: Bir değişkenin değeri yalnızca okunabilir ve değiştirilemez, ancak bu değişkenin referansının kendisi değiştirilemez. `val` değişkenleri bu tür değişkenlerdir.

`val` değişkenleri "değişmez" olarak açıklanmak yerine "salt okunur" olarak açıklanmalıdır, çünkü `val` değişkenlerinin referansı değişmez, ancak referansın gösterdiği nesnenin içeriği değiştirilebilir. Bu, `val` değişkenlerinin referanslarıyla ilişkili nesnelerin değiştirilebilirliğini yansıtmaz.


### Not: val değişkenlere genelde immutable dendiğinid uyarsınız fakat bu yanlış bir tabirdir. readonly olarak tanımlanması daha doğrudur.

=================================================================================

4. - "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

"Tip çıkarımı" (type inference), bir programlama dilinde değişkenlerin veya ifadelerin tiplerini otomatik olarak belirleme sürecidir. Bu, programcıların her değişkenin veya ifadenin tipini açıkça belirtmelerine gerek kalmadan, dilin derleyicisinin veya yorumlayıcısının bu bilgiyi otomatik olarak çıkarmasını sağlar. Tip çıkarımı, birçok modern programlama dilinde kullanılır ve genellikle daha kısa, okunabilir ve bakımını kolaylaştıran kodlar yazmayı mümkün kılar.

### Tip Çıkarımının Özellikleri

1. **Otomatik Tip Belirleme**: Programcı, değişkenlerin ve ifadelerin tiplerini açıkça belirtmeden, derleyici veya yorumlayıcı bu bilgiyi kodun analizinden elde eder.
   
2. **Kısaltma ve Temizlik**: Programcılar kodda tekrar tekrar tip bilgisi yazmak zorunda kalmadan, daha kısa ve temiz kodlar yazabilirler.

3. **Gelişmiş Tip Çıkarımı**: Bazı diller, daha karmaşık tip çıkarımı yapabilir, örneğin, generik tiplerde veya fonksiyonların geri dönüş türlerinde.

### Hangi Durumlarda Tip Belirtmek Kesin Olarak Gereklidir?

Tip çıkarımı genellikle birçok durumda oldukça yeterli olabilir, ancak bazı durumlarda tip belirtmek kesinlikle gereklidir:

1. **Çok Anlamlılık (Ambiguity)**: Derleyici ya da yorumlayıcı, bir ifadenin tipini net bir şekilde çıkaramadığında, tip belirtmek gerekebilir. Örneğin, birden fazla olası tip içeren bir işlem yapıldığında, hangi tipin kullanılacağını belirtmek önemli olabilir.

2. **Tip Güvenliği**: Tip güvenliğini sağlamak için, özellikle karmaşık yapıların ve fonksiyonların doğru çalışması için tiplerin açıkça belirtilmesi gerekebilir. Bu, hataların daha erken aşamalarda tespit edilmesine yardımcı olabilir.

3. **Performans**: Bazı durumlarda, belirli bir türün açıkça belirtilmesi, derleyicinin kodun daha etkili bir şekilde optimize edilmesini sağlayabilir.

4. **Okunabilirlik ve Bakım**: Karmaşık kodlarda, özellikle tiplerin net bir şekilde belirtilmesi, kodun okunabilirliğini ve bakımını kolaylaştırabilir.

5. **Dış Kütüphaneler ve API'ler**: Bir dış kütüphaneyi veya API'yi kullanırken, doğru tiplerin belirtilmesi, kütüphanenin beklediği veri türlerini ve işlevselliği doğru bir şekilde kullanmanızı sağlar.

### Örnekler

- **Python** (dinamik tip çıkarımı): 

  ```python
  x = 10  # Python otomatik olarak x'in bir int olduğunu çıkarır.
  y = "Hello"  # Python otomatik olarak y'nin bir str olduğunu çıkarır.
  ```

- **Haskell** (statik tip çıkarımı): 

  ```haskell
  double :: Int -> Int
  double x = x * 2  -- Haskell, 'x' ve fonksiyonun döndüreceği tiplerin Int olduğunu çıkarır.
  ```

- **C++** (auto anahtar kelimesi ile tip çıkarımı):

  ```cpp
  auto x = 10;  // Derleyici x'in int olduğunu çıkarır.
  auto y = 3.14;  // Derleyici y'nin double olduğunu çıkarır.
  ```

Tip çıkarımı, doğru kullanıldığında programlama sürecini oldukça kolaylaştırabilir, ancak programcıların tiplerin ne anlama geldiğini ve potansiyel hataları iyi anlamaları her zaman önemlidir.


### Not: Bir değişken tipinin "=" sağ tarafında ki veriye bakarak belirlenmesi işlemidir. Ancak sayısal değerlerde verilen değer ınt içerisindeyse... int üzerindeyse long set ediliri.

=================================================================================

5. - Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

Cevap: Kotlin'de, tüm değişkenler bir sınıf olarak bulunur; ancak bu, Kotlin’in ilkel tipleri desteklemediği anlamına gelmez. Kotlin, Java sanal makinesi (JVM) üzerinde çalıştığı için, bazı optimizasyonlar ve performans iyileştirmeleri için ilkel tipleri (primitive types) kullanır. İşte detaylar:

### Kotlin'de Değişkenler ve İlgili Kavramlar

1. **Sınıf Temelli Değişkenler**: Kotlin'de, temel veri türleri (örneğin `Int`, `Double`, `Boolean`) sınıf türleri olarak temsil edilir. Ancak, bu sınıflar JVM'de karşılık gelen ilkel tiplerle (primitive types) optimize edilir.

2. **İlkel Tipler ve Wrapper Sınıflar**: Kotlin'de, ilkel tipler `Int`, `Double`, `Char`, `Boolean`, vb., JVM tarafından yönetilen ilkel türler olarak kullanılır. JVM düzeyinde, bu türler performans için doğrudan bellek erişimi ve işlem yapılabilir. Kotlin, bu ilkel türlerle çalışan kodları yazarken, bu türleri otomatik olarak `int`, `double`, `char`, `boolean` gibi ilkel türlerle optimize eder.

3. **Autoboxing ve Unboxing**: Kotlin, JVM ile uyumluluk sağlamak için `autoboxing` (ilkel tiplerin nesne türlerine dönüştürülmesi) ve `unboxing` (nesne türlerinin ilkel tiplere dönüştürülmesi) işlemlerini otomatik olarak yönetir. Kotlin kodu yazarken, bu dönüşümler genellikle programcı tarafından görünmez.

4. **Performans İyileştirmeleri**: Kotlin, temel veri türlerini JVM'de ilkel türler olarak kullanır. Örneğin, bir `Int` değişkeni Kotlin kodunda bir `Integer` nesnesi gibi görünebilir, ancak JVM tarafından doğrudan `int` türünde işlenir. Bu, performans iyileştirmeleri sağlar çünkü ilkel türler bellek ve işlem açısından daha verimlidir.

### Arka Planda Neler Oluyor?

- **JVM Optimizasyonları**: Kotlin kodu derlendiğinde, değişkenler JVM ilkel türleri olarak işlenir. Örneğin, `Int` tipi Kotlin’de `int` olarak, `Double` tipi `double` olarak derlenir. Bu, Kotlin’in hem nesne yönelimli programlama yapısını hem de ilkel türlerin performans avantajlarını bir araya getirir.

- **Nesne ve İlkel Tiplerin Dönüşümleri**: Kotlin, nesne ve ilkel tipler arasındaki dönüşümleri otomatik olarak yönetir. Bu dönüşümler, performans üzerinde büyük bir etki yapabilir, özellikle büyük veri yapıları veya yoğun işlem gerektiren hesaplamalarda.

- **Kotlin `Boxing` ve `Unboxing`**: Kotlin, `Integer`, `Double`, vb. gibi wrapper sınıflarını kullanırken, otomatik olarak `boxing` (ilkel türleri nesne türlerine dönüştürme) ve `unboxing` (nesne türlerini ilkel türlere dönüştürme) işlemlerini yapar. Bu işlemler JVM tarafından optimizasyonlar sayesinde çoğu zaman etkisiz hale getirilir, yani performans üzerinde minimal bir etki yaratır.

### Özet

Kotlin’de temel veri türleri, arka planda JVM tarafından ilkel türler olarak optimize edilir. Bu, Kotlin’in hem nesne yönelimli programlama özelliklerinden faydalandığını hem de performans için ilkel türlerin avantajlarını kullandığını gösterir. Kotlin kodunuzda değişkenler sınıf türleri olarak görünebilir, ancak bu genellikle JVM düzeyinde ilkel türlerle optimize edilir, bu da hem okunabilirlik hem de performans açısından avantaj sağlar.

=================================================================================

6. - "Tip Güvenliği" (Type Safety) kavramını açıklayın.

Cevap:

"Tip Güvenliği" (Type Safety), bir programlama dilinin veya sisteminin, tiplerle ilgili hataları önleyerek veri türlerinin beklenmedik veya yanlış kullanımlarını engelleme yeteneğidir. Bu, kodun daha güvenilir ve hata yapmaya daha az eğilimli olmasını sağlar. Tip güvenliği, türlerin doğru bir şekilde kullanıldığını ve tür uyumsuzluklarından kaynaklanan hataların minimize edildiğini garanti eder.

### Tip Güvenliğinin Temel Özellikleri

1. **Tür Doğrulama**: Tip güvenliği, değişkenlerin, fonksiyonların ve diğer ifadelerin beklenen türlerle uyumlu olup olmadığını kontrol eder. Bu, derleme zamanı (compile-time) veya çalışma zamanı (runtime) hatalarını önlemeye yardımcı olur.

2. **Tür Dönüşümleri**: Tip güvenliği, tür dönüşümlerinin güvenli bir şekilde yapılmasını sağlar. Örneğin, bir türün başka bir türe dönüştürülmesi gerektiğinde, bu dönüşümün geçerli olup olmadığını kontrol eder.

3. **Tür Güvenliği ve Hatalar**: Tip güvenliği, tür uyumsuzlukları veya hatalı tür kullanımları gibi sorunları tespit eder ve bu tür hataları derleme zamanı veya çalışma zamanı hataları olarak bildirebilir.

4. **Kapsama (Encapsulation)**: Tip güvenliği, kapsama ilkesine göre, belirli bir türün iç yapısının ve işleyişinin yalnızca uygun yöntemlerle erişilmesini ve değiştirilmesini sağlar. Bu, veri bütünlüğünü korur ve kodun güvenliğini artırır.

5. **Fonksiyonların ve Yöntemlerin Türleri**: Fonksiyonların ve yöntemlerin giriş ve çıkış türlerinin doğru bir şekilde tanımlanması ve bu türlerin doğru şekilde kullanılması, tip güvenliğinin bir parçasıdır.

### Tip Güvenliği Sağlayan Özellikler

1. **Statik ve Dinamik Tip Kontrolleri**:
   - **Statik Tip Kontrolü**: Türler derleme zamanında kontrol edilir. Örneğin, Java ve Kotlin gibi statik tipli dillerde, tür hataları derleme zamanında tespit edilir.
   - **Dinamik Tip Kontrolü**: Türler çalışma zamanında kontrol edilir. Python ve JavaScript gibi dinamik tipli dillerde, tür hataları çalışma zamanında ortaya çıkabilir.

2. **Tür Çıkarsaması ve Güvenliği**: Modern diller, tür çıkarımı (type inference) ve tür güvenliğini birleştirerek, programcıların türleri açıkça belirtmeden tür güvenliğini sağlamalarına yardımcı olur.

3. **Tür Sınırlamaları ve Kısıtlamaları**: Generics veya benzeri mekanizmalar kullanarak, belirli türlerle çalışırken tür sınırlamaları belirleyebilir ve tür uyumluluğunu garanti edebilirsiniz.

### Örnekler

- **Java** (Statik Tip Güvenliği):

  ```java
  public void printLength(String str) {
      // str değişkeninin türü String olduğu için, bu fonksiyon yalnızca String türündeki argümanlarla çalışabilir.
      System.out.println(str.length());
  }
  ```

  Java, derleme zamanında `printLength` fonksiyonuna yalnızca `String` türündeki argümanların geçilmesini sağlar.

- **Python** (Dinamik Tip Güvenliği):

  ```python
  def print_length(s):
      if isinstance(s, str):
          print(len(s))
      else:
          raise TypeError("Argument must be a string")
  ```

  Python, çalışma zamanında tür kontrolü yaparak, `print_length` fonksiyonuna yalnızca `str` türündeki argümanların geçilmesini sağlar.

### Önemi ve Faydaları

1. **Hata Azaltma**: Tip güvenliği, tip hatalarının erken aşamalarda tespit edilmesini sağlar, bu da kodda hata oranını azaltır.

2. **Kod Okunabilirliği ve Bakımı**: Tip güvenliği, kodun hangi türde verilerle çalıştığını net bir şekilde belirler, bu da kodun okunabilirliğini ve bakımını kolaylaştırır.

3. **Güvenlik**: Yanlış tür kullanımları, güvenlik açıklarına neden olabilir. Tip güvenliği, bu tür güvenlik açıklarını önlemeye yardımcı olur.

Tip güvenliği, modern yazılım geliştirme süreçlerinde kritik bir rol oynar ve hem yazılım kalitesini hem de güvenliğini artıran önemli bir özelliktir.

=================================================================================

7.- Bir değişkeni nullable yapmak için ne yapmalıyız?

Cevap:

Bir değişkeni nullable yapmak, yani değişkenin `null` değerini alabilmesine izin vermek, çoğu modern programlama dilinde belirli bir sentaks ve kurallar gerektirir. `null` değerinin bir değişken için geçerli bir değer olmasına izin vermek, kodun null güvenliği ve veri bütünlüğü açısından dikkatle yönetilmesi gereken bir durumdur. İşte çeşitli dillerde bir değişkeni nullable yapmak için yapmanız gerekenler:

### Kotlin

Kotlin’de değişkenleri nullable yapmak için tiplerin sonuna `?` işareti eklenir. Bu, değişkenin belirtilen tipin yanı sıra `null` değerini de alabileceğini ifade eder.

**Örnek:**

```kotlin
var name: String? = null
name = "Alice"
```

Burada, `name` değişkeni `String` tipinde olabilir, ancak aynı zamanda `null` da olabilir.

### Java

Java’da nullable tipleri belirtmek için genellikle `null` değerini doğrudan kullanabilirsiniz. Java’nın dil yapısı, her referans tipinin `null` olabilmesine izin verir, bu yüzden ekstra bir sözdizimi gerekmez.

**Örnek:**

```java
String name = null;
name = "Alice";
```

Ancak, Java 14 ile gelen `NullPointerException` hatalarını önlemek için `Optional` sınıfı kullanılabilir. `Optional` bir değerin olup olmadığını belirtmek için kullanılır, ancak bu tamamen nullable davranışını değiştirmez, sadece kontrol etmenin bir yoludur.

**Örnek:**

```java
import java.util.Optional;

Optional<String> name = Optional.empty();
name = Optional.of("Alice");
```

### C#

C# dilinde bir değişkenin nullable olmasını sağlamak için tipin sonuna `?` işareti eklenir, benzer şekilde Kotlin’de olduğu gibi.

**Örnek:**

```csharp
int? age = null;
age = 25;
```

Burada, `int?` tipi, `int` tipiyle birlikte `null` değerini de alabilir.

### Swift

Swift dilinde bir değişkeni nullable yapmak için, tipin sonuna `?` işareti eklenir. Bu, değişkenin belirtilen tipin yanı sıra `nil` değerini de alabileceğini ifade eder.

**Örnek:**

```swift
var name: String? = nil
name = "Alice"
```

### TypeScript

TypeScript’de bir değişkenin nullable olmasını sağlamak için tipin yanına `null` ve/veya `undefined` eklenir. TypeScript’in tip sistemi, `null` ve `undefined` ile ilgili esneklik sağlar.

**Örnek:**

```typescript
let name: string | null = null;
name = "Alice";
```

### Python

Python’da değişkenler varsayılan olarak nullable’dır çünkü `None` değeri alabilirler. Bu nedenle özel bir sentaks gerekmez.

**Örnek:**

```python
name: str = None
name = "Alice"
```

### Özet

Bir değişkenin nullable olmasını sağlamak, her dilde farklı şekilde yapılabilir, ancak genellikle tipin üzerine `?` işareti eklemek, `null` veya `nil` değeri kullanmak gibi işlemler gerektirir. Her dilin kendi syntax ve kurallarına göre bu işlemleri gerçekleştirirsiniz. Null değerlerinin yönetilmesi, veri güvenliği ve hataların önlenmesi açısından dikkatli bir şekilde yapılmalıdır.

=================================================================================

8. - "Null Güvenliği" (Null Safety) kavramını açıklayın.

Cevap:

"Null Güvenliği" (Null Safety), bir programlama dilinin veya sisteminin `null` değerlerle ilgili sorunları minimize etme ve programda `null` referanslarıyla ilgili hataları önleme yeteneğidir. `null` değerleri, programlama dillerinde sıklıkla hatalara ve beklenmedik davranışlara neden olabilir; bu yüzden null güvenliği, bu tür hataları önlemek ve yazılımın güvenilirliğini artırmak amacıyla geliştirilmiş bir özelliktir.

### Null Güvenliğinin Temel Özellikleri

1. **Null Değerlerini Engelleme**: Null güvenliği, bir değişkenin `null` değerini alıp almayacağını belirler ve bu tür değerlerin doğru bir şekilde yönetilmesini sağlar. Null güvenliği olan diller, değişkenlerin `null` olabileceğini açıkça belirtmenizi gerektirebilir.

2. **Statik ve Dinamik Kontroller**: 
   - **Statik Kontroller**: Derleme zamanında (`compile-time`) `null` değerleriyle ilgili hataları tespit eder. Bu, kodun derlenmesi sırasında `null` referans hatalarının önceden belirlenmesini sağlar.
   - **Dinamik Kontroller**: Çalışma zamanında (`runtime`) `null` değerlerle ilgili hataları tespit eder ve yönetir. Bu, uygulamanın çalışırken `null` değerlerinden kaynaklanan hataları yakalar.

3. **Null Değerlerini Yönetme**: Null güvenliği, `null` değerlerinin nasıl yönetileceğini belirler. Bu, `null` değerlerinin nasıl atanacağı, kontrol edileceği ve kullanılacağı ile ilgilidir.

4. **Güvenli Null Dönüşümü ve Erişim**: Null güvenliği, değişkenlerin `null` olup olmadığını güvenli bir şekilde kontrol etmenizi sağlar ve `null` değerlerinin erişim hatalarını önler.

### Null Güvenliği Sağlayan Özellikler

1. **Null Kontrolü**: Bir değişkenin `null` olup olmadığını kontrol etmek için çeşitli yöntemler sağlar. Bu, programın `null` referans hatalarını önlemesine yardımcı olur.

2. **Null İçin Kısıtlamalar**: Bazı diller, bir değişkenin `null` değerini alıp almayacağını açıkça belirtmenizi gerektirir. Bu, kodun daha güvenilir olmasını sağlar.

3. **Opsiyonel Tipler ve Alternatifler**: Bazı diller, `null` yerine opsiyonel tipler veya güvenli `null` alternatifleri kullanır. Bu, kodun `null` değerlerinden kaynaklanan hataları azaltır.

### Örnekler

- **Kotlin**:

  Kotlin, `null` güvenliğini dil seviyesinde sağlar. Değişkenler varsayılan olarak non-null (null olmayan) kabul edilir. Bir değişkenin `null` olmasına izin vermek için `?` işareti kullanılır.

  **Örnek:**

  ```kotlin
  var name: String = "Alice"   // Non-nullable
  var address: String? = null  // Nullable

  // Null kontrolü
  if (address != null) {
      println(address.length)
  }
  ```

  Kotlin, `null` değerlerle ilgili hataları derleme zamanında tespit eder ve bu tür değerlerle çalışmayı güvenli hale getirir.

- **Java**:

  Java, `null` güvenliğini doğrudan dil seviyesinde sağlamaz, ancak Java 14 ve sonrasında `NullPointerException` hatalarını önlemek için `Optional` sınıfı kullanılabilir.

  **Örnek:**

  ```java
  import java.util.Optional;

  Optional<String> name = Optional.ofNullable(null);
  name.ifPresent(n -> System.out.println(n.length()));
  ```

  Burada, `Optional` kullanarak `null` değerlerini güvenli bir şekilde yönetebilirsiniz.

- **Swift**:

  Swift, `nil` güvenliğini dil seviyesinde sağlar. Bir değişkenin `nil` olabilmesi için `?` işareti kullanılır.

  **Örnek:**

  ```swift
  var name: String? = nil
  name = "Alice"

  // Nil kontrolü
  if let unwrappedName = name {
      print(unwrappedName.count)
  }
  ```

  Swift, `nil` değerlerini yönetme konusunda sağlam bir destek sağlar ve bu tür değerlerle güvenli bir şekilde çalışmanızı sağlar.

- **TypeScript**:

  TypeScript’de, bir değişkenin `null` veya `undefined` olabileceğini belirtmek için `null` ve `undefined` türleri kullanılabilir.

  **Örnek:**

  ```typescript
  let name: string | null = null;
  name = "Alice";

  // Null kontrolü
  if (name !== null) {
      console.log(name.length);
  }
  ```

  TypeScript, `null` ve `undefined` değerlerini kontrol etmek için çeşitli yollar sağlar.

### Özet

Null güvenliği, yazılım geliştirmede önemli bir rol oynar çünkü `null` değerleri çoğu zaman program hatalarına ve güvenlik açıklarına neden olabilir. Modern programlama dilleri, `null` güvenliğini sağlamak için çeşitli mekanizmalar sunar, bu da programcıların daha güvenilir, hatasız ve bakımı daha kolay kodlar yazmalarına yardımcı olur.

=================================================================================

9. - Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

Cevap: Kotlin'de bir değişkene `null` değer atanırsa ve değişkenin tipi belirtilmemişse, Kotlin derleyicisi bu değişkenin tipini çıkaramaz ve bu durumda derleme hatası alırsınız. Kotlin, değişkenlerin tiplerini belirlemek için sıkı kurallar uygular ve tür belirlemesi yapmadan `null` değer atanmasına izin vermez.

### Kotlin’de Tip Belirtilmediğinde `null` Atama

Kotlin'de, bir değişkenin tipi belirtilmeden `null` değeri atanırsa, bu durumda derleyici hata verir çünkü Kotlin, `null` değerini hangi türde bir değişkene atayacağını bilmez. Kotlin, tip güvenliği sağlar ve bu nedenle tüm değişkenlerin belirli bir türle ilişkilendirilmiş olması gerekir.

**Örnek:**

```kotlin
val myVariable = null  // Derleme hatası: Null can not be a value of a non-null type Nothing
```

Bu kodda, `myVariable` değişkeninin tipi belirlenmediği için ve `null` değeri atanmış olduğundan, Kotlin derleyicisi bu değişkenin türünü belirleyemez ve bir hata verir. Kotlin, `null` değeri belirli bir türle ilişkilendirilmediğinde, türün ne olması gerektiğini bilemez ve bu nedenle `Nothing` türünü varsayar. Ancak, `Nothing` türü, bir değişkene `null` atanamayacak bir türdür.

### Nullable Türler ile Çalışmak

Kotlin’de `null` değerlerini kullanabilmek için, değişkenin nullable bir tür olarak tanımlanması gerekir. Bu, tipin sonuna `?` işareti eklenerek yapılır.

**Örnek:**

```kotlin
var myVariable: String? = null  // Bu geçerlidir çünkü String? nullable bir türdür.
```

Bu örnekte, `myVariable` değişkeninin türü `String?` olarak belirtilmiştir, bu da değişkenin `String` türünde bir değer veya `null` olabileceği anlamına gelir.

### Kotlin’de Null Güvenliği

Kotlin’in null güvenliği, programcıların değişkenlerin türlerini ve `null` değerlerini açıkça belirtmelerini ve bu tür değerlerle güvenli bir şekilde çalışmayı sağlar. Bu, kodun daha güvenilir ve hatalardan arınmış olmasını sağlar. 

Özetle, Kotlin’de bir değişkenin tipi belirtilmeden `null` değer atanırsa, derleyici hata verir ve değişkenin türünü belirlemez. `null` değerlerle çalışmak için türlerin açıkça belirtilmesi ve nullable türlerin kullanılması gerekir.


=================================================================================

10. - İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

Cevap: İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından bazı önemli farklar vardır. Bu farklar, hem bellek kullanımını hem de performansı etkileyebilir. İşte bu iki durum arasındaki farklar:

### 1. **Bellek Kullanımı**

#### Nullable İlkel Türler:
- **Nesne ve Wrapper Sınıfları**: Bir değişken nullable olduğunda, dil tarafından nesne olarak yönetilmesi gerekebilir. Örneğin, Java'da `Integer` gibi wrapper sınıfları kullanıldığında, `null` değerini temsil edebilmek için ek bellek alanı kullanılır.
  
  ```java
  Integer nullableInt = null;  // Bu bir nesnedir ve JVM'de `null` olabilir.
  ```

  Burada, `Integer` bir wrapper sınıfıdır ve `null` değeri alabilir. Bu durumda, değişken bellek üzerinde bir nesne referansı içerir ve `null` olması için ek bellek yönetimi gerektirir.

- **Kotlin ve Nullable Türler**: Kotlin'de `Int?` gibi nullable türler kullanıldığında, bu türler genellikle bir wrapper nesnesi gibi yönetilir.

  ```kotlin
  var nullableInt: Int? = null
  ```

  `Int?` nullable türü, arka planda `null` değerini yönetmek için ek bellek kullanımı gerektirebilir.

#### Null Olmayan İlkel Türler:
- **Doğrudan Bellek Kullanımı**: İlkel türler (örneğin, `int`, `char`, `boolean` gibi) doğrudan bellek içinde saklanır ve `null` değeri almazlar. Bellek üzerinde yalnızca değerler saklanır ve ek bir bellek yönetimi gerekmez.

  ```java
  int nonNullableInt = 10;  // İlkel bir türdür ve null değeri almaz.
  ```

  Burada, `nonNullableInt` doğrudan bellek içinde bir değer saklar ve `null` değeri almak için ek bir bellek alanı gerekmez.

### 2. **Performans**

#### Nullable İlkel Türler:
- **Nesne Referansları ve Ek İşlemler**: Nullable türler, genellikle nesne referansları olarak yönetilir ve bu nesnelerin `null` olup olmadığını kontrol etmek için ek işlemler yapılır. Bu, performans üzerinde bir etki yaratabilir çünkü her `null` kontrolü veya dönüşümü ek işlem gerektirir.

- **Boxing ve Unboxing**: Nullable türlerin kullanımı, boxing ve unboxing işlemlerini içerebilir. Bu işlemler, ilkel türlerin nesne türlerine dönüştürülmesini ve geri dönüşümünü içerir ve bu da performans üzerinde ek bir yük getirebilir.

#### Null Olmayan İlkel Türler:
- **Doğrudan Erişim ve Performans**: İlkel türler doğrudan bellek içinde saklanır ve bu nedenle daha hızlı erişim ve işleme sağlarlar. `null` değerleriyle ilgili ek işlemler veya kontroller gerektirmez.

- **Düşük Bellek Overhead**: İlkel türler, bellek yönetimi açısından daha verimlidir çünkü ek bir nesne referansı içermezler ve bu nedenle bellek overhead'i daha düşüktür.

### 3. **Null Güvenliği ve Kod Güvenilirliği**

#### Nullable İlkel Türler:
- **Daha Fazla Güvenlik Sağlar**: Nullable türler, `null` değerlerinin açıkça belirtildiği ve yönetildiği durumlarda daha güvenli olabilir. Bu, `null` referans hatalarının kod yazımında daha iyi yönetilmesini sağlar.

#### Null Olmayan İlkel Türler:
- **Hata Riski Azaltılır**: İlkel türlerin `null` değerlerini kabul etmemesi, `null` referans hatalarını tamamen ortadan kaldırır. Bu, bazı durumlarda kodun daha güvenilir olmasına yardımcı olabilir.

### Özet

- **Bellek Yönetimi**: Nullable türler genellikle ek bellek yönetimi gerektirir çünkü `null` değerlerini yönetmek için nesne referansları kullanılır. İlkel türler, doğrudan bellek içinde değerleri saklar ve bu nedenle daha az bellek overhead'i ve daha hızlı erişim sağlar.

- **Performans**: Nullable türlerin kullanımı, boxing, unboxing ve `null` kontrolleri gibi ek işlemleri içerdiği için performans üzerinde etkili olabilir. İlkel türler doğrudan bellek erişimi sağlar ve bu nedenle daha yüksek performans sunar.

- **Kod Güvenilirliği**: Nullable türler, `null` değerlerinin yönetilmesine olanak tanır ve bu da kodun daha güvenilir ve hatasız olmasını sağlayabilir. İlkel türler, `null` referans hatalarını önleyerek bazı güvenilirlik avantajları sağlar.

Her iki yaklaşımın da avantajları ve dezavantajları vardır ve hangi yaklaşımın kullanılacağı, uygulamanın gereksinimlerine ve performans hedeflerine bağlıdır.

=================================================================================

11. - Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?

Cevap: Nullable bir değişkenin bir değere sahip olması ile `null` olması arasında bellek yönetimi açısından önemli farklar bulunmaktadır. Bu farklar, bellek kullanımı, performans ve bellek overhead'i ile ilgilidir.

### 1. Bellek Kullanımı

#### Nullable Bir Değişkenin Bir Değere Sahip Olması:
- **Nesne Referansı ve Bellek Tüketimi**: Eğer bir değişken nullable olarak tanımlanmışsa ve bir değere sahipse, bu değişken tipine bağlı olarak, bellekte veri saklaması gerekir. Örneğin, Java'da `Integer` gibi bir wrapper sınıfı kullanıldığında, değişken bir `Integer` nesnesi referansı içerir ve bu nesne bellek üzerinde saklanır.
  
  ```java
  Integer myInteger = 10;  // Bellekte bir Integer nesnesi saklanır.
  ```

  Bu durumda, değişkenin bellekte yer kaplaması, tipine ve nesne referanslarına bağlı olarak değişir. Bellekte, `Integer` nesnesinin verileri (örneğin, `10`) ve nesnenin kendisi için ek bir alan bulunur.

#### Nullable Bir Değişkenin `null` Olması:
- **Referanslar ve Bellek Tüketimi**: Bir nullable değişken `null` olduğunda, bu değişkenin kendisi için bir nesne referansı bellek üzerinde yer kaplar, ancak bu referans `null` olduğunda veri saklanmaz. Bellekte, bu durumda sadece bir referans işareti bulunur, ancak gerçek veri saklanmaz.

  ```java
  Integer myInteger = null;  // Bellekte sadece bir referans işareti saklanır.
  ```

  `null` değeri, bellek üzerinde gerçek bir veri saklamaz. Ancak, referans türleri için, değişkenin kendisi bir bellek alanı kaplar (örneğin, bir nesne referansı).

### 2. Bellek Overhead ve Performans

#### Bellek Overhead:
- **Nullable ve Değerli Değişkenler**: Nullable değişkenler, bir değer içerdiğinde, bu değişkenin bellekte yer kaplaması gerekir. Özellikle wrapper sınıfları veya nesneler kullanılıyorsa, bu nesnelerin bellekte yer kaplaması ve yönetimi gerekir.

- **Null Referanslar**: Bir değişken `null` olduğunda, gerçek veri saklanmaz. Ancak, referans türleri için, `null` olan bir değişkenin kendisi bellekte bir referans alanı kaplar (bu genellikle çok küçük bir bellek miktarıdır).

#### Performans:
- **Nullable Türler**: Nullable türlerle çalışırken, `null` kontrolleri ve `null` değerlerinin yönetilmesi performans üzerinde etkilidir. Nullable türlerin boxing ve unboxing işlemleri de performansı etkileyebilir.

- **İlkel Türler**: İlkel türler, `null` değerlerini kabul etmedikleri için daha basit ve doğrudan bellek erişimi sağlar. Bu nedenle, ilkel türler genellikle daha az bellek overhead'i ve daha yüksek performans sunar.

### Özet

- **Bellek Yönetimi**: Nullable değişkenler için, bir değer atandığında bu değer bellekte yer kaplar. Ancak, değişken `null` olduğunda, gerçek veri saklanmadığı için yalnızca bir referans alanı kaplanır. Bu referans alanı küçük bir bellek kullanımı sağlar, ancak veri saklamaz.

- **Bellek Kullanımı**: `null` olan bir değişken, veri saklamaz ve bu nedenle bellekte gerçek veri kaplamaz. Ancak, bir nesne referansı içerdiği için bazı bellek alanı kaplar.

- **Performans ve Overhead**: Nullable türlerin performansı, `null` kontrolleri ve boxing/unboxing işlemleri nedeniyle etkilenebilir. İlkel türler, genellikle daha düşük bellek overhead'i ve daha yüksek performans sağlar.

Sonuç olarak, `null` değerine sahip bir değişkenin bellekte yer kaplamadığı ve gerçek veri saklamadığı doğru olsa da, değişkenin kendisi bir referans alanı kaplar. Değişkenin değeri `null` olduğunda, bellek kullanımı genellikle daha düşüktür, ancak referans türleri ile ilgili bazı ek maliyetler olabilir.

=================================================================================

12. - Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır?

Cevap: Nullable bir değişkenle çalışırken, yani değeri `null` olabilen bir değişkenle çalışırken, genellikle aşağıdaki operatörleri kullanırız:

1. **Null-Coalescing Operatörü (`??`):**
   - **Kullanım**: Bir değişken `null` olduğunda, varsayılan bir değer döndürmek için kullanılır.
   - **Örnek**: 
     ```csharp
     int? value = null;
     int result = value ?? 10; // result 10 olur
     ```
   - **Açıklama**: Eğer `value` değişkeni `null` ise, `10` döndürülür. Aksi takdirde `value`'nun kendisi döndürülür. Bu, `null` durumunu kontrol etmenin ve varsayılan bir değer sağlamanın basit bir yoludur.

2. **Null-Conditional Operatörü (`?.`):**
   - **Kullanım**: Bir nesne `null` olduğunda, metot veya özellik çağrısı yapmadan önce güvenli bir şekilde kontrol etmek için kullanılır.
   - **Örnek**:
     ```csharp
     Person person = null;
     string name = person?.Name; // name değişkeni null olur, person null olduğu için
     ```
   - **Açıklama**: Eğer `person` nesnesi `null` ise, `Name` özelliğine erişmeye çalışmak yerine `name` değişkeni `null` olur. Bu, `null` referans hatalarını önlemek için kullanışlıdır.

3. **Null-Conditional Index Operatörü (`?.[]`):**
   - **Kullanım**: Bir koleksiyon veya dizinin `null` olup olmadığını kontrol ederek, güvenli bir şekilde öğeye erişmek için kullanılır.
   - **Örnek**:
     ```csharp
     int[] numbers = null;
     int? number = numbers?.ElementAtOrDefault(0); // number değişkeni null olur, numbers null olduğu için
     ```
   - **Açıklama**: Eğer `numbers` dizisi `null` ise, `ElementAtOrDefault(0)` çağrısı yapmadan `number` değişkeni `null` olur. Bu, koleksiyon erişimlerinde `null` referans hatalarını önlemeye yardımcı olur.

4. **Null-Conditional Method Call (`?.Method()`):**
   - **Kullanım**: Bir nesnenin `null` olup olmadığını kontrol ederek, metot çağrısı yapmadan önce güvenli bir şekilde çalışmak için kullanılır.
   - **Örnek**:
     ```csharp
     MyClass myClass = null;
     myClass?.DoSomething(); // DoSomething metodu çağrılmaz çünkü myClass null
     ```
   - **Açıklama**: Eğer `myClass` nesnesi `null` ise, `DoSomething` metodu çağrılmaz. Bu, `null` referans hatalarını engellemek için faydalıdır.

**Hangisini Ne Zaman Kullanmalıyız?**

- **Null-Coalescing Operatörü (`??`)**: Bir değişkenin `null` olma olasılığını kontrol ederken ve `null` olduğunda varsayılan bir değer sağlamak istiyorsanız kullanılır.
- **Null-Conditional Operatörü (`?.`)**: Bir nesnenin `null` olup olmadığını kontrol etmek ve `null` durumunda bir işlem yapmaktan kaçınmak istiyorsanız kullanılır.
- **Null-Conditional Index Operatörü (`?.[]`)**: Bir koleksiyon veya dizinin `null` olup olmadığını kontrol ederek öğeye güvenli bir şekilde erişmek istiyorsanız kullanılır.
- **Null-Conditional Method Call (`?.Method()`)**: Bir nesnenin `null` olup olmadığını kontrol ederek metot çağrısı yapmadan önce güvenli bir işlem yapmak istiyorsanız kullanılır.

Bu operatörler, nullable değişkenlerle çalışırken kodunuzun daha güvenli ve okunabilir olmasını sağlar.


=================================================================================


### Sayılar

1. - Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?

Cevap: "Number" sınıfını miras alan çeşitli alt sınıflar, farklı programlama dillerinde ve ortamlarında bulunabilir. Burada genel olarak **Java** gibi dillerdeki `Number` sınıfını ve onun alt sınıflarını ele alacağız. 

Java'da `Number` sınıfı, sayısal değerlerin temsilini standartlaştıran bir soyut sınıftır ve birçok alt sınıfı vardır. İşte Java'daki `Number` sınıfından türeyen başlıca alt sınıflar:

### Java'daki `Number` Sınıfının Alt Sınıfları:

1. **`Byte`**: 8-bit işaretli tamsayı. Değer aralığı: `-128` ile `127` arasında.
2. **`Short`**: 16-bit işaretli tamsayı. Değer aralığı: `-32,768` ile `32,767` arasında.
3. **`Integer`**: 32-bit işaretli tamsayı. Değer aralığı: `-2^31` (yaklaşık `-2.1 milyar`) ile `2^31 - 1` (yaklaşık `2.1 milyar`) arasında.
4. **`Long`**: 64-bit işaretli tamsayı. Değer aralığı: `-2^63` (yaklaşık `-9.2x10^18`) ile `2^63 - 1` (yaklaşık `9.2x10^18`) arasında.
5. **`Float`**: 32-bit kayan nokta sayısı. Yaklaşık `1.4E-45` ile `3.4E38` arasında.
6. **`Double`**: 64-bit kayan nokta sayısı. Yaklaşık `4.9E-324` ile `1.8E308` arasında.

### Değer Aralıklarının Önemi:

Değer aralıkları, programlama ve yazılım geliştirme süreçlerinde birkaç önemli neden için kritiktir:

1. **Hafıza Kullanımı:** Her veri tipi belirli bir hafıza alanı kullanır. Küçük aralıklı veri türleri (`byte`, `short`) daha az bellek tüketir ve bu, büyük veri kümesine sahip uygulamalarda hafıza verimliliği sağlar. Ancak, değer aralıkları sınırlı olduğunda, sayı taşması (overflow) riskleri de artar.

2. **Performans:** Genellikle daha küçük veri türleri işlemci tarafından daha hızlı işlenebilir çünkü işlemci daha az veri ile çalışır. Ancak, bu her zaman doğru olmayabilir ve modern işlemciler genellikle 32-bit veya 64-bit işlem yapar, bu nedenle `int` veya `long` veri türleri tercih edilebilir.

3. **Hata Önleme:** Doğru değer aralığını seçmek, veri kaybını ve taşmalarını önlemeye yardımcı olur. Örneğin, bir `byte` değişkenine büyük bir değer atamaya çalışırsanız, bu bir taşma (overflow) ile sonuçlanabilir ve beklenmedik sonuçlara yol açabilir.

4. **Dönüşüm ve Tip Güvenliği:** Veriler üzerinde işlemler yaparken, uygun türde veri kullanmak önemlidir. Büyük bir tam sayıyı `byte` türünde saklamaya çalışmak, değer kaybına veya hatalara neden olabilir.

5. **Matematiksel Hesaplamalar ve Hassasiyet:** Kayan nokta türleri (`float`, `double`) hassasiyet ve yuvarlama hataları içerebilir. Bu, özellikle bilimsel hesaplamalar veya hassas finansal işlemler için önemli olabilir.

Sonuç olarak, `Number` sınıfının alt sınıflarının değer aralıkları, uygulama performansı, bellek kullanımı ve doğruluk açısından önemli rol oynar. Bu yüzden, ihtiyaçlarınıza uygun veri türünü seçerken bu aralıkları göz önünde bulundurmak kritik öneme sahiptir.

=================================================================================

2. - Eğer bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa, Kotlin tip çıkarımını nasıl yapar?

Kotlin, tip çıkarımını (type inference) oldukça etkili bir şekilde yapabilen bir programlama dilidir. Eğer bir değişkene tip belirtimi yapılmadan değer atanırsa, Kotlin derleyicisi değişkenin tipini atanan değerin türüne göre otomatik olarak çıkarır. Bu özellik, kodun daha kısa ve okunabilir olmasını sağlar.

### Tip Çıkarımının Temel Kuralları

1. **Atanan Değere Göre Tip Çıkarımı:**
   Kotlin, değişkene atanan değerin türünü baz alarak değişkenin tipini çıkarır. Örneğin:

   ```kotlin
   val number = 42
   ```

   Bu durumda, Kotlin derleyicisi `number` değişkeninin `Int` türünde olduğunu çıkarır çünkü `42` bir tam sayıdır ve varsayılan olarak `Int` olarak kabul edilir.

2. **Tip Çıkarımı ile `val` ve `var`:**
   - **`val` (Immutable Değişken):** `val` ile tanımlanan değişkenler bir kez atandıktan sonra değiştirilemez. Örneğin:

     ```kotlin
     val message = "Hello, World!"
     ```

     Burada, `message` değişkeni `String` türündedir çünkü `"Hello, World!"` bir `String` literali ile atanmıştır.

   - **`var` (Mutable Değişken):** `var` ile tanımlanan değişkenler ise değiştirilebilir. Örneğin:

     ```kotlin
     var count = 10
     ```

     Burada, `count` değişkeni `Int` türündedir çünkü `10` bir tam sayı olarak atanmıştır.

3. **Fonksiyonlarla Tip Çıkarımı:**
   Fonksiyonlar da tip çıkarımı yapabilir. Bir fonksiyonun dönüş türü, fonksiyonun gövdesinde kullanılan ifadeye göre belirlenir. Örneğin:

   ```kotlin
   fun getGreeting(): String {
       return "Hello, Kotlin!"
   }
   ```

   Burada, Kotlin derleyicisi `getGreeting` fonksiyonunun dönüş türünü `String` olarak çıkarır çünkü fonksiyonun geri döndürdüğü değer bir `String` literali.

4. **Karmaşık Tip Çıkarımları:**
   Kotlin, daha karmaşık durumlarda da tip çıkarımı yapabilir. Örneğin, bir koleksiyon oluşturduğunuzda:

   ```kotlin
   val numbers = listOf(1, 2, 3, 4)
   ```

   Burada, `numbers` değişkeni `List<Int>` türünde olur çünkü `listOf` fonksiyonuna geçirilen değerler `Int` türündedir.

### Tip Çıkarımı Örnekleri

1. **Tam Sayılar ve Ondalık Sayılar:**

   ```kotlin
   val integerNumber = 123          // Int
   val doubleNumber = 123.45        // Double
   ```

2. **Karmaşık Nesneler:**

   ```kotlin
   val person = Person("John", 30)  // Person (varsayalım ki Person sınıfı tanımlıdır)
   ```

3. **Fonksiyonlarla Tip Çıkarımı:**

   ```kotlin
   val result = 1 + 2.5          // Double, çünkü işlemin sonucu daha geniş bir tür olan Double'dır.
   ```

### Tip Çıkarımının Sınırlamaları

- **Yazım Yanlışları ve Hatalar:** Tip çıkarımı bazen yazım hatalarını gizleyebilir veya beklenmedik hatalara yol açabilir. Bu nedenle, tip belirtilerinin açıkça yapıldığı yerlerde kodun ne tür veri ile çalıştığını görmek daha kolay olabilir.
- **Genel ve Karmaşık Tipler:** Özellikle generic türlerde ve karmaşık veri yapılarına sahip durumlarda, tip çıkarımı bazen yeterli olmayabilir ve tip belirtilerinin açıkça yapılması gerekebilir.

### Özet

Kotlin, tip çıkarımını kullanarak kodunuzu daha okunabilir ve kısa hale getirir. Değişkenlere atanan değerler ve fonksiyonların dönüş değerleri baz alınarak değişkenlerin türleri otomatik olarak belirlenir. Ancak, bu özelliği kullanırken dikkatli olmak ve karmaşık durumlarda açık tip belirtileri kullanmak, kodunuzun daha anlaşılır ve hata riskini azaltan bir hale gelmesini sağlar.

=================================================================================

3. - Float değişken oluştururken `F` ve `f` harfleri varken, Long değişken oluştururken neden küçük `l` harfi yoktur?

Cevap: Java ve Kotlin gibi dillerde, sayısal literallerin türlerini belirtmek için kullanılan harfler ve işaretler, veri türlerinin doğru şekilde işlenmesini sağlamak için önemlidir. `Float` ve `Long` veri türleri ile ilgili kullanılan işaretlerin neden farklı olduğunu anlamak için her iki veri türünün nasıl temsil edildiğine ve sayısal literallerin nasıl işlendiğine bakmak faydalıdır.

### `Float` ve `Double` Literalleri:

**Java ve Kotlin'de:**
- **`Float` Literali:** Bir sayının `Float` türünde olduğunu belirtmek için, sayının sonuna `F` veya `f` harfi eklenir. Bu, sayının kayan nokta (floating-point) temsilinin `float` türünde olduğunu belirtir. Örneğin:

  ```java
  float myFloat = 3.14F;  // veya
  float myFloat = 3.14f;
  ```

  Burada `F` veya `f`, sayının `Float` olarak değerlendirileceğini belirtir. Eğer bu işaret kullanılmazsa, sayı varsayılan olarak `Double` türünde değerlendirilir.

- **`Double` Literali:** `Double` türü için özel bir işaret gerekli değildir çünkü sayılar varsayılan olarak `Double` olarak kabul edilir. Örneğin:

  ```java
  double myDouble = 3.14;  // varsayılan olarak Double
  ```

### `Long` Literali:

**Java ve Kotlin'de:**
- **`Long` Literali:** Bir sayının `Long` türünde olduğunu belirtmek için, sayının sonuna `L` veya `l` harfi eklenir. Bu, sayının `Long` türünde olduğunu belirtir. Örneğin:

  ```java
  long myLong = 123456789L;  // veya
  long myLong = 123456789l;
  ```

  Burada `L` veya `l`, sayının `Long` olarak değerlendirileceğini belirtir. `L` harfi genellikle büyük harf olarak kullanılır ve küçük `l` harfi kullanımı, bazı yazım hataları ve okunabilirlik sorunları yaratabilir.

### Neden `Float` için `F` veya `f`, `Long` için ise `L` kullanılır?

1. **Okunabilirlik ve Çakışma Önleme:**
   - Küçük `l` harfi (küçük L), `1` rakamına benzeyebilir ve bu, kodun okunabilirliğini azaltabilir. Bu yüzden, `Long` türü için büyük `L` harfi kullanılır. `L` harfi daha belirgin olduğu için bu, kodun daha okunabilir ve hatasız olmasını sağlar.
   - Küçük `f` harfi ise, rakamlarla çakışma riski taşımaz ve bu yüzden `Float` türü için uygun bir seçimdir.

2. **Dil Tasarımı:**
   - Java ve Kotlin'in tarihsel ve dil tasarımı gereği, `Float` ve `Double` için ayrı işaretler ve `Long` için de büyük `L` harfi kullanılır. Bu, her tür için belirli bir işaretleme standardını sağlar ve bu standart, diller arasında tutarlılığı korur.

### Özet

- `Float` türündeki sayılar `F` veya `f` harfi ile belirtilir, çünkü bu, sayının `Float` olarak yorumlanmasını sağlar.
- `Long` türündeki sayılar `L` veya `l` harfi ile belirtilir, ancak genellikle büyük `L` harfi kullanılır çünkü küçük `l` harfi rakam `1` ile karışabilir ve bu, kodun okunabilirliğini azaltabilir.

Bu işaretler, programcıların sayısal literallerin türlerini açıkça belirtmelerini sağlar ve derleyicinin sayıları doğru bir şekilde işlemesini destekler.

=================================================================================

4. - Tek duyarlıklı (Single precision) ve Çift duyarlıklı (Double precision) kavramlarını açıklayın.

Cevap: Tek duyarlıklı (single precision) ve çift duyarlıklı (double precision) kavramları, kayan nokta (floating-point) sayıların temsilinde kullanılan iki farklı hassasiyet türünü ifade eder. Bu kavramlar, sayısal hesaplamalarda hassasiyeti ve bellek kullanımını etkileyen önemli faktörlerdir.

### Tek Duyarlıklı (Single Precision) Kayan Nokta

- **Bit Sayısı:** Tek duyarlıklı kayan nokta sayıları, genellikle 32 bit (4 byte) uzunluğundadır.
- **Format:** IEEE 754 standardına göre, tek duyarlıklı kayan nokta sayısı şu şekilde temsil edilir:
  - **1 bit** işaret biti: Sayının pozitif mi yoksa negatif mi olduğunu belirtir.
  - **8 bit** üssel kısım (exponent): Sayının ölçeğini (büyüklüğünü) belirler.
  - **23 bit** kesir kısmı (mantissa): Sayının hassasiyetini belirler. Bu kısım sayıdaki gerçek basamakları temsil eder.
  
- **Değer Aralığı:**
  - **En Küçük Pozitif Değer:** Yaklaşık `1.4E-45` (çok küçük değerler).
  - **En Büyük Pozitif Değer:** Yaklaşık `3.4E38` (çok büyük değerler).

- **Hassasiyet:** Tek duyarlıklı sayılar genellikle 6-9 basamağa kadar hassasiyet sağlar.

### Çift Duyarlıklı (Double Precision) Kayan Nokta

- **Bit Sayısı:** Çift duyarlıklı kayan nokta sayıları, genellikle 64 bit (8 byte) uzunluğundadır.
- **Format:** IEEE 754 standardına göre, çift duyarlıklı kayan nokta sayısı şu şekilde temsil edilir:
  - **1 bit** işaret biti: Sayının pozitif mi yoksa negatif mi olduğunu belirtir.
  - **11 bit** üssel kısım (exponent): Sayının ölçeğini (büyüklüğünü) belirler.
  - **52 bit** kesir kısmı (mantissa): Sayının hassasiyetini belirler. Bu kısım sayıdaki gerçek basamakları temsil eder.
  
- **Değer Aralığı:**
  - **En Küçük Pozitif Değer:** Yaklaşık `4.9E-324` (çok küçük değerler).
  - **En Büyük Pozitif Değer:** Yaklaşık `1.8E308` (çok büyük değerler).

- **Hassasiyet:** Çift duyarlıklı sayılar genellikle 15-17 basamağa kadar hassasiyet sağlar.

### Karşılaştırma

- **Bellek Kullanımı:**
  - Tek duyarlıklı sayılar daha az bellek kullanır (4 byte), bu da bellekte daha fazla sayı depolamanıza olanak tanır.
  - Çift duyarlıklı sayılar daha fazla bellek kullanır (8 byte), ancak daha yüksek hassasiyet ve daha geniş değer aralığı sağlar.

- **Hassasiyet:**
  - Tek duyarlıklı sayılar sınırlı bir hassasiyet sağlar ve bu, özellikle küçük ondalıklı değerlerde veya büyük sayıların temsilinde hata veya yuvarlama sorunlarına yol açabilir.
  - Çift duyarlıklı sayılar, daha yüksek hassasiyet sağlar ve bu da daha doğru sonuçlar elde etmenize olanak tanır, ancak daha fazla bellek tüketir ve işlem süresi daha uzun olabilir.

### Kullanım Durumları

- **Tek Duyarlıklı (Single Precision):**
  - Grafik işleme, oyunlar ve bazı bilimsel hesaplamalar gibi bellek ve işlem hızı açısından daha verimli olmaları gereken durumlarda kullanılır.
  
- **Çift Duyarlıklı (Double Precision):**
  - Bilimsel hesaplamalar, mühendislik hesaplamaları, finansal analizler ve hassas matematiksel işlemler gibi yüksek hassasiyetin gerekli olduğu durumlarda tercih edilir.

### Özet

- **Tek Duyarlıklı (Single Precision):** 32 bit, yaklaşık 6-9 basamağa kadar hassasiyet, daha az bellek kullanımı.
- **Çift Duyarlıklı (Double Precision):** 64 bit, yaklaşık 15-17 basamağa kadar hassasiyet, daha fazla bellek kullanımı.

Hangi türün kullanılacağı, uygulamanın gereksinimlerine, hesaplama hassasiyetine ve bellek kısıtlamalarına bağlıdır.

=================================================================================

5. - Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak hangi işaretler kullanılır? Bu ayıraçların kullanımında nelere dikkat etmek gerekir?

Cevap:

Double ve Float veri tipleri, ondalıklı sayıları temsil etmek için kullanılır ve bu sayıları yazarken iki temel ayrım işareti kullanılır: nokta (.) ve virgül (,). Ancak, bu işaretlerin kullanımı programlama diline ve yerel ayarlarına bağlı olarak değişir.

### Nokta (.)
- **Kullanım:** Çoğu programlama dilinde ve uluslararası standartlarda ondalık ayıracı olarak nokta (.) kullanılır. Örneğin, 3.14 veya 2.71828.
- **Dikkat Edilmesi Gerekenler:** Farklı yerel ayarların kullanıldığı uygulamalarda (özellikle çok uluslu uygulamalarda), nokta ile virgül arasında uyumsuzluk olabilir. Örneğin, bazı bölgelerde ondalıklı sayılar virgülle ayrılırken (örneğin, 3,14), bazı bölgelerde nokta kullanılır. Programlama dilinizin veya kütüphanenizin yerel ayarlarını dikkate almanız gerekir.

### Virgül (,)
- **Kullanım:** Virgul, bazı yerel ayarlarda ve özellikle matematiksel veya finansal veri gösteriminde ondalık ayıracı olarak kullanılır. Örneğin, bazı Avrupa ülkelerinde 3,14 veya 2,71828.
- **Dikkat Edilmesi Gerekenler:** Programlama dillerinin çoğu, virgülü ondalık ayırıcı olarak kabul etmez ve nokta kullanır. Bu nedenle, verilerinizi bu dillerde işlerken virgül ile nokta arasında doğru dönüşümler yapmanız gerekebilir.

### Programlama Dillerine Göre Kullanım
- **Python:** Nokta (.) kullanılır. Örneğin, `3.14` olarak yazılır.
- **JavaScript:** Nokta (.) kullanılır. Örneğin, `2.718` olarak yazılır.
- **Java:** Nokta (.) kullanılır. Örneğin, `3.14` olarak yazılır.
- **C/C++:** Nokta (.) kullanılır. Örneğin, `2.718` olarak yazılır.

### Yerel Ayarlarla İlgili Dikkat Edilmesi Gerekenler
- **Yerel Ayar Desteği:** Programlama dilinizin veya veri işleme aracınızın yerel ayarlarını kontrol edin ve gerektiğinde dönüştürme yapın.
- **Uluslararasılaştırma:** Eğer uygulamanız çok uluslu kullanıcılar tarafından kullanılacaksa, yerel ayar farklılıklarını göz önünde bulundurmanız ve kullanıcıya uygun formatı sunmanız önemlidir.
- **Veri Girişi ve Çıkışı:** Kullanıcıdan veri alırken veya veri gösterirken, yerel ayarları dikkate alarak uygun formatta veri sağlayın.

Genel olarak, veri giriş ve çıkışında uyumluluk sağlamak için yerel ayarları doğru şekilde ele almak ve gerekiyorsa dönüşümler yapmak en iyi yaklaşımdır.

=================================================================================

6. - Double ve Float değişkenler ondalık kısımda kaç basamağa kadar işlem yaparlar? Bu sınırın üzerinde gelen ondalık bilgileri için nasıl davranırlar? Hangi durumlar için Float ve hangi durumlar için Double kullanılmalıdır?

Cevap: 

Double ve Float veri tipleri, ondalıklı sayıları temsil ederken farklı hassasiyetlere ve saklama kapasitelerine sahiptir. İşlem yapabilme yetenekleri ve bu yeteneklerin sınırları hakkında daha fazla bilgi aşağıda verilmiştir:

### Float ve Double Hassasiyetleri

#### **Float**
- **Hassasiyet:** Genellikle 6-7 ondalık basamağa kadar hassasiyet sunar.
- **Saklama Kapasitesi:** Float veri tipi, 32-bit (4 byte) bellek kullanır.
- **Sınırlamalar:** Float, ondalıklı sayılarda daha az hassasiyet sunar, bu da bazı durumlarda yuvarlama hatalarına veya hassasiyet kaybına neden olabilir. Örneğin, `0.1` gibi bazı sayılar float ile tam olarak temsil edilemez.

#### **Double**
- **Hassasiyet:** Genellikle 15-16 ondalık basamağa kadar hassasiyet sunar.
- **Saklama Kapasitesi:** Double veri tipi, 64-bit (8 byte) bellek kullanır.
- **Sınırlamalar:** Double, float'tan daha fazla hassasiyet sunar ve daha geniş bir aralıkta değerleri doğru temsil edebilir. Ancak, double'lar da sınırsız hassasiyet sunmaz ve bazı durumlarda yuvarlama hataları meydana gelebilir.

### Sınırların Üzerinde Gelen Ondalık Bilgileri
Her iki veri tipi de belirli bir hassasiyete sahip olduğundan, ondalık kısmın belirli bir basamaktan ötesi için işlem yaparken aşağıdaki durumlarla karşılaşabilirsiniz:
- **Yuvarlama:** Ondalık basamak sayısı sınırına ulaşıldığında, daha fazla hassasiyet kaybolur ve değer yuvarlanır.
- **Truncation:** Bazı durumlarda, ondalık basamağın bir kısmı kesilebilir.
- **Bilgi Kaybı:** Hassasiyet sınırını aşan bilgilerin kaybolması, sonuçların doğru olmayabileceği anlamına gelir.

### Float ve Double Kullanım Senaryoları

#### **Float Kullanılacak Durumlar**
- **Bellek Kullanımı:** Bellek kısıtlaması olan sistemlerde veya büyük veri kümeleriyle çalışırken, daha az bellek kullanımı gerekebilir.
- **Performans:** Float, bazı durumlarda daha hızlı işlem yapabilir, ancak bu genellikle modern işlemcilerde büyük bir fark yaratmaz.
- **Yeterli Hassasiyet:** 6-7 basamak hassasiyetinin yeterli olduğu durumlarda (örneğin, grafiklerde veya bazı oyunlarda).

#### **Double Kullanılacak Durumlar**
- **Yüksek Hassasiyet Gereksinimi:** Daha fazla ondalıklı basamağa ihtiyaç duyulan matematiksel hesaplamalar, bilimsel hesaplamalar, finansal işlemler gibi durumlarda.
- **Kesinlik ve Doğruluk:** Hataların büyük önem taşıdığı uygulamalarda, örneğin finansal hesaplamalarda ve fiziksel simülasyonlarda.
- **Genel Kullanım:** Çoğu durumda, hassasiyet kaybını minimumda tutmak için double kullanılır, çünkü double, float’tan daha güvenilir sonuçlar sağlar.

### Özet
- **Float:** Daha az bellek kullanımı ve yeterli hassasiyet gerektiren durumlarda tercih edilir.
- **Double:** Daha fazla hassasiyet ve doğruluk gerektiren durumlarda, genellikle tercih edilir.

Her iki veri tipinin de kendi avantajları ve sınırlamaları vardır. Uygulamanızın ihtiyaçlarına göre doğru veri tipini seçmek, hem performans hem de doğruluk açısından en iyi sonucu elde etmenize yardımcı olacaktır.

=================================================================================

7. - Ondalık(Decimal), Onaltılık (Hexadecimal) ve İkilik (Binary) değişkenleri Kotlin'de nasıl tanımlayabilirsiniz?

Cevap: Kotlin'de ondalıklı (decimal), onaltılık (hexadecimal) ve ikilik (binary) sayıları tanımlamak ve kullanmak oldukça basittir. Kotlin, bu sayı sistemlerinin her biri için uygun sözdizimini sağlar. İşte bu sayı türlerini Kotlin'de nasıl tanımlayabileceğiniz:

### 1. Ondalık (Decimal) Sayılar

Ondalık sayılar, standart sayı formatıdır ve doğrudan yazılabilir. `Int`, `Long`, `Float`, ve `Double` veri türlerinde tanımlanabilirler.

**Örnekler:**

```kotlin
val decimalInt: Int = 42
val decimalLong: Long = 123456789L
val decimalFloat: Float = 3.14f
val decimalDouble: Double = 2.71828
```

- **`Int` ve `Long`**: Tam sayılar için.
- **`Float` ve `Double`**: Ondalıklı sayılar için.

### 2. Onaltılık (Hexadecimal) Sayılar

Onaltılık sayılar, genellikle `0x` ile başlar ve `0`-`9`, `a`-`f` (veya `A`-`F`) karakterlerini içerir. Kotlin, onaltılık sayıların `Int` ve `Long` veri türlerinde tanımlanmasını destekler.

**Örnekler:**

```kotlin
val hexInt: Int = 0x2A  // 42 ondalık
val hexLong: Long = 0x1F4A3L  // 128563 ondalık
```

- **`0x`**: Onaltılık sayıların başladığını belirten işaret.
- **`L`**: Uzun (`Long`) sayılar için kullanılır.

### 3. İkilik (Binary) Sayılar

İkilik sayılar `0b` ile başlar ve sadece `0` ve `1` karakterlerini içerir. Kotlin, ikilik sayıların `Int` ve `Long` veri türlerinde tanımlanmasını destekler.

**Örnekler:**

```kotlin
val binaryInt: Int = 0b101010  // 42 ondalık
val binaryLong: Long = 0b1101111L  // 111 ondalık
```

- **`0b`**: İkilik sayıların başladığını belirten işaret.
- **`L`**: Uzun (`Long`) sayılar için kullanılır.

### Kullanım Örnekleri

Kotlin'de bu farklı sayı türlerini kullanarak çeşitli işlemler gerçekleştirebilirsiniz. İşte bazı örnekler:

```kotlin
fun main() {
    // Ondalık Sayılar
    val decimalValue: Int = 255
    println("Ondalık: $decimalValue")  // Çıktı: 255

    // Onaltılık Sayılar
    val hexValue: Int = 0xFF
    println("Onaltılık: $hexValue")  // Çıktı: 255

    // İkilik Sayılar
    val binaryValue: Int = 0b11111111
    println("İkilik: $binaryValue")  // Çıktı: 255
}
```

Bu kodda, `decimalValue`, `hexValue`, ve `binaryValue` hepsi 255 değerini temsil eder, fakat farklı biçimlerde tanımlanmıştır. Bu tür değerlerin yazılması, kodunuzu daha okunabilir ve anlamlı hale getirebilir, özellikle belirli bit düzeyindeki işlemlerle çalışırken.

=================================================================================

8. - Sekizlik (Octal) değişkenler Java'da nasıl tanımlanır? Kotlin'de Sekizlik değişken tanımlanabilir mi?

Cevap: ### Sekizlik (Octal) Sayılarının Java ve Kotlin'deki Kullanımı

#### **Java'da Sekizlik (Octal) Sayılar**

Java'da sekizlik (octal) sayılar `0` ile başlar ve ardından sekizlik rakamları (0-7) gelir. Java'da sekizlik sayılar `int` veya `long` veri türleriyle tanımlanabilir. Sekizlik sayıları `0` ile başlar ve bu sayı sistemi için özel bir işaret gerektirir.

**Örnekler:**

```java
public class Main {
    public static void main(String[] args) {
        int octalInt = 075;   // Sekizlik sayı: 75 (ondalık olarak 61)
        long octalLong = 01234567L;  // Sekizlik sayı: 1234567 (ondalık olarak 342391)

        System.out.println("Sekizlik int: " + octalInt);   // Çıktı: 61
        System.out.println("Sekizlik long: " + octalLong); // Çıktı: 342391
    }
}
```

- **`0`**: Sekizlik sayının başladığını belirtir.
- **`L`**: Uzun (`Long`) sayılar için kullanılır.

#### **Kotlin'de Sekizlik (Octal) Sayılar**

Kotlin'de sekizlik (octal) sayıların doğrudan bir sözdizimi desteği yoktur. Yani, Kotlin dilinde sekizlik sayıları tanımlamak için özel bir sözdizimi bulunmaz. Ancak, sekizlik sayıları doğrudan `Int` veya `Long` veri türleriyle tanımlanabilir. Sekizlik sayıların değerlerini bu türlerle manuel olarak tanımlayarak kullanabilirsiniz.

**Kotlin'de Sekizlik Sayıları Kullanma:**

Sekizlik sayıları Kotlin'de kullanılmak istendiğinde, bu sayıları önce ondalıklı değere dönüştürüp sonra bu değeri kullanabilirsiniz.

**Örnek:**

```kotlin
fun main() {
    val octalInt = 0b101010 // İkilik sayı, burada örnek olarak 0o075 (sekizlik) değerinin ikilik karşılığı verilmiştir
    println("Sekizlik int: $octalInt")  // Çıktı: 42 (ondalık)
    
    // Sekizlik sayıyı ondalıklı değere dönüştürmek
    val octalValue = 0o75 // Sekizlik sayı, ondalıklı karşılığı 61
    println("Sekizlik int: $octalValue")  // Çıktı: 61
}
```

- **`0o`**: Kotlin'de sekizlik (octal) sayılar için kullanılan işaret.

### Özet

- **Java'da:** Sekizlik sayılar `0` ile başlar ve `int` veya `long` veri türleri ile kullanılabilir.
- **Kotlin'de:** Sekizlik sayılar doğrudan desteklenmez, fakat sekizlik sayılar ondalıklı değere dönüştürülerek kullanılabilir ve `0o` işareti ile tanımlanabilir.

Bu bilgiler, Java ve Kotlin'de sekizlik sayıların nasıl tanımlanabileceği ve kullanılabileceği hakkında temel bir anlayış sağlar.


=================================================================================

9.- "Geleneksel Notasyon" (Conventional Notation) gösterimi nasıl yapılır?

Cevap:"Geleneksel Notasyon" (Conventional Notation) terimi genellikle sayıları, matematiksel ifadeleri, veya özel işaretleme biçimlerini standart, yaygın olarak kabul edilen formatlarda ifade etmek için kullanılır. Ancak bu terim bağlamına göre farklı anlamlara gelebilir. Bu notasyonlar genellikle belirli bir bağlamda sayıları veya ifadeleri standart bir şekilde yazma yöntemidir. Aşağıda farklı bağlamlarda geleneksel notasyonların nasıl kullanıldığını açıklayacağım.

### 1. Sayılar İçin Geleneksel Notasyon

**Ondalık Notasyon:**
- **Geleneksel Notasyon:** Bu, sayıları standart ondalıklı biçimde ifade eder. Örneğin, 1234, 56.78 gibi.
- **Kullanım:** Sayılar günlük hesaplamalarda, finansal raporlama ve genel veri sunumunda kullanılır.

**Örnek:**
```plaintext
1234 (ondalık sayı)
56.78 (ondalık sayı)
```

### 2. Matematiksel İfadeler İçin Geleneksel Notasyon

**Matematiksel İşlemler:**
- **Geleneksel Notasyon:** Matematiksel işlemler genellikle standart sembollerle gösterilir. Örneğin, toplama (+), çıkarma (-), çarpma (× veya *), bölme (÷ veya /) gibi.
- **Kullanım:** Bu notasyonlar matematiksel hesaplamalar ve denklemler için kullanılır.

**Örnek:**
```plaintext
Toplama: 3 + 5 = 8
Çıkarma: 10 - 2 = 8
Çarpma: 4 × 7 = 28
Bölme: 20 ÷ 4 = 5
```

### 3. Bilgisayarlarda Sayı Sistemleri İçin Geleneksel Notasyon

**İkilik, Onaltılık ve Sekizlik Sistemler:**
- **İkilik Notasyon:** Sayılar `0` ve `1` ile temsil edilir. Genellikle `0b` öneki ile gösterilir.
- **Onaltılık Notasyon:** Sayılar `0-9` ve `A-F` ile temsil edilir. Genellikle `0x` öneki ile gösterilir.
- **Sekizlik Notasyon:** Sayılar `0-7` ile temsil edilir. Genellikle `0` öneki ile gösterilir.

**Örnekler:**
```plaintext
İkilik: 0b1010 (ikilik) = 10 (ondalık)
Onaltılık: 0x1F (onaltılık) = 31 (ondalık)
Sekizlik: 075 (sekizlik) = 61 (ondalık)
```

### 4. Bilgisayar Programlama Dillerinde Geleneksel Notasyon

**Kotlin, Java, Python gibi dillerde geleneksel notasyon:**
- **Ondalık:** Standart ondalıklı biçim.
- **İkilik, Onaltılık ve Sekizlik:** Belirli öneklerle (Kotlin ve Java'da `0b`, `0x`, `0` önekleri gibi).

**Örnekler:**

**Kotlin:**
```kotlin
val decimal: Int = 255
val binary: Int = 0b11111111
val hexadecimal: Int = 0xFF
val octal: Int = 0o377
```

**Java:**
```java
int decimal = 255;
int binary = 0b11111111;
int hexadecimal = 0xFF;
int octal = 0377;
```

**Python:**
```python
decimal = 255
binary = 0b11111111
hexadecimal = 0xFF
octal = 0o377
```

### 5. Genel Kullanımda Geleneksel Notasyon

**Genel Notasyon Kuralları:**
- **Zaman:** Saat ve dakika genellikle `HH:MM` formatında yazılır. Örneğin, 14:30.
- **Tarih:** Tarihler genellikle `DD/MM/YYYY` veya `YYYY-MM-DD` formatında yazılır. Örneğin, 05/08/2024 veya 2024-08-05.
- **Para Birimi:** Para birimleri genellikle `£100`, `$50` veya `€75` formatında yazılır.

Bu geleneksel notasyon biçimleri, verilerin ve bilgilerin standart bir şekilde ifade edilmesine ve anlaşılmasına yardımcı olur. Hangi bağlamda kullanıldığına göre detaylı notasyonlar ve kurallar değişebilir.

=================================================================================

10. - Sayısal değişkenlerde alt çizgi (underscore) nasıl kullanılır? Kotlin bunu nasıl yorumlar?

Cevap: Sayısal değişkenlerde alt çizgi (underscore) kullanımı, genellikle büyük sayıları daha okunabilir hale getirmek için kullanılan bir tekniktir. Hem Kotlin hem de diğer birçok programlama dilinde bu, büyük sayıları gruplandırarak daha anlaşılır kılar. Alt çizgi (underscore) sadece sayıları ayırmak için kullanılan bir işarettir ve aritmetik işlemler üzerinde hiçbir etkisi yoktur.

### 1. **Alt Çizgi Kullanımı:**

**Amaç:** 
- **Okunabilirlik:** Büyük sayıları daha okunabilir hale getirmek için kullanılır.
- **Ayırma:** Binlik, milyonluk ayrımları daha belirgin hale getirir.

**Örnekler:**

```kotlin
val oneMillion: Int = 1_000_000
val largeNumber: Long = 1_000_000_000_000
val hexValue: Int = 0xFF_FF_FF
val binaryValue: Int = 0b1010_1011_1100_1100
```

### 2. **Kotlin’de Alt Çizgi Kullanımı:**

Kotlin, sayısal değerlerde alt çizgi kullanımını destekler ve bu notasyon yalnızca sayıların okunabilirliğini artırmak amacıyla kullanılır. Kotlin derleyicisi alt çizgileri göz ardı eder ve onları sayının bir parçası olarak değerlendirmez. Aşağıda Kotlin’de alt çizgi kullanımının nasıl çalıştığını gösteren örnekler bulunmaktadır:

**Örnekler:**

```kotlin
fun main() {
    val billion: Long = 1_000_000_000L
    val bytes: Int = 0b0010_0100_0110_1000
    val hexNumber: Int = 0xAB_CD_EF
    
    println("Billion: $billion")       // Çıktı: Billion: 1000000000
    println("Bytes: $bytes")           // Çıktı: Bytes: 9208
    println("Hex Number: $hexNumber")  // Çıktı: Hex Number: 1144201743
}
```

**Açıklamalar:**

- **`1_000_000_000L`**: Bir milyar değeri, `L` işareti `Long` türünü belirtir. Alt çizgiler sadece sayının daha okunabilir olmasını sağlar.
- **`0b0010_0100_0110_1000`**: İkilik (binary) sayı, alt çizgiler gruplama amaçlı kullanılır.
- **`0xAB_CD_EF`**: Onaltılık (hexadecimal) sayı, alt çizgiler gruplamayı kolaylaştırır.

### 3. **Kotlin Derleyicisi ve Alt Çizgi:**

Kotlin derleyicisi, sayıların değerlerini hesaplamak için alt çizgileri göz ardı eder. Bu sayılar yazılımda hesaplamalar sırasında alt çizgilerle ayrılmış olarak görünse bile, bu ayrımlar aritmetik işlemler veya sayısal değerler üzerinde etkili değildir.

### 4. **Genel Kullanım ve Standartlar:**

- **Okunabilirlik:** Alt çizgiler genellikle çok büyük sayılarda veya uzun sayısal dizilerde kullanılır.
- **Standartlar:** Çoğu modern programlama dili, büyük sayıları gruplamak için alt çizgi kullanımını destekler, örneğin Python, Java, C#, JavaScript gibi.

### Özet:

- **Kotlin:** Sayısal değişkenlerde alt çizgi kullanımı desteklenir ve okunabilirliği artırmak için kullanılır. Derleyici, alt çizgileri sayısal değeri hesaplamak için dikkate almaz.
- **Kullanım:** Büyük sayılarda ve uzun sayısal dizilerde, binlik ayrımlarını belirginleştirmek için alt çizgi kullanımı yaygındır.

Bu kullanım, büyük sayıları daha okunabilir ve anlaşılır hale getirerek kodun bakımını kolaylaştırır.

=================================================================================

11. - `==` ile neyi karşılaştırırız? `===` ile neyi karşılaştırırız?

Cevap: Kotlin'de `==` ve `===` operatörleri, nesneleri karşılaştırmak için farklı amaçlarla kullanılır. İşte her iki operatörün nasıl çalıştığını ve aralarındaki farkları açıklayan detaylar:

### 1. **`==` Operatörü (Eşitlik Karşılaştırması)**

- **Amaç:** İki nesnenin **değerlerini** karşılaştırır.
- **Çalışma Şekli:** `==` operatörü, Kotlin'de Java'daki `equals()` metoduna karşılık gelir. Bu operatör, iki nesnenin içeriklerinin eşit olup olmadığını kontrol eder.
- **Kullanım:** Değer eşitliğini kontrol etmek için kullanılır.

**Örnek:**

```kotlin
data class Person(val name: String, val age: Int)

fun main() {
    val person1 = Person("Alice", 30)
    val person2 = Person("Alice", 30)
    val person3 = person1

    println(person1 == person2) // true: `person1` ve `person2` aynı değerlere sahip
    println(person1 == person3) // true: `person1` ve `person3` aynı nesneyi referans alıyor
}
```

- **Not:** `==` operatörü kullanıldığında, Kotlin otomatik olarak `equals()` metodunu çağırır. Eğer `data class` gibi bir veri sınıfı kullanıyorsanız, Kotlin bu sınıflar için `equals()` metodunu varsayılan olarak, tüm özelliklerin eşitliğini kontrol edecek şekilde override eder.

### 2. **`===` Operatörü (Referans Karşılaştırması)**

- **Amaç:** İki nesnenin **referanslarını** (yani, aynı hafıza adresini) karşılaştırır.
- **Çalışma Şekli:** `===` operatörü, iki nesnenin aynı nesne olup olmadığını kontrol eder. Yani, bellekte aynı yerden mi referans aldıklarını kontrol eder.
- **Kullanım:** Referans eşitliğini kontrol etmek için kullanılır.

**Örnek:**

```kotlin
fun main() {
    val person1 = Person("Alice", 30)
    val person2 = Person("Alice", 30)
    val person3 = person1

    println(person1 === person2) // false: `person1` ve `person2` aynı nesne değil, farklı bellek adreslerine sahip
    println(person1 === person3) // true: `person1` ve `person3` aynı nesneyi referans alıyor
}
```

### Özet

- **`==` (Değer Karşılaştırması):** İki nesnenin içeriklerini karşılaştırır. Eğer iki nesne aynı türde ve aynı içeriğe sahipse, `true` döner. Kotlin'de bu operatör, `equals()` metodunu çağırarak çalışır.

- **`===` (Referans Karşılaştırması):** İki nesnenin bellekte aynı referansı gösterip göstermediğini kontrol eder. Eğer iki referans aynı nesneyi işaret ediyorsa, `true` döner.

Bu operatörler arasındaki fark, Kotlin'de nesne karşılaştırmaları yaparken hangi tür karşılaştırma yapmanız gerektiğini belirlemenize yardımcı olur. Değer karşılaştırması yapmanız gereken durumlarda `==`, referans eşitliği kontrolü yapmanız gereken durumlarda ise `===` kullanmalısınız.

=================================================================================

12. - `===` operatörü ile karşılaştırma yaparken Byte değer aralığı neden önemlidir? Kotlin bu aralığa göre neden özel bir davranış sergiler?

Cevap: Kotlin'de `===` operatörü referans karşılaştırması yapmak için kullanılır. Ancak, Kotlin'de `Byte` değerleri için özel bir davranış vardır. Bu davranış, Kotlin'in performansı ve bellek yönetimini optimize etme çabasından kaynaklanır. İşte bu özel durum ve nedenleri detaylı bir şekilde açıklayalım:

### Byte Değer Aralığı ve Referans Karşılaştırması

#### **1. Byte Değerleri ve Özel Davranış**

Kotlin, `Byte` veri tipini optimize etmek amacıyla, `Byte` türündeki küçük sayılar için **caching** (önbellekleme) kullanır. Bu, bellek kullanımını ve performansı artırmak için yapılır. 

- **Byte Aralığı:** Kotlin'de `Byte` veri tipi `-128` ile `127` arasındaki değerleri alabilir. Bu aralık, toplam 256 farklı değeri kapsar.

- **Caching (Önbellekleme):** Kotlin, bu 256 değer için bir önbellek oluşturur. Yani, bu aralık içindeki değerler bellekte tek bir örnek olarak saklanır. Bu, performansı artırır çünkü aynı `Byte` değeri ile karşılaşıldığında, mevcut bellek adresindeki aynı nesne referans kullanılır.

#### **2. Referans Karşılaştırması ile İlgili Örnekler**

Bu optimizasyon, `===` operatörü ile yapılan referans karşılaştırmalarında belirgin bir fark yaratır. İşte nasıl çalıştığını gösteren bir örnek:

**Örnek:**

```kotlin
fun main() {
    val byte1: Byte = 100
    val byte2: Byte = 100
    val byte3: Byte = 128
    val byte4: Byte = 128

    println(byte1 === byte2) // true: `100` değeri için önbellekte aynı referans kullanılır.
    println(byte3 === byte4) // false: `128` değeri için önbellek dışında bir referans kullanılır.
}
```

- **`byte1 === byte2`**: `true` döner çünkü `100` değeri önbellekten alınmış ve aynı bellek adresini paylaşır.

- **`byte3 === byte4`**: `false` döner çünkü `128` değeri önbellekte yer almaz ve bu nedenle farklı bellek adreslerinde saklanır.

#### **3. Neden Özel Davranış?**

- **Performans:** Küçük ve sık kullanılan değerler için önbellekleme, bu değerler üzerinde yapılan işlemlerde performansı artırır. Aynı değeri tekrar kullanmak, bellek tahsisi ve referans oluşturma işlemlerini azaltır.

- **Bellek Yönetimi:** Küçük veri türlerinin (bu örnekte `Byte` tipi) sıkça kullanıldığı durumlarda, bellek yönetimini daha verimli hale getirir. Önbellekleme sayesinde, aynı değeri birden fazla kez kullanmanın bellek üzerindeki etkisi azaltılır.

### Genel Özet

- **`===` Operatörü:** Kotlin'de `===` operatörü, iki nesnenin bellekte aynı referansı işaret edip etmediğini kontrol eder.

- **Byte Aralığı:** `Byte` veri tipi için `-128` ile `127` arasındaki değerler özel olarak önbelleğe alınır, bu nedenle bu aralıktaki değerler için referans karşılaştırması yapılırken aynı referans kullanılır.

- **Performans ve Bellek Yönetimi:** Küçük ve sık kullanılan değerlerin önbelleğe alınması, performans iyileştirmeleri ve bellek yönetimini optimize etmek için kullanılır.

Kotlin'deki bu özel davranış, performans ve bellek yönetimi açısından oldukça etkili olabilir. Ancak, büyük veri kümeleri veya dışarıdan gelen verilerle çalışırken `===` yerine `==` operatörünü kullanmak, genellikle değer karşılaştırmaları yapmak için daha uygundur.

=================================================================================

13. - Sayısal değişkenlerde hangi matematiksel operatörler kullanılabilir?

Cevap: Kotlin'de sayısal değişkenlerle çalışırken kullanılabilecek temel matematiksel operatörler şunlardır:

### Temel Matematiksel Operatörler

1. **Toplama (`+`):**
   - İki sayıyı toplar.
   - **Örnek:** `val sum = 5 + 3` // `sum` değeri 8 olur.

2. **Çıkarma (`-`):**
   - Bir sayıdan diğerini çıkarır.
   - **Örnek:** `val difference = 5 - 3` // `difference` değeri 2 olur.

3. **Çarpma (`*`):**
   - İki sayıyı çarpar.
   - **Örnek:** `val product = 5 * 3` // `product` değeri 15 olur.

4. **Bölme (`/`):**
   - Bir sayıyı diğerine böler. Bölme sonucunda `Double` türünde bir değer elde edilir.
   - **Örnek:** `val quotient = 10 / 3` // `quotient` değeri 3.0 (Double) olur.

5. **Mod (Kalan) (`%`):**
   - Bir sayının diğerine bölümünden kalan değeri verir.
   - **Örnek:** `val remainder = 10 % 3` // `remainder` değeri 1 olur.

### Artırma ve Azaltma Operatörleri

1. **Artırma (`++`):**
   - Bir sayının değerini 1 artırır.
   - **Örnek:** `var x = 5` ve `x++` // `x` değeri 6 olur.

2. **Azaltma (`--`):**
   - Bir sayının değerini 1 azaltır.
   - **Örnek:** `var y = 5` ve `y--` // `y` değeri 4 olur.

### Aritmetik Operatörlerin Kullanımı

- **Tam Sayılar (`Int`, `Long`):** 
  - `Int` ve `Long` türleri üzerinde yukarıdaki tüm temel matematiksel operatörleri kullanabilirsiniz.
  - Bölme işlemi, `Int` türüyle yapıldığında tam sayı bölmesi yapar ve kalan kısmı atar. Onaltılık (hexadecimal), ikilik (binary) ve sekizlik (octal) sayılar da bu operatörlerle kullanılabilir.

**Örnek:**
```kotlin
fun main() {
    val a: Int = 10
    val b: Int = 3
    
    println("Toplama: ${a + b}") // Çıktı: Toplama: 13
    println("Çıkarma: ${a - b}") // Çıktı: Çıkarma: 7
    println("Çarpma: ${a * b}") // Çıktı: Çarpma: 30
    println("Bölme: ${a / b}") // Çıktı: Bölme: 3
    println("Mod: ${a % b}") // Çıktı: Mod: 1
}
```

- **Ondalık Sayılar (`Float`, `Double`):** 
  - `Float` ve `Double` türleri, ondalıklı matematiksel işlemler yapar. Bölme işlemleri, genellikle `Float` veya `Double` kullanılarak daha doğru sonuçlar verir.

**Örnek:**
```kotlin
fun main() {
    val x: Double = 10.0
    val y: Double = 3.0
    
    println("Toplama: ${x + y}") // Çıktı: Toplama: 13.0
    println("Çıkarma: ${x - y}") // Çıktı: Çıkarma: 7.0
    println("Çarpma: ${x * y}") // Çıktı: Çarpma: 30.0
    println("Bölme: ${x / y}") // Çıktı: Bölme: 3.3333333333333335
    println("Mod: ${x % y}") // Çıktı: Mod: 1.0
}
```

### Operatörlerin Karakteristikleri

- **Tam Sayı Bölmesi:** `Int` veya `Long` türleriyle yapılan bölme işlemleri tam sayı bölmesi yapar. Bölme işleminin sonucunda, ondalıklı kısmı atılır.
- **Ondalık Bölme:** `Float` veya `Double` türleriyle yapılan bölme işlemlerinde, ondalıklı değerler doğru bir şekilde hesaplanır.
- **Mod:** Modül işlemi, bölme işleminden kalan kısmı verir ve genellikle `Int` ve `Long` türleriyle kullanılır.

### Ekstra: 

- **Üs Alma (`pow()`):** Kotlin'de doğrudan bir üs alma operatörü yoktur, ancak `kotlin.math.pow` fonksiyonunu kullanarak üs alma işlemi yapabilirsiniz.

**Örnek:**
```kotlin
import kotlin.math.pow

fun main() {
    val base: Double = 2.0
    val exponent: Double = 3.0
    val result = base.pow(exponent)
    println("Üs Alma: $result") // Çıktı: Üs Alma: 8.0
}
```

Bu operatörler ve fonksiyonlar, Kotlin'de matematiksel hesaplamalar yaparken kullanılabilir ve çeşitli veri türleri üzerinde geniş bir uygulama yelpazesi sunar.

=================================================================================
