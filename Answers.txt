#Answers#

1. - `val` ile `var` arasındaki fark nedir?

Cevap: 

Kotlin'de `val` ve `var` arasındaki farklar şunlardır:

### `val` (Değişmez Değerler)
- **Tanım**: `val`, sabit bir değişken tanımlar. Bir `val` değişkeninin değeri ilk atandıktan sonra değiştirilemez.
- **Örnek**: Bir `val` ile değişken tanımlandığında, bu değişkenin değeri yalnızca bir kez atanabilir ve sonrasında değiştirilemez.

  ```kotlin
  val pi = 3.14
  // pi = 3.14159 // Bu satır derleme hatasına neden olur çünkü `pi` bir `val`'dir.
  ```

- **Kullanım Durumları**: `val`, değeri bir kez atanıp değişmeyecekse veya sabit olmasını istiyorsan kullanılır. Özellikle bir nesneye referansın değişmemesi gerektiğinde veya sabit verileri temsil eden değişkenlerde tercih edilir.

### `var` (Değişebilir Değerler)
- **Tanım**: `var`, değiştirilebilir bir değişken tanımlar. Bir `var` değişkeninin değeri program çalıştığı sürece değiştirilebilir.
- **Örnek**: Bir `var` ile değişken tanımladığında, bu değişkenin değeri programın herhangi bir yerinde değiştirilebilir.

  ```kotlin
  var age = 25
  age = 26 // Bu geçerlidir çünkü `age` bir `var`'dır.
  ```

- **Kullanım Durumları**: `var`, değeri değiştirilebilir olan değişkenlerde kullanılır. Değişkenin değerinin farklı durumlarda veya çeşitli işlemler sonucunda değişmesi gerekiyorsa `var` tercih edilir.

### Özet

- **`val`**: Bir kez atandıktan sonra değişmeyen (sabit) değerler için kullanılır.
- **`var`**: Değeri programın herhangi bir yerinde değiştirilebilen değişkenler için kullanılır.

Kotlin'de `val` kullanarak kodunu daha güvenilir ve hatasız hale getirebilirsin, çünkü değişkenin değerinin değişmeyeceğini garanti edersin. `var` ise daha esneklik sağlar ancak değişkenin değerinin beklenmedik bir şekilde değişmesine neden olabilir, bu yüzden kullanım yerlerini dikkatle seçmek gerekir.

### Not: 'val' ile 'var' arasında maliyet farkı var mıdır? şeklinde soru geldiğinde; performans olarak fark yok denecek kadar azdır. 

'val' Value yani değer demektir.
'var' Variable yani değişken demektir.

=================================================================================

2. - Bir `var` değişkeni `val` gibi davranmasını nasıl sağlayabiliriz `val` kelimesini kullanmadan?

Cevap: Bir `var` değişkeninin `val` gibi davranmasını sağlamak, genellikle bir değişkenin değerinin değişmeyeceğini garanti etmek için uygulanabilecek çeşitli yöntemleri içerir. Bununla birlikte, `val` anahtar kelimesini kullanmadan bir `var` değişkenini `val` gibi davranmasını sağlamak için aşağıdaki yöntemlerden bazılarını kullanabilirsin:

### 1. **Kapsülleme (Encapsulation) Kullanarak**
Kapsülleme, bir değişkenin değerinin sadece belirli bir şekilde değişmesini sağlar. Bu, genellikle getter ve setter'lar aracılığıyla yapılır. 

```kotlin
class MyClass {
    private var _value: Int = 0

    val value: Int
        get() = _value

    fun updateValue(newValue: Int) {
        _value = newValue
    }
}
```

Burada `_value` değişkeni `var` olarak tanımlanmıştır, ancak dışarıdan sadece `value` ile erişim sağlanır ve bu erişim sadece okunabilir (sadece getter kullanılır). `updateValue` fonksiyonu ise değeri güncelleyebilir.

### 2. **Özel Bir Setter Kullanarak**
Eğer bir `var` değişkeninin değerinin dışarıdan değiştirilemez olmasını istiyorsan, değişkeni `var` olarak tanımlayıp özel bir setter kullanarak bu davranışı sağlayabilirsin.

```kotlin
class MyClass {
    private var _value: Int = 0

    var value: Int
        get() = _value
        private set(value) {
            _value = value
        }
}
```

Burada `value` değişkeni `private set` ile tanımlanmıştır, yani sadece sınıfın içinde değiştirilebilir.

### 3. **Fonksiyonlar Kullanarak**
Bir değişkenin değerini doğrudan değiştiremezsin, ancak onu bir fonksiyon aracılığıyla değiştirebilirsin. Bu, değişkenin dışarıdan erişimini ve değiştirilmesini kısıtlar.

```kotlin
class MyClass {
    private var _value: Int = 0

    fun getValue(): Int {
        return _value
    }

    fun updateValue(newValue: Int) {
        _value = newValue
    }
}
```

Burada `_value` değişkenine sadece `updateValue` fonksiyonu aracılığıyla erişim sağlanır. `getValue` fonksiyonu ise değerini okur.

### 4. **Immutable Koleksiyonlar Kullanarak**
Eğer bir `List`, `Set` veya `Map` gibi koleksiyon türlerinde değerleri değiştiremeyen bir yapı istiyorsan, immutable koleksiyonlar kullanabilirsin.

```kotlin
class MyClass {
    private val _items: List<String> = listOf("item1", "item2", "item3")

    val items: List<String>
        get() = _items
}
```

Bu durumda, `_items` koleksiyonu değiştirilemez (immutable) ve dışarıdan sadece okunabilir.

### 5. **Delegates Kullanarak**
Kotlin’in `by` anahtar kelimesini kullanarak değişkenler için delegate özellikleri tanımlayabilirsin. Bu, değişkenlerin erişim ve değişim davranışını özelleştirmene olanak tanır.

```kotlin
import kotlin.properties.Delegates

class MyClass {
    var value: Int by Delegates.observable(0) { _, old, new ->
        println("Value changed from $old to $new")
    }
}
```

Burada `Delegates.observable` kullanarak bir `var` değişkenine get/set davranışı eklenmiş olur.

### Özet

`val` kelimesini kullanmadan bir `var` değişkeninin `val` gibi davranmasını sağlamak için:

- **Kapsülleme** yaparak `var` değişkenine dışarıdan sadece okunabilir erişim sağla.
- **Özel Setter** kullanarak değişkeni dışarıdan değiştirilemez hale getir.
- **Fonksiyonlar** kullanarak değişkenin değerini kontrol altına al.
- **Immutable Koleksiyonlar** kullanarak değiştirilemez veri yapıları oluştur.
- **Delegates** kullanarak değişkenlerin erişim ve değişim davranışlarını özelleştir.

Bu yöntemler, değişkenlerinizi kontrol altında tutmanıza ve beklenmedik değişikliklerden korumanıza yardımcı olur.

### Not: kısaca private set(value) yaparak işlemi sağlıyabiliriz.

================================================================================= 

3. - "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. `val` değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

Cevap: Kotlin'de `val` ve `var` değişkenleri arasında önemli farklar vardır ve bu farklar genellikle "değişmez" (immutable) ve "salt okunur" (read-only) kavramlarıyla açıklanır. İşte bu kavramların açıklamaları ve neden `val` değişkenlerin "değişmez" değil, "salt okunur" olarak açıklanması gerektiği:

### 1. **Değişmez (Immutable) Kavramı**

**Değişmez (immutable)** bir nesne, oluşturulduktan sonra herhangi bir durumda değiştirilemeyen bir nesnedir. Değişmezlik, nesnenin durumunun değişmez olduğunu ifade eder. Bu, nesneye atanan değerlerin ve içeriğin sabit kalacağı anlamına gelir. Değişmez nesneler, genellikle uygulama durumunu daha öngörülebilir ve hatasız hale getirmek için kullanılır.

- **Örnek**: Kotlin'de `String` sınıfı bir değişmez nesnedir. Bir `String` nesnesi oluşturulduğunda, bu nesnenin içeriği değiştirilemez. Ancak, yeni bir `String` nesnesi oluşturulabilir.

  ```kotlin
  val str = "Hello"
  val newStr = str + " World"
  // str hala "Hello", newStr ise "Hello World" olur
  ```

### 2. **Salt Okunur (Read-Only) Kavramı**

**Salt okunur (read-only)** bir değişken, bir kez atandıktan sonra değiştirilemez, yani yalnızca okunabilir. Bu, değişkenin değerinin dışarıdan değiştirilemez olduğu anlamına gelir, ancak değişkenin referansının kendisi değiştirilebilir. 

- **Örnek**: Kotlin'de `val` anahtar kelimesi ile tanımlanan değişkenler salt okunur olarak kabul edilir. Bu, değişkenin değerinin atandıktan sonra değiştirilemeyeceği anlamına gelir. Ancak, `val` ile tanımlanan bir değişken, değişkenin referansının kendisi değiştirilebilir.

  ```kotlin
  val list = mutableListOf("item1", "item2")
  list.add("item3")
  // list'in referansı değişmez, ama içeriği değişebilir.
  ```

### 3. **`val` Değişkenler Neden "Salt Okunur" Olarak Açıklanmalıdır?**

Kotlin'deki `val` anahtar kelimesi bir değişkenin salt okunur olduğunu belirtir, yani değişkenin değeri bir kez atandıktan sonra değiştirilemez. Ancak, bu değişkenin referansının kendisi değişmez. Bu nedenle, `val` değişkenler aslında tamamen değişmez (immutable) değildir, çünkü:

- **Nesne Referansları Değişmez**: `val` değişkeninin değeri değiştirilemez, ancak bu değişken bir nesneye referans gösteriyorsa, nesnenin içeriği değiştirilebilir. Örneğin, `val` ile tanımlanan bir `List` değişkeni, bir `mutableListOf` nesnesini referans alıyorsa, listenin içeriği değiştirilebilir.

- **Yalnızca Referansın Değişmezliği**: `val` değişkenleri yalnızca referansın değiştirilemezliğini garanti eder. Eğer değişken bir değişken türü (örneğin, bir liste veya bir nesne) referans alıyorsa, bu referansın gösterdiği nesnenin içeriği değişebilir.

  ```kotlin
  val myList = mutableListOf("apple", "banana")
  myList.add("cherry") // myList'in içeriği değişti, referansı değişmedi
  ```

### Özet

- **Değişmez (Immutable)**: Bir nesnenin oluşturulduktan sonra değişmez olduğunu ifade eder. `String` gibi bazı sınıflar bu özelliğe sahiptir.
- **Salt Okunur (Read-Only)**: Bir değişkenin değeri yalnızca okunabilir ve değiştirilemez, ancak bu değişkenin referansının kendisi değiştirilemez. `val` değişkenleri bu tür değişkenlerdir.

`val` değişkenleri "değişmez" olarak açıklanmak yerine "salt okunur" olarak açıklanmalıdır, çünkü `val` değişkenlerinin referansı değişmez, ancak referansın gösterdiği nesnenin içeriği değiştirilebilir. Bu, `val` değişkenlerinin referanslarıyla ilişkili nesnelerin değiştirilebilirliğini yansıtmaz.


### Not: val değişkenlere genelde immutable dendiğinid uyarsınız fakat bu yanlış bir tabirdir. readonly olarak tanımlanması daha doğrudur.

=================================================================================

4. - "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

"Tip çıkarımı" (type inference), bir programlama dilinde değişkenlerin veya ifadelerin tiplerini otomatik olarak belirleme sürecidir. Bu, programcıların her değişkenin veya ifadenin tipini açıkça belirtmelerine gerek kalmadan, dilin derleyicisinin veya yorumlayıcısının bu bilgiyi otomatik olarak çıkarmasını sağlar. Tip çıkarımı, birçok modern programlama dilinde kullanılır ve genellikle daha kısa, okunabilir ve bakımını kolaylaştıran kodlar yazmayı mümkün kılar.

### Tip Çıkarımının Özellikleri

1. **Otomatik Tip Belirleme**: Programcı, değişkenlerin ve ifadelerin tiplerini açıkça belirtmeden, derleyici veya yorumlayıcı bu bilgiyi kodun analizinden elde eder.
   
2. **Kısaltma ve Temizlik**: Programcılar kodda tekrar tekrar tip bilgisi yazmak zorunda kalmadan, daha kısa ve temiz kodlar yazabilirler.

3. **Gelişmiş Tip Çıkarımı**: Bazı diller, daha karmaşık tip çıkarımı yapabilir, örneğin, generik tiplerde veya fonksiyonların geri dönüş türlerinde.

### Hangi Durumlarda Tip Belirtmek Kesin Olarak Gereklidir?

Tip çıkarımı genellikle birçok durumda oldukça yeterli olabilir, ancak bazı durumlarda tip belirtmek kesinlikle gereklidir:

1. **Çok Anlamlılık (Ambiguity)**: Derleyici ya da yorumlayıcı, bir ifadenin tipini net bir şekilde çıkaramadığında, tip belirtmek gerekebilir. Örneğin, birden fazla olası tip içeren bir işlem yapıldığında, hangi tipin kullanılacağını belirtmek önemli olabilir.

2. **Tip Güvenliği**: Tip güvenliğini sağlamak için, özellikle karmaşık yapıların ve fonksiyonların doğru çalışması için tiplerin açıkça belirtilmesi gerekebilir. Bu, hataların daha erken aşamalarda tespit edilmesine yardımcı olabilir.

3. **Performans**: Bazı durumlarda, belirli bir türün açıkça belirtilmesi, derleyicinin kodun daha etkili bir şekilde optimize edilmesini sağlayabilir.

4. **Okunabilirlik ve Bakım**: Karmaşık kodlarda, özellikle tiplerin net bir şekilde belirtilmesi, kodun okunabilirliğini ve bakımını kolaylaştırabilir.

5. **Dış Kütüphaneler ve API'ler**: Bir dış kütüphaneyi veya API'yi kullanırken, doğru tiplerin belirtilmesi, kütüphanenin beklediği veri türlerini ve işlevselliği doğru bir şekilde kullanmanızı sağlar.

### Örnekler

- **Python** (dinamik tip çıkarımı): 

  ```python
  x = 10  # Python otomatik olarak x'in bir int olduğunu çıkarır.
  y = "Hello"  # Python otomatik olarak y'nin bir str olduğunu çıkarır.
  ```

- **Haskell** (statik tip çıkarımı): 

  ```haskell
  double :: Int -> Int
  double x = x * 2  -- Haskell, 'x' ve fonksiyonun döndüreceği tiplerin Int olduğunu çıkarır.
  ```

- **C++** (auto anahtar kelimesi ile tip çıkarımı):

  ```cpp
  auto x = 10;  // Derleyici x'in int olduğunu çıkarır.
  auto y = 3.14;  // Derleyici y'nin double olduğunu çıkarır.
  ```

Tip çıkarımı, doğru kullanıldığında programlama sürecini oldukça kolaylaştırabilir, ancak programcıların tiplerin ne anlama geldiğini ve potansiyel hataları iyi anlamaları her zaman önemlidir.


### Not: Bir değişken tipinin "=" sağ tarafında ki veriye bakarak belirlenmesi işlemidir. Ancak sayısal değerlerde verilen değer ınt içerisindeyse... int üzerindeyse long set ediliri.

=================================================================================

5. - Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

Cevap: Kotlin'de, tüm değişkenler bir sınıf olarak bulunur; ancak bu, Kotlin’in ilkel tipleri desteklemediği anlamına gelmez. Kotlin, Java sanal makinesi (JVM) üzerinde çalıştığı için, bazı optimizasyonlar ve performans iyileştirmeleri için ilkel tipleri (primitive types) kullanır. İşte detaylar:

### Kotlin'de Değişkenler ve İlgili Kavramlar

1. **Sınıf Temelli Değişkenler**: Kotlin'de, temel veri türleri (örneğin `Int`, `Double`, `Boolean`) sınıf türleri olarak temsil edilir. Ancak, bu sınıflar JVM'de karşılık gelen ilkel tiplerle (primitive types) optimize edilir.

2. **İlkel Tipler ve Wrapper Sınıflar**: Kotlin'de, ilkel tipler `Int`, `Double`, `Char`, `Boolean`, vb., JVM tarafından yönetilen ilkel türler olarak kullanılır. JVM düzeyinde, bu türler performans için doğrudan bellek erişimi ve işlem yapılabilir. Kotlin, bu ilkel türlerle çalışan kodları yazarken, bu türleri otomatik olarak `int`, `double`, `char`, `boolean` gibi ilkel türlerle optimize eder.

3. **Autoboxing ve Unboxing**: Kotlin, JVM ile uyumluluk sağlamak için `autoboxing` (ilkel tiplerin nesne türlerine dönüştürülmesi) ve `unboxing` (nesne türlerinin ilkel tiplere dönüştürülmesi) işlemlerini otomatik olarak yönetir. Kotlin kodu yazarken, bu dönüşümler genellikle programcı tarafından görünmez.

4. **Performans İyileştirmeleri**: Kotlin, temel veri türlerini JVM'de ilkel türler olarak kullanır. Örneğin, bir `Int` değişkeni Kotlin kodunda bir `Integer` nesnesi gibi görünebilir, ancak JVM tarafından doğrudan `int` türünde işlenir. Bu, performans iyileştirmeleri sağlar çünkü ilkel türler bellek ve işlem açısından daha verimlidir.

### Arka Planda Neler Oluyor?

- **JVM Optimizasyonları**: Kotlin kodu derlendiğinde, değişkenler JVM ilkel türleri olarak işlenir. Örneğin, `Int` tipi Kotlin’de `int` olarak, `Double` tipi `double` olarak derlenir. Bu, Kotlin’in hem nesne yönelimli programlama yapısını hem de ilkel türlerin performans avantajlarını bir araya getirir.

- **Nesne ve İlkel Tiplerin Dönüşümleri**: Kotlin, nesne ve ilkel tipler arasındaki dönüşümleri otomatik olarak yönetir. Bu dönüşümler, performans üzerinde büyük bir etki yapabilir, özellikle büyük veri yapıları veya yoğun işlem gerektiren hesaplamalarda.

- **Kotlin `Boxing` ve `Unboxing`**: Kotlin, `Integer`, `Double`, vb. gibi wrapper sınıflarını kullanırken, otomatik olarak `boxing` (ilkel türleri nesne türlerine dönüştürme) ve `unboxing` (nesne türlerini ilkel türlere dönüştürme) işlemlerini yapar. Bu işlemler JVM tarafından optimizasyonlar sayesinde çoğu zaman etkisiz hale getirilir, yani performans üzerinde minimal bir etki yaratır.

### Özet

Kotlin’de temel veri türleri, arka planda JVM tarafından ilkel türler olarak optimize edilir. Bu, Kotlin’in hem nesne yönelimli programlama özelliklerinden faydalandığını hem de performans için ilkel türlerin avantajlarını kullandığını gösterir. Kotlin kodunuzda değişkenler sınıf türleri olarak görünebilir, ancak bu genellikle JVM düzeyinde ilkel türlerle optimize edilir, bu da hem okunabilirlik hem de performans açısından avantaj sağlar.

=================================================================================
