1) val ile var arasındaki fark nedir?

val ->  değeri sonradan değiştirilemeyen değişkendir. Value(sabit) kelimesinin kısaltmasıdır. Genellikle "immutable" olarak bilinsede "immutable" değil "read-only" değişkendir. "read-only" demek ilk değer atamasından sonra tekrar değer atanamaz demektir. "immutable" ise bir değişkenin veya nesnenin durumu ilk değerden farklı olamaz demektir.
var -> değeri sonradan değiştirilebilen değişkendir. Variable(değişken) kelimesinin kısaltmasıdır.

örn :
var a = 12
a = 14 // değerini sonradan değiştirebildik

val b = 12
b = 14 // hata alacaktır değeri sonradan değiştirilemez

**immutable değilde read-only denilen durum için
-> fullname'i val olarak tanımlasakta get fonk sabit bir değere değilde değişebilen parametrelere bağlı olduğu için farklı değerler için farklı sonuçlar üretebildi.

class Person {
    var name = "Cansel"
    var surname = "Değdaş"

    val fullName : String
        get() {
            return name + surname
        }
}

fun getFullNameOfPerson() {
    val person = Person()
    person.name = "İlyas"
    person.surname = "Yüregir"
    print(person.fullName) // sonucu İlyas Yüregir olarak print eder

    val person = Person()
    person.name = "Seher"
     person.surname = "Değdaş"
     print(person.fullName) // sonucu Seher Değdaş olarak print eder
}

2) Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

Değişkenin set fonksiyonunu private yaparak val gibi davranmasını sağlayabiliriz. Çünkü bir değişkene değer atamamızı sağlayan değişkenin set fonksiyonuna bağlıdır. var değişkenin set fonksiyonunu private yapıp "show kotlin bytecode" ile decompile ettiğimizde set fonklsiyonu oluşturmadığına bakabiliriz.

Val kullanmak yerine bunu neden kullanmak isteriz sorusuna cevap olarak, değişkeni ilgili class içerisinde değiştirmek isteyipte dışarıdan başka bir class veya fonk içerisinde değiştirilmesine izin vermek istemiyorsak kullanabiliriz.

örn:

Elimizde bir kullanıcı ismi var ve private set olarak ayarlandı ve sadece belirli bir validasyon ile değiştirilmesi isteniyor, bunu dışarıdan direkt erişim verirsek validasyona bağlı olmaksızın istemediğimiz şekilde değiştirilebilir. Bu yüzden private set yaparsak kullanıcı adı ilgili classta bu validasyonu sağladığı dıurumda güncellenmesi sağlanır.

class User(private var _username: String) {
    var username: String
        get() = _username
        private set(value) {
            if (validateUsername(value)) {
                _username = value
            }
        }

    private fun validateUsername(username: String): Boolean {
        // Kullanıcı adı geçerlilik kontrolü (örneğin minimum uzunluk vs.)
        return username.length >= 5
    }

    fun updateUsername(newUsername: String) {
        if (validateUsername(newUsername)) {
            _username = newUsername
        }
    }
}

fun main() {
    val user = User("JohnDoe")
    println(user.username)  // JohnDoe

    // user.username = "NewName" // Dışarıdan değiştirme yapılamaz (compile error)

    user.updateUsername("NewName")
    println(user.username)  // NewName
}


3) "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

 "read-only" -> bir değişkene değer atamasından sonra tekrar değer atanamaz demektir.
 "immutable" -> bir değişkenin veya nesnenin durumu ilk değerden farklı olamaz demektir.

 -> fullname'i val olarak tanımlasakta get fonk sabit bir değere değilde değişebilen parametrelere bağlı olduğu için farklı değerler için farklı sonuçlar üretebildi.

 class Person {
     var name = "Cansel"
     var surname = "Değdaş"

     val fullName : String
         get() {
             return name + surname
         }
 }

 fun getFullNameOfPerson() {
     val person = Person()
     person.name = "İlyas"
     person.surname = "Yüregir"
     print(person.fullName) // sonucu İlyas Yüregir olarak print eder

     val person = Person()
     person.name = "Seher"
      person.surname = "Değdaş"
      print(person.fullName) // sonucu Seher Değdaş olarak print eder
 }

 4) "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

 Bir değişkenin tanımlandığı anda açıkça(explicit) tip belirtilmediğinde atanan değer doğrultusunda ide'nin değişkenin tipini belirlemesidir.

 Eğer bir değişken tanımlandığı anda değer ataması yapılmayacaksa tip belirtmek gerekir. Çünkü ide'nin değişkeni tanımlayabilmesi ve ram'de uygun yer ayırabilmesi için değişkenin tipine ihtiyacı vardır. Tip'e göre ram'de ayrılan yerin boyutu değişiklik gösterir.



 5) Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

 Kotlinde değişken tipleri sınıf olarak bulunsalarda çalışma zamanda yapılan özel optimizasyonlarla javadaki primitive tiplere karşılık gelirler. Show kotlin Byte kod ile bakıldığında gözlemlenebilir.

 örn:
 Kotlin -> val a: Int = 10 bu koda show kotlin byte kod ile decompile ettiğimizde aşağıdaki gibi javada olan primitive karşılığını göreceğiz.
 Java -> int a = 10



6) "Tip Güvenliği" (Type Safety) kavramını açıklayın.

 Her değişkenin ve ifadenin yalnızca belirli bir türle çalışmasını garanti altına alan bir kavramdır.

 örn:
 var name: String = "Kotlin"
 name = 123 // bu şekilde atama yaptığımızda name String tipinde olduğı halde int tipinde bir değer ataması olduğu için derleme zamanında hata verir.



 7) Bir değişkeni nullable yapmak için ne yapmalıyız?

 Bir değişkeni null yapmak için değişken tipinin sonuna ? işaretini koymamız gerekir.

 örn:  nullable bir değişken hem null hem de değere sahip olabilir demektir.
 var number1: Int? = 10
 number1 = null