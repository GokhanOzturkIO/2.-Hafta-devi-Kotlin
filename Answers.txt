BASIC TYPES & NULL SAFETY

1) var , değişkenin değerini herhangi bir zamanda değiştirebiliriz. val değeri bir kez atanabilen bir değişkeni tanımlar. Yani bir kez tanımlandıktan sonra değiştiremeyiz. 


<--------------------------------------------------------------------------------------------------------------------------------------------------->


2) Bir var değerinin değişkenin val gibi davranması için setini private yaparız. Değişkenin değerinin sadece o sınıf içerisinde değiştirilebilmesi dışarıdan ise sadece okunabilir olması için private yapabiliriz. 


<--------------------------------------------------------------------------------------------------------------------------------------------------->



3) Read only değeri okunabilen ama set edilemeyen anlamına gelir. Immutable ise değeri hiçbir şekilde değiştirilemeyen anlamına gelir. Kotlin'de val anahtar kelimesi ile tanımlanan değişkenlerin "değişmez" değil de "salt okunur" olarak açıklanması, değişkenin değerinin atanmasından sonra değiştirilemez olduğunu, ancak içinde saklanan nesnenin değiştirilebilir olabileceğini vurgular. Yani, val ile tanımlanan bir değişkenin referansı değiştirilemez, ancak referansın işaret ettiği nesne değiştirilebilir. Bu nedenle, değişkenin kendisi değişmez olmayabilir, ancak değeri bir kez atandıktan sonra değiştirilemez. Bu durumda, değişkenin "salt okunur" olduğu söylenir.


<--------------------------------------------------------------------------------------------------------------------------------------------------->



4) Tip çıkarımı (type inference), bir programlama dilinde değişkenin veya ifadenin veri türünün otomatik olarak belirlenmesidir. Bu, programcının belirli bir değişkenin veya ifadenin veri türünü açıkça belirtmesine gerek olmadığı anlamına gelir. İlk değeri olmayan değişken oluşturduğumuz zaman tipini belirtmeliyiz. Kotlinde sayısal değerler virgüllü değil ve integer değer aralığında ise default olarak integer tanımlanır. Byte veya short kullanmaz istersek tipleri belirtmemiz gerekir



<--------------------------------------------------------------------------------------------------------------------------------------------------->



5) Kotlin de class gibi gözüken değişken tipleri özel optimizasyonlarla byte koda çevrilirken primitive olacak şekilde çevriliyorlar.



<--------------------------------------------------------------------------------------------------------------------------------------------------->



6) "Tip Güvenliği" (Type Safety), bir programlama dilinde belirli türlerin birbirleriyle uyumlu şekilde kullanılmasını ve hatalı tür dönüşümlerinin engellenmesini sağlayan bir özelliktir. 



<--------------------------------------------------------------------------------------------------------------------------------------------------->



7) Bir değişkenin nullable yapmak için ? kullanırız. Örneğin "val name: String? = null" şeklinde.



<--------------------------------------------------------------------------------------------------------------------------------------------------->



8) Null Safety bir nesne null olduğunda ve ona erişmeye çalıştığımızda hata almamızı engellemek için oluşturulmuştur. Null durumunu kontrol eder. Kotlin gibi dillerde, null güvenliği sağlamak için değişkenlerin null olabileceğini açıkça belirtmek gerekir. Bu şekilde, bir değişkenin null olup olmadığını kontrol edebiliriz ve hata olasılığını azaltabiliriz.Ayrıca, Kotlin gibi dillerde null kontrol operatörleri gibi araçlar sağlanır. Bu operatörler, bir nesnenin null olup olmadığını kontrol eder ve null olduğunda hata almayız. Bu sayede, programlarımız daha güvenli hale gelir ve daha az hata içerir.



<--------------------------------------------------------------------------------------------------------------------------------------------------->



9) Bir değişkene null değer atanır ve tip belitrilmezse Kotlin bu değişkeni Nothing olarak yorumlar. 



<--------------------------------------------------------------------------------------------------------------------------------------------------->



10)  İlkel bir değişkenin nullable olması, o değişkenin null değer alabilmesi anlamına gelir. Bu durumda, bellekte bir ilave alan ayrılması gerekir çünkü null değer alabilen bir değişken, bir değere (örneğin, bir referansa) işaret etmeyebilir. Dolayısıyla, nullable bir değişken için bellekte bir miktar ek alan ayrılması gerekir. Ancak, nullable olmayan bir ilkel değişkenin bellekte ayrılacak herhangi bir ek alanı yoktur çünkü 


<--------------------------------------------------------------------------------------------------------------------------------------------------->


11) Null değer almış bir değişken bellekte yer kaplamaz. Nullable bir değişkenin bir değere sahip olması durumunda, o değişken için bellekte bir alan ayrılması gerekir. Değişkenin tutacağı değer, bellekte bir yer kaplar ve bu bellek alanı kullanılır. Ancak, nullable bir değişken null değer almışsa, bellekte hiçbir alan ayrılmaz. Null değer, değişkenin bir değere işaret etmediği anlamına gelir ve dolayısıyla bellekte yer kaplamaz.


<--------------------------------------------------------------------------------------------------------------------------------------------------->


12) Nullable bir değişkenle çalışırken kullandığımız iki tane operatör vardır. Bunlar ? ve !! operatörleridir. ? opeartörü değişkenin null olabileceği anlamında gelir. !! operatörü ise değerin kesinlikle null olmayacağını bildiğimiz durumlarda kullanılır, ide ye değer kesinlikle null değil demiş oluruz.



NUMBERS 


1) 10 farklı tipte number sınıfını miras alan alt sınıf vardır. Bunlar:
	Byte, Short, Int, Long, UByte, .UShort, UInt, ULong, Float, Double
Değer aralıkları bellekte kapladıkları alan açısından önemlidir. Değerimiz hangi tip aralığında ise o tipte değişken tanımlamam bellek kullanımı açısından önemlidir.



<--------------------------------------------------------------------------------------------------------------------------------------------------->



2) Eğer değişken integer değer aralığında ise integer olarak atanır. İnteger değer aralığından büyük ise Long olarak atanır. Virgüllü değerlerde ise double olarak atanır. 


<--------------------------------------------------------------------------------------------------------------------------------------------------->


3) l harfinin kullanılamamasının sebebi 1 sayısına benziyor olması.


<--------------------------------------------------------------------------------------------------------------------------------------------------->



4) 
Tek Duyarlıklı (Single Precision):
Tek duyarlıklı, kayan nokta sayılarını daha az bellek kullanarak depolayan bir veri tipidir. Genellikle "float" olarak adlandırılır ve 32 bit (4 byte) bellek alanı kullanır. Bu tip, genellikle daha sınırlı hassasiyet gerektiren hesaplamalarda kullanılır. Örneğin, grafik işleme veya sensor verileri gibi uygulamalarda kullanılabilir.

Çift Duyarlıklı (Double Precision):
Çift duyarlıklı, daha yüksek hassasiyete sahip kayan nokta sayılarını depolamak için kullanılan bir veri tipidir. Genellikle "double" olarak adlandırılır ve 64 bit (8 byte) bellek alanı kullanır. Bu tip, daha geniş bir sayı aralığında ve daha yüksek hassasiyette hesaplamalar gerektiren uygulamalarda kullanılır. Bilimsel hesaplamalar, finansal uygulamalar ve hassas veri analizi gibi alanlarda çift duyarlıklı veri tipi tercih edilir.



<--------------------------------------------------------------------------------------------------------------------------------------------------->


5) Kotlin'de, Double ve Float veri tipleri ile ondalık ayıracı olarak nokta('.') kullanılır. Nokta yerine virgül kullanılması durumunda hata ile karşılaşabiliriz. Uzak sunucudan sayısal bir değer çekiyor isek bu değerin virgül ile mi nokta ile mi geldiğini kontrol etmemiz gerekir. 


<--------------------------------------------------------------------------------------------------------------------------------------------------->


6) Float veri tipi, yaklaşık 7 basamak hassasiyete sahiptir. Bu, ondalık kısımda en fazla 7 rakamı doğru bir şekilde temsil edebileceği anlamına gelir. 
Double veri tipi, daha yüksek bir hassasiyete sahiptir ve yaklaşık 15-16 basamaklık bir hassasiyet sunar. Float veri tipi, daha az bellek kullanır ve bazı uygulamalarda yeterli hassasiyeti sağlayabilir. Ancak, yüksek hassasiyet gerektiren işlemlerde veya büyük sayı aralıklarında çalışırken Float veri tipi kullanılmamalıdır. Genel olarak, hassasiyet ve bellek kullanımı arasında bir denge sağlamak önemlidir. Hassas işlemler için Double, daha düşük bellek kullanımı gereken durumlar için ise Float tercih edilir.


<--------------------------------------------------------------------------------------------------------------------------------------------------->


7) Ondalık sayılarda alt çizgi ('_') ile tanımlayabiliriz. val number = 10_000_000
Hexadecimal sayılar val hexadecimalNumberLong: Long = 0xABCDL
Binary sayılar val binaryNumberLong: Long = 0b11001100L 
şekillerinde tanımlanır. 



<--------------------------------------------------------------------------------------------------------------------------------------------------->



8) Java'da sekizlik (Octal) sayılar, ön ek olarak 0 kullanılarak tanımlanır. Ancak, Kotlin'de doğrudan sekizlik bir sayı tanımlama söz konusu değildir. Kotlin'de, ondalık (Decimal), onaltılık (Hexadecimal) ve ikilik (Binary) sayılar doğrudan desteklenirken, sekizlik sayılar için özel bir tanımlama yoktur.


<--------------------------------------------------------------------------------------------------------------------------------------------------->


9) Geleneksel notasyon sayıların alt çizgi('_') ile ayrılmasıdır.  Örneğin val number = 10_000_000 


<--------------------------------------------------------------------------------------------------------------------------------------------------->


10) val number = 1_000_000  Kotlin bu alt çizgileri yok sayarak sayıyı yorumlar. 


<--------------------------------------------------------------------------------------------------------------------------------------------------->


11) '==' operatörü, iki değerin eşit olup olmadığını kontrol eder. Eşitlik kontrolünde, referansları değil, değerlerin kendisini karşılaştırır. Yani, eğer iki değer aynı değere sahipse (içeriği aynıysa), true döner. 
'===' operatörü, referansların aynı olup olmadığını kontrol eder. Yani, iki değişken aynı nesneyi mi işaret ediyor yoksa farklı nesneleri mi işaret ediyor kontrol eder. 


<--------------------------------------------------------------------------------------------------------------------------------------------------->


12)  Kotlin'de === operatörü referans karşılaştırması yapar ve bu operatörün kullanımı, veri türlerine göre farklı davranışlar sergileyebilir. Özellikle Byte veri tipi için bu önemlidir çünkü Kotlin'de -128 ile 127 arasındaki Byte değerleri için bir önbellek mekanizması vardır.

Java'da olduğu gibi, Kotlin'de de -128 ile 127 arasındaki Byte değerleri için bellekte tek bir kopya tutulur ve her değişken bu bellek bloğunu işaret eder. Bu, === operatörünün bu aralıktaki Byte değerleri için referansların aynı olup olmadığını doğru bir şekilde kontrol etmesini sağlar.

Ancak, bu önbellek mekanizması yalnızca -128 ile 127 aralığındaki değerler için geçerlidir. Bu aralık dışındaki Byte değerleri için her değişken ayrı bir bellek bloğunu işaret eder ve bu durumda === operatörü referansların aynı olup olmadığını doğru bir şekilde kontrol edemez.

Bu nedenle, Byte veri tipi için === operatörünün -128 ile 127 aralığındaki değerler için özel bir davranış sergilediğini söyleyebiliriz. Diğer Byte değerleri için bu operatör referansların aynı olup olmadığını kontrol eder. Bu önemli bir detaydır ve Byte veri tipiyle çalışırken referans karşılaştırması yaparken dikkate alınması gereken bir husustur.


<--------------------------------------------------------------------------------------------------------------------------------------------------->


13) Toplama, çıkarma, çarpma, bölme, mod alma


<--------------------------------------------------------------------------------------------------------------------------------------------------->


14) 
	1) "=="
	2) "!="
	3) ">"
	4) "<"
	5) ">="
	6) "<="
	7) "==="



<--------------------------------------------------------------------------------------------------------------------------------------------------->



15) 
Bit düzeyinde operatörler (Bitwise operators), sayıları binary (ikilik) düzeyde manipüle etmek için kullanılan operatörlerdir. Bu operatörler, bit seviyesinde mantıksal ve aritmetik operasyonlar gerçekleştirirler.

Kullanılan bit düzeyinde operatörler şunlardır:

VE (AND) (&): İki sayının her iki biti de 1 ise sonuç 1 olur, diğer durumlarda sonuç 0 olur.

VEYA (OR) (|): İki sayının herhangi biri 1 ise sonuç 1 olur, her iki bit de 0 ise sonuç 0 olur.

XOR (XOR) (^): İki sayının bitleri farklıysa sonuç 1 olur, aynıysa sonuç 0 olur.

Tersi Alma (NOT) (~): Bir sayının her bir bitini tersine çevirir, yani 0'ları 1 yapar, 1'leri 0 yapar.

Kaydırma Sola (Shift Left) (<<): Belirtilen sayıda biti sola doğru kaydırır, sağdaki boşlukları 0 yapar.

Kaydırma Sağa (Shift Right) (>>): Belirtilen sayıda biti sağa doğru kaydırır, soldaki boşlukları işaret biti ile doldurur.


<--------------------------------------------------------------------------------------------------------------------------------------------------->


16) 
Kotlin'de büyük sayılarla çalışırken, BigInteger ve BigDecimal gibi büyük sayıları temsil etmek için özel veri tiplerinden yararlanılır.

BigInteger: Bu sınıf, işaretli tam sayıları (integer) temsil etmek için kullanılır. Bu sınıf, herhangi bir boyutta tam sayıları temsil edebilir, yani pratikte sınırlı değildir. BigInteger sınıfı, büyük sayılarla çalışırken hassas hesaplamalar yapmak için kullanılır.

BigDecimal: Bu sınıf, ondalık sayıları (decimal) temsil etmek için kullanılır. BigDecimal sınıfı, ondalık noktadan sonra daha yüksek hassasiyet sağlar ve büyük ve hassas ondalık sayılarla çalışırken kullanılır.


<--------------------------------------------------------------------------------------------------------------------------------------------------->


17) 
Double ve Float gibi kayan noktalı sayı veri tipleri, hassas ondalık sayılarla çalışırken bazı yuvarlama davranışları gösterirler. Bu yuvarlama davranışı, veri türünün iç yapısından kaynaklanır ve genellikle IEEE 754 standartlarına uygun olarak gerçekleşir.

Kotlin'de, Double ve Float değerleri varsayılan olarak yakınsak yuvarlama yöntemini kullanır. Bu, bir sayıyı en yakın tam sayıya yuvarlarken, tam sayıya en yakın olan çift sayıya yuvarlamayı tercih eder. Örneğin:

0.5 değeri yukarı yuvarlanırken 0.4 değeri aşağı yuvarlanır.
1.5 değeri 2 olarak yuvarlanırken, 2.5 değeri de 2 olarak yuvarlanır.
Bu varsayılan davranış, çoğu durumda uygundur, ancak bazı durumlarda farklı yuvarlama davranışlarına ihtiyaç duyabilirsiniz. Bu durumlarda, yuvarlama davranışını değiştirmek için farklı yöntemler kullanılabilir:

Yakınsak Yuvarlama (Round): Bu, Double ve Float veri türlerinin varsayılan yuvarlama davranışıdır. En yakın tam sayıya yuvarlar ve tam sayıya en yakın olan çift sayıya yuvarlamayı tercih eder.

Aşağı Yuvarlama (Floor): Bu yöntem, bir sayıyı bir alt tam sayıya yuvarlar. floor() fonksiyonu ile gerçekleştirilebilir.

Yukarı Yuvarlama (Ceil): Bu yöntem, bir sayıyı bir üst tam sayıya yuvarlar. ceil() fonksiyonu ile gerçekleştirilebilir.

Yönünü Belirleyen Yuvarlama (Rounding Mode): Bazı durumlarda, yuvarlama davranışını daha ayrıntılı olarak kontrol etmek gerekebilir. Bu durumda, yönünü belirleyen yuvarlama modunu kullanabilirsiniz. Bu mod, belirli bir yönde yuvarlama yapılmasını sağlar (yukarı, aşağı, sıfıra yakın, vb.). Bu genellikle RoundingMode sınıfı veya benzer bir mekanizma kullanılarak gerçekleştirilir.


<--------------------------------------------------------------------------------------------------------------------------------------------------->



UNSIGNED NUMBERS 


1) İşaretsiz değişkenler, yalnızca pozitif sayıları temsil etmek için kullanılır. Yani, işaretsiz değişkenlerin değerleri her zaman 0 veya daha büyük olacaktır. İşaretli değişkenler negatif sayılarda alabilir. 


<--------------------------------------------------------------------------------------------------------------------------------------------------->


2) İşaretsiz (Unsigned) değişkenler, sayıları temsil etmek için kullanılan bir veri türüdür ve genellikle pozitif tamsayıları temsil etmek için kullanılır. Bunlar, işaret biti (sign bit) olmadan, yani yalnızca pozitif değerler için ayrılan bellek alanlarında saklanırlar.İşaretsiz değişkenlerin kullanımı, bazı durumlarda daha doğru ve uygun sonuçlar almanızı sağlar. Özellikle, işaretsiz değerlerle çalışırken negatif sayılarla ilgili herhangi bir sorunla uğraşmazsınız. Ayrıca, işaretsiz değişkenler, bazı işlemler için daha optimize edilmiş olabilirler.