Soru 1: "val" ile "var" arasındaki fark nedir ? 

Cevap: "val" ve "var" ifadeleri değişken tanımlaması yaparken sonrasında durumunda değişim olup olmayacağını belirlemek için kullanıyoruz eğer değişebilir
bir durumda ise var değişemez bir durumda ise val ifadesi kullanımı uygundur Performans konusuna değinecek olursak aralarında bir fark yoktur diyebiliriz ancak 
mutli-thread işlemlerinde val kullanımı diğer işlemlerde de var kullanımı yapabiliriz. Akademik olarak var kullanımı val kullanımına göre daha performanslıdır
ancak kullanıcı işlemlerinde etkisi hissedilecek bir fark değildir bu.

Soru 2 : Bir var değişkenin val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz ? Örnek bir senaryo verin ? 

Cevap: Bu işlemi değişkenin set fonksiyonunu private yaparak val gibi davranmasını sağlayabiliriz. Ek bir bilgi olarak bu işlemi class içerisinde yapmaya 
dikkat etmeliyiz çünkü fonksiyon içerindeki değişkenlere sadece o fonksiyon içerisinde erişebiliriz. Bu özelliği değişkenimize class dışından erişim sağlanmasını
istemediğimiz durumlarda kullanabiliriz. Direkt val olarak neden tanımlamıyoruz ? Çünkü farklı fonksiyonlarda name değişkenini kullanmak isteyebiliriz
Kısaca set() fonksiyonuna private visibility modifier eklersek değiştirilemez bir değişken elde etmiş oluruz. Dışarıdan okunabilir sınıf içerisinden değiştirilebilir
bir değişken yaratmış oluyoruz

var name = "Barış" 
    private set 	

Soru 3 : "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

Cevap: “Değişmez” (Immutable), bir nesnenin veya değişkenin değerinin oluşturulduktan sonra hiçbir şekilde değiştirilemediği anlamına gelir. Değişmez bir nesne veya
değişken, yalnızca bir kez değer atanabilen ve sonradan değiştirilemeyen bir sabittir. Örneğin, Kotlin’de const val anahtar kelimeleri ile tanımlanan değişkenler değişmezdir.
Bu değişkenlerin değerleri derleme zamanında belirlenir ve çalışma zamanında değiştirilemez. 

Örneğin: 
const val PI = 3.14 // değişmez değişken
PI = 3.15 // hata! değişmez değişkenin değeri değiştirilemez

Salt okunur” (ReadOnly), bir nesnenin veya değişkenin değerinin okunabileceği, ancak doğrudan değiştirilemeyeceği anlamına gelir. Salt okunur bir nesne veya değişken,
değer ataması yapılabilen, ancak daha sonra yeniden atama yapılamayan bir değişkendir. Ancak, salt okunur bir nesne veya değişkenin değeri, dolaylı olarak başka bir nesne
veya değişkene bağlı olarak değişebilir. Örneğin, Kotlin’de val anahtar kelimesi ile tanımlanan değişkenler salt okunurdur. Bu değişkenlerin değerleri çalışma zamanında
belirlenir ve doğrudan değiştirilemez. Ancak, bu değişkenler get fonksiyonu ile değişim yapabilir. Örneğin:

val name: String = "Barış" // salt okunur değişken  (Burayı değiştirdikçe değeri değişecektir)
name = "Barışş" // hata! salt okunur değişkenin değeri değiştirilemez
val nameLength: Int
    get() = this.name.length // get fonksiyonu ile değişim yapılabilir

Bu kavramları açıkladıktan sonra, val değişkenlerin neden aslında “değişmez” değil de “salt okunur” olarak açıklanması gerektiğini anlayabiliriz. Çünkü val değişkenlerin
değerleri, doğrudan değiştirilemese de, dolaylı olarak değişebilir. Bu, val değişkenlerin değerinin sabit olmadığını, ancak değiştirilemez olduğunu gösterir. Bu nedenle, val
değişkenler “değişmez” değil, “salt okunur” olarak tanımlanmalıdır.

Burayı toparlayacak olursak, şunu yazabiliriz:

Val değişkenler, değerleri doğrudan değiştirilemeyen, ancak get fonksiyonu ile değişebilen değişkenlerdir. Bu değişkenler, değişmez değil, salt okunur olarak adlandırılır.

Soru 4 :"Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

Cevap: Tip çıkarımı (Type inference), Kotlin’de bir değişkenin tipinin, değerine göre otomatik olarak belirlenmesi anlamına gelir. Bu, değişken tanımlarken tip belirtmenin
zorunlu olmadığı, ancak isteğe bağlı olduğu anlamına gelir. Kodun daha kısa ve okunabilir olması konusunda bize fayda sağlar.

val name = "Barış" // Tip çıkarımı ile String tipi belirlendi
val age = 23 // Tip çıkarımı ile Int tipi belirlendi


Ancak bazı durumlarda tip belirtmek durumundayız örneğin değer ataması yapmak istemiyorsak değişkenin türünü bildirmek zorundayız:

val age = 10 // sorun yok
val age : Int // Değer vermek istemiyorsak bu şekilde tip belirmek durumundayız

val age 
age = 10 şeklinde hata alacağız çünkü tipini belirtmedik daha önce. bunun dışında listeler ile çalışırken de içinde neleri barındıracağını belirtmemiz gerekebilir string, int gibi

Soru 5: Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

Cevap: Kotlin dilinde değişken tiplerimiz bir class'dan referans alır ve Java dilindeki gibi primitive tip değildir bu durumun avantaj ve dezavantajları vardır avantajları Class 
özelliklerini kullanabiliyor olmamız iken (.length, .toUpperCase()) dezavantajı ise bellek ve performans kaybıdır. örnek vermek gerekirse java'da int tipindeki bir değişken 
4 byte yer tutarken Kotlin dilinde 16 byte bellek kullanır. Kotlin dilinde primitive tip yoktur demek çok doğru değil çünkü Kotlin java ile uyumlu olabilmek için bazı durumlarda
bizim için derleme zamanında özel bir optimizasyon ile değişkenlerimizi primitive hale getiriyor. Bu değişken performansını arttırmak için kullanılır. Eğer değişken primitive
tipe atanabilen bir değişken ise derleme (compile) zamanında 

val number: Int = 10 // null olamayan bir tip, primitive tipe dönüştürülür
val number2: Int? = 10 // null olabilen bir tip, primitive tipe dönüştürülmez

Değişkenin bir String veri tipinden primitive dönüştürülebilen bir veri yapısına (Int, Double, Boolean vb.) ‘as’ keywordü ile cast işlemi yapılıyorsa, bu dönüşüm çalışma
zamanında (runtime) gerçekleşir. Örneğin:

val number: String = "10" // String bir tip, primitive tipe dönüştürülmez
val number2: Int = number.toInt() // String tipinden Int tipine cast işlemi, çalışma zamanında gerçekleşir

Soru 6: "Tip Güvenliği" (Type Safety) kavramını açıklayın.

Cevap: Tip güvenliği (Type Safety) kavramı, bir programlama dilinde her değişkenin belirli bir veri tipine sahip olması ve bu tipin çalışma zamanında değiştirilmemesi anlamına
gelir bu program hatalarını önlemeye ve performansı arttırmaya yardımcı olur. Kotlin Type Safety bir dildir ve bunun için iki yol vardır: 

-Statik tip belirleme
Değişken tanımlarken veri tipini açıkça belirtirsiniz. Örneğin var name : String = Barış

-Tip çıkarımı 
Değişken tanımlarken veri tipini belirtmiyoruz ancak Kotlin derleyicisi atanan değere göre veri tipini otomatik olarak çıkarır. Örneğin var name = "Ali"

Kotlin, tip güvenliğini sağlamak için bazı özellikler sunar. Bunlardan bazıları şunlardır:

Nullability: Kotlin, null değeri alabilen ve alamayan veri tiplerini ayırır. Null değeri alabilen bir veri tipi, sonuna ? işareti eklenerek tanımlanır.
Örneğin, var name: String? = null gibi. Null değeri alamayan bir veri tipi ise normal şekilde tanımlanır. Örneğin, var name: String = "Ali" gibi.
Bu şekilde, null pointer exception (NPE) adı verilen çalışma zamanı hatası önlenir.

Smart cast: Kotlin, bir değişkenin veri tipini kontrol ettikten sonra, o değişkenin tipine uygun işlemleri yapmanıza izin verir. Örneğin, var x: Any = 10 diyelim.
x değişkeni Any tipinde tanımlandığı için, herhangi bir veri tipi alabilir. Ancak, x değişkeninin Int tipinde olduğunu kontrol etmek isterseniz, if (x is Int) yazabilirsiniz.
Bu durumda, x değişkeni Int tipine otomatik olarak dönüştürülür ve Int tipine özgü işlemleri yapabilirsiniz. Örneğin, x + 5 gibi.

Soru 7: Bir değişkeni nullable yapmak için ne yapmalıyız?

Cevap: Bir değişkeni nullable yapmak için veri tipinin sonuna ? işareti eklemeliyiz. Örneğin var name: String? = null gibi. Bu şekilde değişkenin null değeri alabileceğini belirtiyoruz
Null değeri alamayan bir değişken ise normal şekilde tanımlanır. var name = String = "Barış". Nullable NullPointerException çalışma hatasından bizi kurtarmak için etkili bir yoldur.

Soru 8: "Null Güvenliği" (Null Safety) kavramını açıklayın.

Cevap: Null Güvenliği (Null Safety) bir programlama dilinde değişkenleri null(boş) değerlere sahip olma durumunu kontrol etmek ve başa çıkmak için kullanılır. Null bir değişken
veya nesnenin bellekte bulunmaması veya hiçbir şeye işaret etmemesi anlamına gelir. Bu noktada bu nesne veya değişkenin üyelerine erişmeye çalışmak NPE hatasını oluşturur
Kotlin dili null güvenliği konusunda oldukça güçlü bir dil olarak bilinmektedir. Kotlin değişkenlerin veya değerlerin null olup olmayacağını belirtmek için nullable ve non-nullable
türler arasında ayrım yapar.

Nullable değişkenler: Bir değişkenin null olması durumudur. Nullable değişkenlerinin tipi hem null hem de belirtilen türde (String, Int) olabilir bir nullable değişkeni kullanırken
null olup olmadığını kontrol etmemiz gerekmektedir. Örneğin var name : String? = null

Non-Nullable Değişkenler: Bir değişkenin null olmaması durumudur Non-Nullable değişkenlerin tipi sadece belirtilen tüden olabilir (String,Int) var name :String = Ali

Kotlin, nullable değişkenlerin değerlerini kontrol etmek ve null referans hatalarını önlemek için bazı özellikler sunar.

-Null Check: 
Bir değişkenin null olup olmadığını kontrol ederiz if(name != null)

-Safe Call (?.) bir değişkenin null olup olmadığından emin olmadan onun üyelerine erişmek için kullanılır. name?.lenght gibi (name null ise null değilse değerini döndürür)

-Elvis Operatörü(?:) Bir değişkenin null olması durumunda alternatif bir değer kullanmak için kullanılan bir operatördür. name?.lenght ?:0 gibi (null veya 0) olsun diyoruz.

-Not null Assertion Operatörü (!!): Bir değişkenin kesinlikle null olmadığını belirtmek için kullanılan bir operatördür. name!!.lenght gibi. Eğer null ise NPE patlayacaktır değilse
değerini döndürür. 
Kotlin, null güvenliği sayesinde, programlamada ortaya çıkabilecek birçok hata türünü azaltır ve kodunuzun güvenilirliğini, performansını ve okunabilirliğini artırır.

Soru 9: Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

Cevap: Kotlin, bir değişkene null değer atanır ve tip belirtilmezse, bu değişkenin tipini Nothing? olarak yorumlar çünkü tip çıkarımı yapamaz. Nullable ya da null olanlara any
veriliyor.

Soru 10: İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

Cevap: Null değişkenler bellek yönetimi açısından daha performanslıdır çünkü class olarak tutulurlar ancak nullable olmayan değişkenler daha az yer kaplar çünkü optimizasyon
ile primitive tiplere dönüştürülürler.

Soru 11: Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer
kaplamaz diyebilir miyiz?

Cevap: Bir değere sahip olan nullable bir değişken, bellekte hem veriyi hem de null olup olmadığını belirten bir bayrak tutar. Bu, nullable değişkenlerin bellek kullanımını artırır.
Örneğin, var sayi: Int? = 5 
Null olan nullable bir değişken, bellekte sadece null bayrağını tutar. Bu, nullable değişkenlerin bellek kullanımını azaltır. Örneğin, var sayi: Int? = null diyelim. 
Null değer almış bir değişken bellekte yer kaplamaz diyemeyiz, çünkü bu değişkenin null olduğunu belirten bir bayrak bellekte yer kaplar. Ancak, null değer almış bir değişken,
bir değere sahip olan nullable değişkene göre daha az bellek kullanır.

Soru 12: Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır?

Cevap: 

Safe call operatörü (?.): Bir değişkenin null olmadığından emin olmadan, onun üyelerine erişmek için kullanılan bir operatördür. Örneğin, name?.length gibi.
Eğer değişken null ise, null döndürür. Aksi halde, üyenin değerini döndürür. Bu operatörü, değişkenin null olabileceği durumlarda kullanmak daha anlamlıdır.


Elvis operatörü (?:): Bir değişkenin null olması durumunda, alternatif bir değer kullanmak için kullanılan bir operatördür. Örneğin, name?.length ?: 0 gibi. Eğer değişken null ise
0 döndürür. Aksi halde, üyenin değerini döndürür.  Bu operatörü, değişkenin null olması durumunda, alternatif bir değer kullanmak istediğiniz durumlarda kullanmak daha
anlamlıdır.

Not-null assertion operatörü (!!): Bir değişkenin kesinlikle null olmadığını belirtmek için kullanılan bir operatördür. Örneğin, name!!.length gibi. Eğer değişken null ise,
NullPointerException (NPE) fırlatır. Aksi halde, üyenin değerini döndürür. Bu operatörü, değişkenin null olmadığından kesinlikle emin olduğunuz ve NPE riskini göze aldığınız
durumlarda kullanmak daha anlamlıdır.

- - - - - - - - -
Sayılar
- - - - - - - - -

Soru 13: Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?

Cevap: Kotlin'de number sınıfı sayısal değerleri temsil eden soyut bir sınıftır. Bu sınıfın farklı alt sınıfları vardır. Bunlar Byte, Short, Int, Long, Float ve Double'dır. Bu alt sınıfların her biri için 
kullanılır. Örneğin Byte 8 bit, Short 16 bit, Int 32 Bit, Long 64 bit boyutundadır. Bu alt sınıfların değer aralıkları önemlidir, çünkü sayısal işlemler sırasında taşma (overflow) veya yuvarlama
(rounding) hataları oluşabilir. Taşma hatası, bir değişkenin değerinin, o değişkenin saklayabileceğinden daha büyük veya daha küçük olması durumunda ortaya çıkar. Yuvarlama hatası ise,
bir değişkenin değerinin, o değişkenin hassasiyetinden daha fazla ondalık basamağa sahip olması durumunda ortaya çıkar. Bu hatalar, programın beklenmedik şekilde davranmasına veya
yanlış sonuçlar üretmesine neden olabilir.

Bu nedenle, sayısal verileri saklamak için uygun alt sınıfı seçmek önemlidir. Bu, hem veri kaybını önlemek hem de bellek kullanımını optimize etmek için gereklidir. Kotlin, sayısal verileri
otomatik olarak dönüştürmez, bu yüzden farklı alt sınıflar arasında dönüşüm yapmak için belirli fonksiyonları kullanmak gerekir. Örneğin, bir Int değerini Double’a dönüştürmek için toDouble()
fonksiyonunu kullanabilirsiniz.

Sınıf	Boyut (bit)	Min değer	                            Max değer
Byte	8	                -128	                                            127
Short	16	                -32768	                                          32767
Int	32	                -2,147,483,648	                     2,147,483,647
Long	64	  -9,223,372,036,854,775,808 	    9,223,372,036,854,775,807
Float	32	    -3.4028235E38	                                     3.4028235E38
Double	64	 -1.7976931348623157E308	               1.7976931348623157E308


// Number sınıfından türetilmiş bir alt sınıf olan Int sınıfını kullanıyoruz
val x: Int = 10
println(x) // 10

// Int sınıfının bir özelliği olan toDouble() fonksiyonunu çağırarak, Int değerini Double değerine dönüştürüyoruz
val y: Double = x.toDouble()
println(y) // 10.0

Ek olarak rounding ve overflow hatalarına değinmek istiyorum.
Overflow, bir değişkenin değerinin, o değişkenin saklayabileceğinden daha büyük veya daha küçük olması durumunda çıkar.

val b: Byte = 128 // overflow hatası
println(b) // -128

Rounding, bir değişkenin değerinin o değişkenin hassasiyetinden daha fazla ondalık basamağa sahip olması durumunda ortaya çıkarç

val f: Float = 0.34444f // rounding hatası
println(f) // 0.34444001
























