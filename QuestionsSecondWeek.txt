Soru 1: "val" ile "var" arasındaki fark nedir ? 

Cevap: "val" ve "var" ifadeleri değişken tanımlaması yaparken sonrasında durumunda değişim olup olmayacağını belirlemek için kullanıyoruz eğer değişebilir
bir durumda ise var değişemez bir durumda ise val ifadesi kullanımı uygundur Performans konusuna değinecek olursak aralarında bir fark yoktur diyebiliriz ancak 
mutli-thread işlemlerinde val kullanımı diğer işlemlerde de var kullanımı yapabiliriz. Akademik olarak var kullanımı val kullanımına göre daha performanslıdır
ancak kullanıcı işlemlerinde etkisi hissedilecek bir fark değildir bu.

Soru 2 : Bir var değişkenin val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz ? Örnek bir senaryo verin ? 

Cevap: Bu işlemi değişkenin set fonksiyonunu private yaparak val gibi davranmasını sağlayabiliriz. Ek bir bilgi olarak bu işlemi class içerisinde yapmaya 
dikkat etmeliyiz çünkü fonksiyon içerindeki değişkenlere sadece o fonksiyon içerisinde erişebiliriz. Bu özelliği değişkenimize class dışından erişim sağlanmasını
istemediğimiz durumlarda kullanabiliriz. Direkt val olarak neden tanımlamıyoruz ? Çünkü farklı fonksiyonlarda name değişkenini kullanmak isteyebiliriz
Kısaca set() fonksiyonuna private visibility modifier eklersek değiştirilemez bir değişken elde etmiş oluruz. Dışarıdan okunabilir sınıf içerisinden değiştirilebilir
bir değişken yaratmış oluyoruz

var name = "Barış" 
    private set 	

Soru 3 : "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

Cevap: “Değişmez” (Immutable), bir nesnenin veya değişkenin değerinin oluşturulduktan sonra hiçbir şekilde değiştirilemediği anlamına gelir. Değişmez bir nesne veya
değişken, yalnızca bir kez değer atanabilen ve sonradan değiştirilemeyen bir sabittir. Örneğin, Kotlin’de const val anahtar kelimeleri ile tanımlanan değişkenler değişmezdir.
Bu değişkenlerin değerleri derleme zamanında belirlenir ve çalışma zamanında değiştirilemez. 

Örneğin: 
const val PI = 3.14 // değişmez değişken
PI = 3.15 // hata! değişmez değişkenin değeri değiştirilemez

Salt okunur” (ReadOnly), bir nesnenin veya değişkenin değerinin okunabileceği, ancak doğrudan değiştirilemeyeceği anlamına gelir. Salt okunur bir nesne veya değişken,
değer ataması yapılabilen, ancak daha sonra yeniden atama yapılamayan bir değişkendir. Ancak, salt okunur bir nesne veya değişkenin değeri, dolaylı olarak başka bir nesne
veya değişkene bağlı olarak değişebilir. Örneğin, Kotlin’de val anahtar kelimesi ile tanımlanan değişkenler salt okunurdur. Bu değişkenlerin değerleri çalışma zamanında
belirlenir ve doğrudan değiştirilemez. Ancak, bu değişkenler get fonksiyonu ile değişim yapabilir. Örneğin:

val name: String = "Barış" // salt okunur değişken  (Burayı değiştirdikçe değeri değişecektir)
name = "Barışş" // hata! salt okunur değişkenin değeri değiştirilemez
val nameLength: Int
    get() = this.name.length // get fonksiyonu ile değişim yapılabilir

Bu kavramları açıkladıktan sonra, val değişkenlerin neden aslında “değişmez” değil de “salt okunur” olarak açıklanması gerektiğini anlayabiliriz. Çünkü val değişkenlerin
değerleri, doğrudan değiştirilemese de, dolaylı olarak değişebilir. Bu, val değişkenlerin değerinin sabit olmadığını, ancak değiştirilemez olduğunu gösterir. Bu nedenle, val
değişkenler “değişmez” değil, “salt okunur” olarak tanımlanmalıdır.

Burayı toparlayacak olursak, şunu yazabiliriz:

Val değişkenler, değerleri doğrudan değiştirilemeyen, ancak get fonksiyonu ile değişebilen değişkenlerdir. Bu değişkenler, değişmez değil, salt okunur olarak adlandırılır.

Soru 4 :"Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

Cevap: Tip çıkarımı (Type inference), Kotlin’de bir değişkenin tipinin, değerine göre otomatik olarak belirlenmesi anlamına gelir. Bu, değişken tanımlarken tip belirtmenin
zorunlu olmadığı, ancak isteğe bağlı olduğu anlamına gelir. Kodun daha kısa ve okunabilir olması konusunda bize fayda sağlar.

val name = "Barış" // Tip çıkarımı ile String tipi belirlendi
val age = 23 // Tip çıkarımı ile Int tipi belirlendi


Ancak bazı durumlarda tip belirtmek durumundayız örneğin değer ataması yapmak istemiyorsak değişkenin türünü bildirmek zorundayız:

val age = 10 // sorun yok
val age : Int // Değer vermek istemiyorsak bu şekilde tip belirmek durumundayız

val age 
age = 10 şeklinde hata alacağız çünkü tipini belirtmedik daha önce. bunun dışında listeler ile çalışırken de içinde neleri barındıracağını belirtmemiz gerekebilir string, int gibi

Soru 5: Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

Cevap: Kotlin dilinde değişken tiplerimiz bir class'dan referans alır ve Java dilindeki gibi primitive tip değildir bu durumun avantaj ve dezavantajları vardır avantajları Class 
özelliklerini kullanabiliyor olmamız iken (.length, .toUpperCase()) dezavantajı ise bellek ve performans kaybıdır. örnek vermek gerekirse java'da int tipindeki bir değişken 
4 byte yer tutarken Kotlin dilinde 16 byte bellek kullanır. Kotlin dilinde primitive tip yoktur demek çok doğru değil çünkü Kotlin java ile uyumlu olabilmek için bazı durumlarda
bizim için derleme zamanında özel bir optimizasyon ile değişkenlerimizi primitive hale getiriyor. Bu değişken performansını arttırmak için kullanılır. Eğer değişken primitive
tipe atanabilen bir değişken ise derleme (compile) zamanında 

val number: Int = 10 // null olamayan bir tip, primitive tipe dönüştürülür
val number2: Int? = 10 // null olabilen bir tip, primitive tipe dönüştürülmez

Değişkenin bir String veri tipinden primitive dönüştürülebilen bir veri yapısına (Int, Double, Boolean vb.) ‘as’ keywordü ile cast işlemi yapılıyorsa, bu dönüşüm çalışma
zamanında (runtime) gerçekleşir. Örneğin:

val number: String = "10" // String bir tip, primitive tipe dönüştürülmez
val number2: Int = number.toInt() // String tipinden Int tipine cast işlemi, çalışma zamanında gerçekleşir

Soru 6: "Tip Güvenliği" (Type Safety) kavramını açıklayın.

Cevap: Tip güvenliği (Type Safety) kavramı, bir programlama dilinde her değişkenin belirli bir veri tipine sahip olması ve bu tipin çalışma zamanında değiştirilmemesi anlamına
gelir bu program hatalarını önlemeye ve performansı arttırmaya yardımcı olur. Kotlin Type Safety bir dildir ve bunun için iki yol vardır: 

-Statik tip belirleme
Değişken tanımlarken veri tipini açıkça belirtirsiniz. Örneğin var name : String = Barış

-Tip çıkarımı 
Değişken tanımlarken veri tipini belirtmiyoruz ancak Kotlin derleyicisi atanan değere göre veri tipini otomatik olarak çıkarır. Örneğin var name = "Ali"

Kotlin, tip güvenliğini sağlamak için bazı özellikler sunar. Bunlardan bazıları şunlardır:

Nullability: Kotlin, null değeri alabilen ve alamayan veri tiplerini ayırır. Null değeri alabilen bir veri tipi, sonuna ? işareti eklenerek tanımlanır.
Örneğin, var name: String? = null gibi. Null değeri alamayan bir veri tipi ise normal şekilde tanımlanır. Örneğin, var name: String = "Ali" gibi.
Bu şekilde, null pointer exception (NPE) adı verilen çalışma zamanı hatası önlenir.

Smart cast: Kotlin, bir değişkenin veri tipini kontrol ettikten sonra, o değişkenin tipine uygun işlemleri yapmanıza izin verir. Örneğin, var x: Any = 10 diyelim.
x değişkeni Any tipinde tanımlandığı için, herhangi bir veri tipi alabilir. Ancak, x değişkeninin Int tipinde olduğunu kontrol etmek isterseniz, if (x is Int) yazabilirsiniz.
Bu durumda, x değişkeni Int tipine otomatik olarak dönüştürülür ve Int tipine özgü işlemleri yapabilirsiniz. Örneğin, x + 5 gibi.

Soru: Bir değişkeni nullable yapmak için ne yapmalıyız?

Cevap: Bir değişkeni nullable yapmak için veri tipinin sonuna ? işareti eklemeliyiz. Örneğin var name: String? = null gibi. Bu şekilde değişkenin null değeri alabileceğini belirtiyoruz
Null değeri alamayan bir değişken ise normal şekilde tanımlanır. var name = String = "Barış". Nullable NullPointerException çalışma hatasından bizi kurtarmak için etkili bir yoldur.

Soru: "Null Güvenliği" (Null Safety) kavramını açıklayın.

Cevap: Null Güvenliği (Null Safety) bir programlama dilinde değişkenleri null(boş) değerlere sahip olma durumunu kontrol etmek ve başa çıkmak için kullanılır. Null bir değişken
veya nesnenin bellekte bulunmaması veya hiçbir şeye işaret etmemesi anlamına gelir. Bu noktada bu nesne veya değişkenin üyelerine erişmeye çalışmak NPE hatasını oluşturur
Kotlin dili null güvenliği konusunda oldukça güçlü bir dil olarak bilinmektedir. Kotlin değişkenlerin veya değerlerin null olup olmayacağını belirtmek için nullable ve non-nullable
türler arasında ayrım yapar.

Nullable değişkenler: Bir değişkenin null olması durumudur. Nullable değişkenlerinin tipi hem null hem de belirtilen türde (String, Int) olabilir bir nullable değişkeni kullanırken
null olup olmadığını kontrol etmemiz gerekmektedir. Örneğin var name : String? = null

Non-Nullable Değişkenler: Bir değişkenin null olmaması durumudur Non-Nullable değişkenlerin tipi sadece belirtilen tüden olabilir (String,Int) var name :String = Ali

Kotlin, nullable değişkenlerin değerlerini kontrol etmek ve null referans hatalarını önlemek için bazı özellikler sunar.

-Null Check: 
Bir değişkenin null olup olmadığını kontrol ederiz if(name != null)

-Safe Call (?.) bir değişkenin null olup olmadığından emin olmadan onun üyelerine erişmek için kullanılır. name?.lenght gibi (name null ise null değilse değerini döndürür)

-Elvis Operatörü(?:) Bir değişkenin null olması durumunda alternatif bir değer kullanmak için kullanılan bir operatördür. name?.lenght ?:0 gibi (null veya 0) olsun diyoruz.

-Not null Assertion Operatörü (!!): Bir değişkenin kesinlikle null olmadığını belirtmek için kullanılan bir operatördür. name!!.lenght gibi. Eğer null ise NPE patlayacaktır değilse
değerini döndürür. 
Kotlin, null güvenliği sayesinde, programlamada ortaya çıkabilecek birçok hata türünü azaltır ve kodunuzun güvenilirliğini, performansını ve okunabilirliğini artırır.

Soru: Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

Cevap: Kotlin, bir değişkene null değer atanır ve tip belirtilmezse, bu değişkenin tipini Nothing? olarak yorumlar çünkü tip çıkarımı yapamaz. Nullable ya da null olanlara any
veriliyor.

Soru: İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

Cevap: Null değişkenler bellek yönetimi açısından daha performanslıdır çünkü class olarak tutulurlar ancak nullable olmayan değişkenler daha az yer kaplar çünkü optimizasyon
ile primitive tiplere dönüştürülürler.










