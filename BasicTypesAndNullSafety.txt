val ile var arasındaki fark nedir?
* Val kullanarak oluşturduğumuz değişkenler ReadOnly 'dir, değeri tekrardan set etilemez fakat var değerlerini tekrardan set edebiliriz. Yaygın bilinenin aksine val immutable değildir. Get fonksiyonu ile değeri değiştirilebilir.


Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.
* Var kullanarak oluşturduğumuz değişkenin setter ını private yaptığımızda val değişkenleri gibi artık set edilemeyecektir.

"Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?
* Immutable kavramı bir değişkenin değerinin bir kere atandıktan sonra hiçbir şekilde değiştirilememesidir. ReadOnly ise bir değişken değerinin sadece okunabilir olduğunu, setter ı ile işlem yapılamayacağını belirtir. Val değişkeninin immutable değil de ReadOnly olmamasının sebebi getter kullanarak aldığı değerin değişmesini sağlayabildiğimizdendir. Örnek verirsek kullanıcıdan a ve b adında iki input değeri alıp result adını verdiğimiz val bir değişkenin değerini de get() { return(a+b) } yaptığımızda sonucun kullanıcının input değerlerine göre değiştiğini görürüz.


"Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?
* Type Inference oluşturduğumuz bir değişkenin türünü tanımlanmadığımız durumlarda IDE nin bu değişkeni otomatik olarak tanımlaması, çıkarım yapmasıdır. Örnek olarak val a = 1 dediğimizde veya type ını Number olarak belirtmiş olsak da IDE bunu eğer integer aralığındaysa integer olarak tanımlar. Byte ve Short type ını verseydi değer aralıkları 1 değerini kapsadığı için yine de kod çalışırdı fakat integer yaygın bir kullanıma sahip olduğu için IDE tarafından tercih edilir. Type inferenceda dikkat edilmesi gereken diğer bir konu eğer iki tane short ve byte tipinde variable ı çarparsak ve tip belirtmezsek IDE sonucun tipini bu tiplerden en geniş aralığa sahip olanı yani shortu sonucun tipi olarak belirler. Bu bir kolaylık gibi gözükse de alabileceği maksimum aralık 32,768 olan short variable ı yaptığımız çarpma işlemi sonucu bu değerin üzerine çıktığında hatalı sonuç verecektir. Diğer bir örnek 128 olan integer değerini toByte() explicit type inference ile Byte koduna çevirdiğimizde de bir hata alırız çünkü Byte ın değer aralığı -128 ile 127' dır. Bu gibi durumlarda tip belirtmek gerekir.