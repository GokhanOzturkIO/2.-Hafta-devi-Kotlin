##Temel Türler & Null Güvenliği

Answer 1:
    val: yalnızca okunabilir. Bir kere atama yaptıktan sonra tekrar bir atama gerçekleştiremeyiz.
    var: İstenen yerde atama yaptıktan sonra tekrar atamalar yapılabilir.

Answer 2:
    var değişkeninin val gibi davranabilmesi için var ın set metoduna erişim belirleyici
    ekleyebiliriz.

    örnekleyelim:
        var deneme=10           /// burada deneme normalde tekrar atama yapılabilir oluyor fakat
            private set         /// private set dediğimiz için set etme işlemi yapılamaz hale geldi.

    *Bunu neden yapmak isteriz ?
        Projelerde class içerisindeki bir değişkenin sadece kendi class metodları içerisinde set
        edilip dışarıya karşı val gibi davranarak değiştirilmesini ve kötü amaçla kullanılmasını
        önleme amacıyla, Encapsulation yapmak için kullanmak isteyebiliriz.

Answer 3:
   **Değişmez(Immutable): Ne yaparsak yapalım hiçbir şekilde değiştirilemeyen anlamına gelir.
   **Salt Okunur(Read Only): İçeriği değiştirip set edemezsin fakat içeriğini okuyabilirsin. set
    etmeden belli yöntemlerle içeriği değişebilen anlamına gelir.
   **val değişkenler immutable değildir çünkü set edemesek bile val değişkenine atadığımız kısım
    sabit değil de değeri dışarıdan alıyorsa her seferinde farklı değere sahip olabilir. Bu nedenle
    val immutable değil read-only dir.

    örnekleyelim:
        fun deneme(s1:Int,s2:Int){
            val carpim = s1*s2
            println(carpim)
        }
        üstteki fonksiyonda dışarıdan iki tane int değer alıyor. val olarak tanımlanan carpim
        değerine de iki sayının çarpımı veriliyor. Dışarıdan gelen değer her değiştiğinde carpim
        değeri de değişeceği için val immutable'dir diyemiyoruz. val read-only dir.

Answer 4:
  **Tip çıkarımı(Type inference): Bir değişkene değer ataması yaparken hangi türde olduğunu
    belirtmediğimizde, atama yaptığımız değere göre IDE'nin bu değeri otomatik olarak kendisinin
    algılayıp değişkeni en uygun veri tipine eşlemesi. En uygun için örnek olarak sayısal değerlerde
    verilen sayı int değer aralığındaysa normalde byte/short aralığında da olsa olabilecek hataları
    önleme amacı ile en uygun tipe int e eşleyecektir, int aralığından da büyük bir sayı ise bu sefer
    long olarak görüntülenecektir.
  **bir değişkene örneğin var a = null dediğimizde tipini belirtmeliyiz çünkü belirtmediğimizde IDE
    bunun Nothing tipine eşler. Unit den farklıdır. unit bir şey döner ama boştur, Nothing bir şey
    de dönmez. Daha sonradan bir değer atamak istediğimizde şöyle bir hata verecek : Bunun tipi
    Nothing ama sen int atıyorsun (gibi).

Answer 5:
    Kotlinde class gibi görünen değişken tipleri özel optimizasyon ile proje derlenirken otomatik
    olarak bytecode'a dçnüştürürken yine primitive tip olarak çeviriliyor.

    örnekleyelim:
         //KOTLIN İÇİN//                    //JAVA İÇİN//
        val a:Int=10                    int a =10;

    üstteki örnekte kotlinde Int olarak belirttiğimiz tip javaya çevrildiğinde primitive tipe
    dönüşüyor. Her derlendiği zaman IDE bunu arkaplanda çeviriyor.

Answer 6:
    Type Safety: Kod yazarken iki uyumsuz tipi birbirine atama yapmaya çalışırsak IDE bize kızıyor.
    Örneğin int bir değişkene String atamaya çalışırsak bu hata ile karşılaşırız. IDE kodu düzeltene
    kadar derlemeye izin vermez, derlemez.

