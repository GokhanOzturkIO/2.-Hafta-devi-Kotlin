/*----------------------------------------------------------------------------------------------------------------------
                                         1- Temel Türler & Null Güvenliği
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  1.1 ->  val değeri get edilebilir ama set edilemez.readOnly durumdadır.Readonly durumdadır değeri okunabilir.
       var değeri hem set ve hemde get edilebilir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  1.2 -> var keywordunu(değişkeni) val gibi kullanmak istersek setini private yapıp readonly durumuna getiririz.Peron sınıfımda
 name değişkenim olsun dışardan erişen o değeri almasını isteyebilirim ama class içinde o değeri değiştirmek isteyebilirim.
 Bunun için bu yöntemi kullanırım.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  1.3 -> -Immutable değeri hiçbir sekilde değişemez.
       -Readonly ise değeri okunabilir ama set edilemez.
       -Readonlynin nesnesi veya referansının durumu  değişebilir ama immutable  nesnesinin ve referansın değiştirmeninin
       hicbir yolu yoktur. val ise nesnesi veya referansının durumu değiştiği için readonlydir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  1.4 ->  Programcı veri türünün belirtmeden IDE'nin veri türünü anlamasıdır.Tür Bildirimi yapmamız gereken yerler ise
  null bir tip bildirdiğimizde,fonksiyon geri dönüş değerinde ve parametlerinde bildiririz.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  1.5 -> Kotlin'de, temel veri tipleri referans olarak temsil edilir; ancak derleyici, temel veri
  tiplerini optimize ederek ilkel türlere dönüştürür.(Bycode da  java koduna bakarsak primitive olarak tanımlanmıştır)
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  1.6 -> Tip Güvenliği, derleme sırasında değişkenlerin türlerinin ve atanacak değerlerin türlerinin doğrulanmasıyla
  sağlanan bir programlama kavramıdır, böylelikle tür uyumsuzlukları önlenir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  1.7 ->  var age : Int? = null  bu sekilde null bildirilir.Tür Bildirimi yapmak ve tür bildirimin sonuna "?" koymak
  zorundayız.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  1.8 -> Bir programlama dilinde, değişkenlerin veya referansların null olabileceği durumları kontrol altına alarak null
  referanslarından kaynaklanan hataları önlemeyi amaçlayan bir kavramdır.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  1.9 -> Bir programlama dilinde, değişkenlerin veya referansların null olabileceği durumları kontrol altına alarak null
  referanslarından kaynaklanan hataları önlemeyi amaçlayan bir kavramdır.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  1.10 -> Nothing tipinde tutar.Nothing sınıfı "Asla var olmayan bir değeri" temsil etmek için kulllanılır.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
1.11 -> Null olmayan değerler her zaman bir değer içerir, veri türünün boyutu kadar bellekte yer kaplar ve değerini ve
referansını stack bellekte saklar; ancak null değerler için bellekte, değerine karşılık gelen bir referans olması 
durumunda heap bellekte bir yer ayrılır.	
----------------------------------------------------------------------------------------------------------------------*/
1.12 -> İlkel veri tipleri, değerlerini ve referanslarını stack bellekte tutar, ancak null değerler referans tipleridir,
dolayısıyla değerleri heap bellekte saklanırken, referansları stack bellekte tutulur; stack bellekte null değerlerin 
referansları için yer ayrılır.	
/*----------------------------------------------------------------------------------------------------------------------
  1.13 -> !! -> Null olmasa karışma ben ona değer vericem anlamına gelir.Değer verilmesse NP fırlatır.
        ?. ->  Null gelebilir null gelirse de NP fırlatmaz.
        -> Bir bankacılık uygulamasında, kullanıcının bakiyesinin null olmamasını isteriz; aksi takdirde uygulamanın çökmesi,
 kullanıcının para miktarının hatalı şekilde görüntülenmesine ve hatta ciddi sorunlara yol açabilir. Bu tür kritik yerlerde,
 kullanıcı bakiyesinin null olmadığını doğrulamak için !! operatörünü kullanmak daha güvenli bir çözüm olabilir
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
 					                            2 - Sayılar
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    2.1 -> Number sınıfının 6 alt sınıfı vardır: Float, Double, Byte, Short, Int ve Long. Bu alt sınıflar, farklı veri
    aralıklarını temsil eder ve bellek kullanımı ile performans açısından önemlidir. Özellikle, doğru veri tipinin seçimi,
    bellek kullanımını optimize etme ve programın performansını artırma açısından kritiktir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
    2.2 ->Integer veri tiplerinde, tip çıkarımı yapılmadığında, short ve byte aralığındaki değerler varsayılan olarak int
    olarak kabul edilirken, long aralığındaki değerler long olarak kabul edilir. Kayan noktalı (floating point) veri
    tiplerinde ise, tip belirtilmediği durumda double olarak kabul edilir. Toplama işlemlerinde, toplanan veri tiplerinin
    en büyük sayının değer aralığını belirlemesi gerekmektedir. Örneğin, int ve int toplamı int değer aralığını aşsa bile
    sonuç yine int olarak kabul edilir. Bu kural, veri tiplerinin dikkatlice seçilmesi ve uygun şekilde kullanılmasını
    gerektirir.
----------------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------------
 2.3 -> Long veri tipinin "L" harfiyle bildirilmesinin sebebi, küçük "l" harfinin rakam "1" ile kolayca karıştırılabilmesidir.
 Bu nedenle, long bir değer bildirirken "L" harfi kullanılarak netlik sağlanır ve olası karışıklıkların önüne geçilir.
----------------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------------
 2.4 -> Float veri türü, tek duyarlıklı (single precision) kayan noktalı sayıları temsil eder. Bu tür, genellikle daha kısa
 bellek boyutuyla (32 bit) kullanılır ve genellikle yaklaşık 6-7 basamak doğrulukla sayıları temsil eder. Diğer bir deyişle,
 float değerler, ondalık kısımların doğruluğunu yaklaşık olarak 6-7 basamağa kadar korur.

 Double veri türü ise çift duyarlıklı (double precision) kayan noktalı sayıları temsil eder. Bu tür, daha uzun bir bellek
 boyutuyla (64 bit) kullanılır ve genellikle yaklaşık 15-16 basamak doğrulukla sayıları temsil eder. Yani, double değerler,
 ondalık kısımların doğruluğunu yaklaşık olarak 15-16 basamağa kadar korur.
----------------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------------
 2.5 ->  Ondalık ayracı "." nokta ile temsil edilir.
        val piDouble = 3.14 // Double
        val piFloat  = 3.14f // Float
----------------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------------
 2.6 -> Float veri türü yaklaşık olarak 6-7 basamağa kadar doğrulukla ondalık işlemler yaparken, Double veri türü yaklaşık
 olarak 15-16 basamağa kadar doğrulukla ondalık işlemler yapabilir. Float, daha az bellek kullanır ve daha düşük hassasiyetli
 işlemler için kullanılırken, Double daha fazla bellek kullanır ve daha yüksek hassasiyetli işlemler için kullanılır.
----------------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------------
 2.7 -> val decimal = 123 //Decimal
    	val hexadecimals = 0x00 // Hexadecimal
    	val binaries = 0b00001011 // Binary
	Bu şekilde tanımlanır.
----------------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------------
 2.8 -> int octalNumber = 0123 javada tanımı bu şekildedir.Kotlinde sayının başına sıfır koyulmaz ve hata alırız.
	(Unsupported [literal prefixes and suffixes]. bu hatayı alırız.)
----------------------------------------------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------------------------/
 2.9 -> Kotlin'de, ondalık sayıların geleneksel gösterimi desteklenir. Bu gösterim şu şekildedir:
        Double türü için, ondalık sayılar ve bilimsel gösterim (exponential notation) kullanılabilir. Örneğin, 123.5 veya 123.5e10.
        Float türü için, sayılar 'f' veya 'F' etiketi ile işaretlenir. Örneğin, 123.5f veya 123.5F.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------------*/
 2.10 -> Kotlin'de sayısal değerlerin daha kolay okunabilmesi için alt çizgi (underscore) kullanılabilir. Ancak, alt çizgiler
sadece sayının daha okunabilir olmasını sağlar ve değerlerin kendisini etkilemez. Yani, alt çizgiler sadece okunabilirlik
için kullanılır ve değeri belirlemez. Dolayısıyla, bir sayıyı print ettiğinizde alt çizgiler kaldırılır ve sadece sayının
değeri görüntülenir.
-------------------------------------------------------------------------------------------------------------------------------*/
 2.11 -> "==" operatörü, değerleri karşılaştırırken kullanılırken, "===" operatörü referansları karşılaştırmak için kullanılır.
 Bu, değerlerin içeriğini kontrol etmek için "==", ancak bellek adreslerini doğrudan karşılaştırmak için "===", kullanırız.
 Bu şekilde, bir nesnenin aynı bellek konumunu gösterip göstermediğini kontrol edebiliriz. Bu, veri işlemleri sırasında
 doğru sonuçları elde etmek için önemlidir.
---------------------------------------------------------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------------------------------------------------------*/
 2.12 -> JVM, -128 ile 127 arasındaki Integer değerlerini bellek optimizasyonu yaparak önbelleğe alır. Bu nedenle,
 aynı aralıktaki byte değerler, bellekte aynı nesneyi işaret eder
----------------------------------------------------------------------------------------------------------------------------
/*-------------------------------------------------------------------------------------------------------------------------*/
 2.13 -> Kotlin'de kullanılan matematiksel operatörler arasında toplama, çıkarma, çarpma, bölme, mod alma, artırma, azaltma,
 üs alma, karekök alma, mutlak değer alma, trigonometrik ve logaritmik fonksiyonlar bulunur.
-------------------------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------------------*/
 2.14 -> Kotlin'de sayısal değerler için kullanılan karşılaştırma operatörleri şunlardır: == (eşitlik), != (eşit değil),
  > (büyüktür), < (küçüktür), >= (büyük eşittir) ve <= (küçük eşittir).
-------------------------------------------------------------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------------------------------------------------------*/
 2.15 -> Bit düzeyinde operatörler, verilerin ikili temsilini kullanarak bellek manipülasyonu, veri sıkıştırma, matematiksel
 işlemler ve şifreleme gibi düşük seviyeli işlemleri gerçekleştirmek için kullanılır. Bu operatörler arasında AND (&), OR (|),
 XOR (^), NOT (~), Left Shift (<<) ve Right Shift (>>) bulunur.

 val a = 0b1010
 val b = 0b1100

 val andResult = a and b
 val orResult = a or b
 val xorResult = a xor b
 val notResult = a.inv()
 val leftShiftResult = a shl 2
 val rightShiftResult = a shr 2

 println(andResult) // Çıktı: 8 (0b1000)
 println(orResult) // Çıktı: 14 (0b1110)
 println(xorResult) // Çıktı: 6 (0b110)
 println(notResult) // Çıktı: -11 (0b11111111111111111111111111110101)
 println(leftShiftResult) // Çıktı: 40 (0b101000)
 println(rightShiftResult) // Çıktı: 2 (0b10)

-------------------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  1.16 -> Kotlin'de, tam sayılar için işlemlerinde BigInteger türü kullanılırken, ondalıklı sayılar için BigDecimal türü tercih edilir.
Bu ek türler, sınırsız büyüklükte sayılarla çalışmayı sağlar ve yüksek hassasiyet gerektiren hesaplamalarda kullanılır.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  1.16 -> Double ve Float veri tiplerindeki yuvarlama davranışı, IEEE 754 standardına göre belirlenir ve varsayılan olarak yakınsama
kuralına göre gerçekleşir. Ancak, bu davranışı değiştirmek için özel yuvarlama stratejileri kullanılabilir. Kotlin'de,
Math sınıfı altında yer alan round(), ceil() ve floor() gibi fonksiyonlarla yuvarlama işlemleri gerçekleştirilebilir.
Bu yöntemlerle, sayılar belirli bir hassasiyete veya istenen yuvarlama davranışına göre düzenlenebilir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
 					                            3 - İşaretsiz Sayılar
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  3.1 -> UByte boyutu 8 bit olup  değer aralığı 0 ile 255
 	    -> Ushort  boyutu 16 bit olup  aralığı 0 ile 65,535 arasındadır
 	    ->  UInt, 32 bit boyutunda olup değer aralığı 0 ile 4,294,967,295 (2^32 - 1) arasındadır.
        -> ULong ise 64 bit boyutundadır ve değer aralığı 0 ile 18,446,744,073,709,551,615 (2^64 - 1) arasındadı.
        -> Unsigned  veri tipleri sadece pozitif sayıları kapsamaktadır.

----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  3.2 -> İşaretsiz diziler, işaretsiz tamsayıları (UByte, UShort, UInt, ULong) temsil etmek için özel olarak tasarlanmış
    sınıfları kullanır. Bu özellik deneysel olduğu için @ExperimentalUnsignedTypes API ile desteklenir.
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  3.3 -> İşaretsiz değişkenler, genellikle "u" veya "U" harfi ile gösterilir
----------------------------------------------------------------------------------------------------------------------*/
/*----------------------------------------------------------------------------------------------------------------------
  3.4 ->  val a1 = 42u // Sabit 42, UInt türündedir çünkü beklenen bir tür belirtilmedi ve 42 UInt aralığına sığar.
      -> val a2 = 0xFFFF_FFFF_FFFFu // Sabit 0xFFFF_FFFF_FFFF, UInt aralığını aştığı için derleyici onu ULong olarak yorumlar.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
  3.5 ->   val a1 : ULong = 42u 
    	   val a = 1UL
	 Bu şekilde Long tipi bildirilir.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
  3.6 ->  İşaretsiz değişkenler, genellikle sadece pozitif tamsayıları veya sıfırı temsil etmek için kullanılır. Ayrıca, 
belirli bir veri aralığında sınırlı olan değerlerde ve bellek kullanımını azaltmak veya verimliliği artırmak için de 
tercih edilirler. Bunun yanı sıra, harici sistemlerle veya donanımlarla uyumluluk sağlamak amacıyla da kullanılabilirler.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
  3.7 -> İşaretsiz tamsayılar, negatif değerler gerektiğinde kullanılmaz. İşaretli tamsayılar taşmaları algılayabilir ve hata 
koşullarını belirtir. İşaretsiz tamsayılar, işaretli tamsayıların alt türü değildir, bu nedenle negatif tamsayıları 
temsil edemezler
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
  3.9 -> Type   	bits     Min Value     Max Value 
	 UByte	         8	   0		  255	
	 UShort		 16	   0		65,535
	 UInt		 32        0	        4,294,967,295 (232 - 1)
	 ULong		 64	   0 		18,446,744,073,709,551,615 (264 - 1)
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
  3.10 -> İşaretsiz tamsayı dizileri, kutulama gerektirmeyen Array sınıfına benzer bir API sağlar. Ancak, bu özellik henüz kararlı 
değildir ve kullanırken @ExperimentalUnsignedTypes açıklamasını kullanarak onay vermeniz gerekir. Aralıklar ve ilerlemeler 
UIntRange, UIntProgression, ULongRange ve ULongProgression sınıfları tarafından UInt ve ULong için desteklenir. İşaretsiz 
tamsayı türleriyle birlikte, bu sınıflar kararlıdır.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 							4. Tür Dönüşümü
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.1  -> İs operatörünü  nesnenin belirli bir tipe uygun olup olmadıgı kontrol etmek için kullanılır.!is operatorü ise is tam
tersidir.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.2 -> "Akıllı Dönüşüm" (Smart Cast), Kotlin programlama dilinde tür güvenliğini sağlamak için kullanılan bir özelliktir.
    val a: Any = "Yunus Emre"
    if (a !is String)
        return
    println(a.length) // String otamatik olarak dönüşmüs ise a propertysinin uzunluğu yazdırır.Dönüsmemiş ise boş döner
 
 var x: Any = 10
    when (x) {
        is Int -> print(x + 1)
        is String -> print(x.length + 1)
        is IntArray -> print(x.sum())
    }
    // x burda 11 olarak yazdırır.

----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.3 -> Kotlin'de güvensiz dönüşüm, infix operatörü olan as ile gerçekleştirilir.Özel istisnaları önlemek için güvenli (nullable) 
dönüşüm operatörü olan as? kullanılır. Bu operatör, başarısız olduğunda null değeri döndürür.	
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.4 -> Örtük tip genişletme, bir veri türünün daha büyük bir veri türüne otomatik olarak dönüştürülmesini ifade eder. Ancak, 
Kotlin'de bu tür otomatik genişletmeler yapılamaz. Bunun yerine, genişletme işlemleri açık dönüşüm operatörleri kullanılarak 
yapılmalıdır. Bu, veri türlerinin genişletilmesini açıkça belirtmek ve potansiyel veri kaybı riskini azaltmak için tercih 
edilen bir yaklaşımdır.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.5 ->    val b: Byte = 1
    	   val i: Int = b
    	   print(b == i)
 -> (implicit widening conversions) izin verilmediği anlamına gelir. Bu hata, bir veri türünün otomatik olarak diğer bir 
türe dönüştürülmesine izin verilmemesi durumunda oluşur.

Kotlin'de, eğer bir veri türünü başka bir türe dönüştürmek istiyorsanız, bunu açıkça belirtmeniz gerekir. Bu, "explicit type 
conversion" olarak adlandırılır. Yani, veri türlerini birbirine dönüştürürken, Kotlin dilinde açık dönüşüm operatörlerini 
kullanmanız gerekir. Bu yaklaşım, potansiyel hata riskini azaltır ve kodun daha güvenli olmasını sağlar.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.6 ->    val b: Byte = 1
   	 val i: Int = b.toInt()
   	 print(b == i)

 -> Bu kodda hatanın sebebi, Byte ve Int türlerinin doğrudan karşılaştırılamamasıdır. Bu nedenle, b propertysini bir Int'e dönüştürseniz 
bile, hala b propertysinin orijinal veri türü Byte olarak kalır. Bu nedenle, b == i ifadesinde hala bir hata alırsınız. Bu hatayı 
çözmek için, b'yi açıkça bir Int türüne dönüştürmeniz gerekmektedir.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.7 ->  toByte(): Bir değeri Byte türüne dönüştürmek için kullanılır.
	 toShort(): Bir değeri Short türüne dönüştürmek için kullanılır.
	 toInt(): Bir değeri Int türüne dönüştürmek için kullanılır.
	 toLong(): Bir değeri Long türüne dönüştürmek için kullanılır.
	 toFloat(): Bir değeri Float türüne dönüştürmek için kullanılır.
	 toDouble(): Bir değeri Double türüne dönüştürmek için kullanılır.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.8 ->  toByte(): Bir değeri Byte türüne dönüştürmek için kullanılır.
	 toShort(): Bir değeri Short türüne dönüştürmek için kullanılır.
	 toInt(): Bir değeri Int türüne dönüştürmek için kullanılır.
	 toLong(): Bir değeri Long türüne dönüştürmek için kullanılır.
	 toFloat(): Bir değeri Float türüne dönüştürmek için kullanılır.
	 toDouble(): Bir değeri Double türüne dönüştürmek için kullanılır.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.10 -> val result = Int.MAX_VALUE + Int.MAX_VALUE bu deyiminin tipi int olur.iki değerde int olduğu için yine int döner.
intin değerini aştıktan sonra en küçük int değer aralıgından başlar.B		
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.11 ->    val x = 5 / 2
   	   println(x == 2)
-> Kotlin, tür çıkarımı (type inference) özelliğine sahip olduğundan, 5 / 2 işlemi sonucunu varsayılan olarak Int olarak algılar. 
Bu durumda, işlemin sonucu olan 2 değeri, Int türüne sahip olur.Dolayısıyla, println(x == 2) ifadesi true olarak değerlendirilir, 
çünkü x değişkeninin değeri 2'dir.Ancak, bu işlemin tam bölme sonucunun 2.5 olduğunu dikkate almak önemlidir. Eğer kesirli sonuç elde 
etmek isteniyorsa, işlemin sonucunu Double veya başka bir ondalık tür olarak belirtmek gerekir.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.12 ->  val x = 5L / 2 ;println(x == 2L) true olarak print eder.Cünkü büyük sayının tipini aldğı için ve long veri tipi
tam sayı olduğu kesirli işlem yapamaz.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.13 -> val x = 5 / 2.toDouble() ;  println(x == 2.5) işlemin sonuuc true döner.Explicit Type Conversion yaptıgı için deyimin
tipi double olur.
----------------------------------------------------------------------------------------------------------------------*
/*----------------------------------------------------------------------------------------------------------------------
 4.14 -> TypeCastException, Kotlin'de tür dönüşümü sırasında oluşabilecek bir istisnadır. Bu istisnayı ele almak için üç ana yöntem vardır:

1.Try-Catch Blokları: try-catch blokları kullanarak, dönüşüm işlemi sırasında oluşabilecek istisnayı yakalayabiliriz. 
Bu şekilde, dönüşüm başarısız olduğunda programın çökmesini önleyebiliriz.
2.As ve Is Anahtar Kelimeleri: as ve is anahtar kelimeleriyle tür kontrolü yaparak, dönüşüm işleminden önce değerin beklenen türde olup olmadığını kontrol edebiliriz. 
Bu sayede, dönüşüm başarısız olmadan önce kontrol yapabiliriz.

----------------------------------------------------------------------------------------------------------------------*

