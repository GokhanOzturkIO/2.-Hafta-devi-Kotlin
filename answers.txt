1) val ile tanimlanan degiskenler degeri sonradan belirlenemyen degiskenler. var ile olanlar degeri sonradan degisen degiskenlerdir. val vara nisbeten daha yavasdir, ancaq bu fark yok denecek kadar azdir. Bunun sebebi val icinde bir kosul olmasidir. ANcak multithreading olan bir uygulamada val daha avantajlidir, cunki var ile tanimlanan degisken deyise bileceyi icin ide geri donub bu deyiskenin degerinin ne oldugunu kontrol eder, valda bu durum yoktur cunki degeri sonradan degisemez.

2) var degiskeninin set fonsiyonunu private yapa biliriz. ornek:
var name = "Ziya"
    private set

Bu kullanim class icinde tanimlanmis degiskenler icinde gecerlidir. Degiskenin degerini class icinde degise bilmesini ancak class disinda degismemesini istiyorsak bunu kullana biliriz.

3) readonly degeri sadece okuna bilen ama set edilemeyen demekti. Immutable ise ilk basdaki degeri hic bir sekilde dgismeyen degiskendir. val readonlydir cunku val degiskenine return edilen bir deger degise bilir. Orneyin val degiskenine toplama sonucunu return ediyoruzdur, bu zaman topladigimiz degerleri degisirsek val degiskeninin degeride degismis olucak. Ancak immutbale degiskende bu soz konusu degil.

4) Kotlinde bir degisken tanimlarken onun tipini belirtmeye gerek yoktur cunki, ide degiskene verdigimiz degere bakarak onun hangi tipde oldugunu anlar. Mesela:

val name: String = "Selam" burada int yazmamiz gerekli degildir cunki Selam degerinin String tipinde oldunu ide kendi anlayacakdir. 
val name = "Selam" yukardaki kullanim yerine bunu yazmak daha iyi olur, ancak yuarideki kullanim yanlis degildir, buna ragmen oyle yapilmasi zorunlu durumlar haric onerilmez. Buna type inference denir.

5) Hayir cunki o degiskenler arka planda byte codeye cevrilirken primitiv tipe karsilik gelir.

6) Type safety programlama dilinin tur hatalarini azaltmak icin kullanilan bir ozelliktir. Mesela nullability bir type safety ifadesidir. 