1) val ile tanimlanan degiskenler degeri sonradan belirlenemyen degiskenler. var ile olanlar degeri sonradan degisen degiskenlerdir. val vara nisbeten daha yavasdir, ancaq bu fark yok denecek kadar azdir. Bunun sebebi val icinde bir kosul olmasidir. ANcak multithreading olan bir uygulamada val daha avantajlidir, cunki var ile tanimlanan degisken deyise bileceyi icin ide geri donub bu deyiskenin degerinin ne oldugunu kontrol eder, valda bu durum yoktur cunki degeri sonradan degisemez.

2) var degiskeninin set fonsiyonunu private yapa biliriz. ornek:
var name = "Ziya"
    private set

Bu kullanim class icinde tanimlanmis degiskenler icinde gecerlidir. Degiskenin degerini class icinde degise bilmesini ancak class disinda degismemesini istiyorsak bunu kullana biliriz.

3) readonly degeri sadece okuna bilen ama set edilemeyen demekti. Immutable ise ilk basdaki degeri hic bir sekilde dgismeyen degiskendir. val readonlydir cunku val degiskenine return edilen bir deger degise bilir. Orneyin val degiskenine toplama sonucunu return ediyoruzdur, bu zaman topladigimiz degerleri degisirsek val degiskeninin degeride degismis olucak. Ancak immutbale degiskende bu soz konusu degil.

4) Kotlinde bir degisken tanimlarken onun tipini belirtmeye gerek yoktur cunki, ide degiskene verdigimiz degere bakarak onun hangi tipde oldugunu anlar. Mesela:

val name: String = "Selam" burada int yazmamiz gerekli degildir cunki Selam degerinin String tipinde oldunu ide kendi anlayacakdir. 
val name = "Selam" yukardaki kullanim yerine bunu yazmak daha iyi olur, ancak yuarideki kullanim yanlis degildir, buna ragmen oyle yapilmasi zorunlu durumlar haric onerilmez. Buna type inference denir.

5) Hayir cunki o degiskenler arka planda byte codeye cevrilirken primitiv tipe karsilik gelir.

6) Type safety programlama dilinin tur hatalarini azaltmak icin kullanilan bir ozelliktir. Mesela nullability bir type safety ifadesidir. 

7) degiskenin turunun sonuna ? isareti koymaliyiz. Mesela

val num: Int? = null

8) NUll guvenligi bir degiskenin null olup olmadigini bildirmek icin son derece onemlidir, null degeri donduren bir degisken kritik noktalarda olursa uygulamayi cokerte bilir. Mesela serverden bekledigimiz deger gelmiyorsa biz bunu null guvenligi ile kontrol ede bilir ve ona gore bir islem yapa biliriz.

9) null degiskenin tipi belirlenmezse bu zaman ide onu Nothing tipinde kabul eder. null tipinde olan deger icin type iference calismaz.

10) nullable olmayan bir deyer bellekte sabit yer tutar. nullable olan deger icin bellekde ek yer ayrilir bu nullable degerin sonradan degismesi ve null olmayan bir deger almasi ihtimaline karsi yapilir. Bu yuzden nullable deger daha maliyetlidir.

11)Evet, null değer almış bir değişken, bellekte yer kaplamaz. Nullable bir değişken, değere sahip olabilir veya null olabilir. Bir değişken null olduğunda, bu, bellekte herhangi bir değer içermediği anlamına gelir ve dolayısıyla bellekte yer kaplamaz. 

Sayilar:

12) 6 esas number sinifi mevcuttur. BUnlar byte, short, int, long, float, double. Deger araliklari onemlidir, cunki yazdigmiz sayinin hangi number tipinde oldugunu bu araliklar belirler. Sayinin istdigimiz araliga dahil olup olmadigina dikkat etmeliyiz, cunki eger sayi belirlenmis araligin disindaysa bu bir takim sorunlara yol aca bilir.

13) Esitligin sag tarafindaki deyere gore tip cikarimi yapilir.

14) Cunki kucuk l-in yazlimi 1-e benzemektedir ve bu kafa karikligina yol aca bilir.

15) BUnlar kesirli sayilari temsil eden formatlari ifade eder. Single Precision float turuyle, Double precision double turuyle temsil edilir.

16) nokta ve virgul kullanilir. BUnlarin hangisinin kullanildigi ulkeden ulkeye degismektedir.

17) Float 6-7 basmaga kadar, double ise 15-16 basamaga kadar islem yapa bilir. Bu sinir asildiginda yuvarlama hatasi olur. Daha yuksek hassasiyete ve daha yuksek bellek araligina ihtiyac varsa double, daha kucuyune ihtiyac varsa float kullanilir.

18) Asagidaki gibi tanimlanir
val decimalNumber: Int = 10
val decimalNumber: Double = 3.14

val hexadedecimalNumber: Int = 0x1A
val hexadedecimalNumber: Long = 0xABCD1234

val binaryNumber: Int = 0b1010
val binaryNumber: Long = 0b1010101001

19) Hayir tanimlanamaz Kotlin sekizlik degiskenler desteklenmiyor

20) "Geleneksel Notasyon" bir sayının standart ondalık gösterimini ifade eder. Geleneksel notasyon, genellikle günlük yaşamda kullandığımız sayıların temsili şeklidir. Örneğin, "123" veya "-45.678" gibi sayılar geleneksel notasyonla gösterilir.

21) Alt cizgi(underscore) buyuk sayilari daha anlasilir sekilde gormemize yardimci olur. Mesela:
val num = 1_000_000
Kotlin 1_000_000 deyerini 1000000 gibi yorumlar. 

22) == ile degiskenlerin degerlerini karsilastiriyoruz.

23) === ile dgiskenlerin nereye referans verdigini karsilastiriyoruz. Yalniz byte araligina dusen ve nullable olan degiskenler farkli degisken olsa bile ayni memory alanlarina isaret eder. Byte araliginin disinda ise farkli memory alanlarina isret eder