1- `val` ile `var` arasındaki fark nedir?
	-val ile var arasındaki temel fark şudur: val anahtar kelimesi ile oluşturduğumuz bir değişkenin ilk atamasını yaptıktan
	sonra bir daha atama işlemi ile değişkenin değerini değiştiremeyiz. Var anahtar kelimesinde ise bu durum tam tersi olup birden fazla kez
	değişkenin değerini değiştirebiliriz.
	-Val ile Var arasında performans olarak çok az bir fark vardır. Val anahtar kelimesi arka planda, değişkenin ilk atamasının
	yapılıp yapılmadığına dair bir kontrol yapıtğı için ço az daha yavaştır. Akademik olarak Var daha hızlıdır ama günlük hayatta ve
	mutli-tread işlemlerde Val daha hızlıdır.
	-Val read-only'dir immutable değildir. Çünkü bir class'ın içindeki Val değişkenin değerini get metodu ile istediğimiz 
	şekilde değiştirebilip geri döndürebiliriz.
2- Bir `var` değişkeni `val` gibi davranmasını nasıl sağlayabiliriz `val` kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.
	-Var değişkenin set metodunu private yaparsak onu Val'a çevirmiş oluruz. 
	-Private set'i olan bir değikenin değerini private setter'ını çağıran bir public metod ile değiştirebiliriz. Sadece bu private setter'a ulaşabilen bir metod veye başka bir 
	şey ile bu değişkenin değerini istediğimiz gibi değiştirebilmek için kullanılabilir.
3- "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. `val` değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?
	-Immutable ve ReadOnly değişkenlerin her ikisi de ilk değer atamasından sonra başka bir değer atanmaz. Ama read-only değişkenin değeri class içerisindeki getter'lar ile değiştirilebilir.
	-Val read-only'dir immutable değildir. Çünkü bir class'ın içindeki Val değişkenin değerini get metodu ile istediğimiz 
	şekilde değiştirebilip geri döndürebiliriz. 
4- "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?
	-Bir değişkeni tipini belirtmeden oluşturduğumuz zamanlarda Kotlinin bu değişkenin tipini otomatik olarak algılamasıdır.
	-Bazen karışık kod yapısı olduğunda Kotlin tip çıkarımını yapamaz veya doğru yapmaz. Bu durumda ise hata meydana gelir.
	 val number = if (condition) 42 else 3.14 // Error: Cannot infer the type
	-Overload metodlarla uğraşırken tipleri açık bir şekilde belirtmek lazımdır. 
	-kompleks lampda fonksiyonlarında tipleri açık bir şekilde belirtmek gerekebilir.
5- Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?
	-Kotlinde primitive'ler class gibi gözükselerde özel optimizasyonlar ile primitive'e dönüşür. Byte koda çevrilirken primitive
	çevrilirler. Bu bize class yapısını bir çok özelliğini kazandırken primitive kadar alan kaplamasını sağlar.
6- "Tip Güvenliği" (Type Safety) kavramını açıklayın.
	-Tip güvenliği dilin compile zamanında herhangi bir hata çıkmaması için zorunlu olarak bazı kuralları uygulaması. 
	-Kotlin dili static olarak yazılmıştır yani her değişkenin tipi compile zamanında biliniyor.
	-Kotlinde null safety vardır. Bu sayede verilerin null olarak gelip çalışma zamanında ve derleme zamanında herhangibir sorun çıkamasını 
	engeller.
	-Diğer olarak Type inference, smart cast ve type check ve cast vardır.
7- Bir değişkeni nullable yapmak için ne yapmalıyız?
	-val nullableString: String? = null kodundaki gibi tipin önüne ? koyarak.
	-Val number = null şekilde bir değken tanımladığımızda bu değişkenin tipi Nothing olur.
8- "Null Güvenliği" (Null Safety) kavramını açıklayın.
	-Kotlin dilinde null safety vardır bu sayede null pointer exeption hatasından dolayı uygulamanın çökmesi ve
	başka olayların olması engellenir.
	-? işareti ile bir değişkenin null olabileceğini işaretleriz.
	-Safe calls(?.) ile propertylere erişirken veya metodları çağorırken hata meydana gelmesini engelleriz. 
	-Elvis operatörü ile de bir değerin boş gelmesi durumunda default olarak dönülecek değeri verebiliriz.
	-!! işaretini ise bir değişkenin hiç bir zaman null olmayacağı zamanlarda kullanabiliriz. Bu sayede Kotlin bu değişkenin 
	null olup olmadığına bakmayacak ve daha performanslı olacak.,
	
	
	


	

	
	

	
	
