1. Temel Türler & Null Güvenliği

1.1 val ile var arasındaki fark nedir?

- val'a bir kez değer atanır, yeniden atanamaz. var'a sonradan değer atanabilir.
- val read-only, var mutable değişkendir.
- Değişken oluştururken önce val ile oluşturup sonra gerekirse var'a çevirmek best practise olarak kabul edilebilir.

1.2 Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

- var değişkenin set'i private yapılırsa val gibi davranır.
- var değişkenin değeri Class'ın dışından değiştirilemesin ancak Class'ın içinden değiştirilebilsin isteniyorsa bu yöntem kullanılabilir.

1.3 "Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

- Read-only: İlk değer atamasından sonra tekrar değer atanamaz.
- Immutable: Değişkenin/Nesnenin durumu asla ilk değerden farklı olamaz.
- val read-only'dir, immutable değil. Bunun açıklaması bir örnekle verilecek olursa, aşağıdaki kodda availableSpace'in değeri her seferinde farklı sonuç üretebilir:

val availableSpace: Int
	get() {
		return (width * height * length) - usedSpace
	}

1.4 "Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

- Type Inference bir değişken tipinin eşitliğin sağındaki değere göre atanması demektir. Örneğin val age = 34 kodunda age değişkenine değer atandığı için Kotlin değişkenin hangi tipte olduğunu anlar, age'in değişken tipi Int olarak belirlenir.
- Bazı durumlarda tip belirtmek kesin olarak gereklidir. Sayısal değerler için; değişkene girilen değer Int aralığı içerisindeyse Int set edilir (Byte ve Short aralığında olsa bile). Int'in üstünde bir değer ise Long set edilir. Örneğin val longNumber = 1586L kodunda değişkenin Long olması istenirse sonuna L konulur yoksa 1586 sayısı Int aralığında olduğundan değişkene Int atanır.

1.5 Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

- Kotlin'de primitif tipler Class olarak bulunsalar bile kodlar bytecode'a çevrilirken yapılan optimizasyonlarla Java'daki gerçek primitif tiplere dönüştürülürler.

1.6 "Tip Güvenliği" (Type Safety) kavramını açıklayın.

- Değişkenin tipiyle değişkene atanan değerin tipinin farklı olması durumunda hata alınması tip güvenliği sayesindedir. Değişkene istenilen tipin dışında bir tipte değer atanmasının önüne geçer.

1.7 Bir değişkeni nullable yapmak için ne yapmalıyız?

- Bir değişkene null değer ataması yapabilmek için değişken tipinin sonuna soru işareti (?) konulur. Örneğin: val name: String? = null

1.8 "Null Güvenliği" (Null Safety) kavramını açıklayın.

- Nullable olmayan değişkene null atanırsa hata alınır, bu null güvenliği sayesinde gerçekleşir. Örneğin val name: String = null kodu çalışmaz. "Null can not be a value of a non-null type String" hatası alınır.

1.9 Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

- Bir değişkene null değer atanır ve tip belirtilmezse, IDE tip çıkarımı yaparken bu değişkenin değerini Nothing? olarak işaretler. Örneğin val number = null kodu aslında val number: Nothing? = null koduna denktir.
