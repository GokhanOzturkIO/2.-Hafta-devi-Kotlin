------------- Temel Türler & Null Güvenliği -------------

1 - val değişkenler farklı senaryolara göre ya read-only ya da immutable olabilir. var değişkenler ise mutable'dır, yani değeri sonradan değiştirilebilir. Arasındaki fark temel olarak budur. Performans açısından kıyaslayacak olursak, yine farklı bakış açılarıyla farklı sonuçlar elde ederiz. Val bir property'nin setter fonksiyonu olmadığı için doğrudan atama yapılamıyor. Atama yaparken threadlerden yararlanacağımızı düşünecek olursak bu threadlerin maaliyeti "var" için yapılacak kullanım kadar fazla değildir. var bir property'e değer atarken hangi thread bu işlemi yapıyor ve diğer threadlerin bu değişikliği takip etmesi gibi durumları düşünmeliyiz. Bu açıdan val daha performanslıdır. Fakat başka bir bakış açısıyla şunu da söyleyebiliriz: val propertylerde tekrar değer ataması olmadığı için burada bir if case'i varmış gibi düşünebiliriz. Sürekli kontrol sağlanarak değer atanıp atanmadığını düşünecek olursak val burada daha az performanslı olur. var propertyler için böyle bir kontrol olmadığını düşünebiliriz.

2 - var bir property'nin val gibi davranması için setter fonksiyonunu private yapabiliriz. Bu şekilde dışarıdan bu property'e değer atanamaz. Bunu neden yapmak isteyebiliriz? Tanımlanan bir property sadece o sınıf içinde değiştirilebilir olsun, dışarıdan değiştirilemez olsun istiyorsak kullanabiliriz. Örneğin mutableLiveData yapısını bu şekilde kullanabiliriz, sadece view model içinden değiştirip UI'da erişemeyiz. Örnek kod:

fun main() {
    val user = User()
    user.name = "" // Error! (Cannot assign to 'name': the setter is private in 'User')
}

class User() {
    var name: String = "Omer"
        private set

    fun printName() {
        name = "Ahmet"
    }
}

3 - Immutable, değeri sonradan değiştirilemeyen veya atama yapılamayan kavramına denk gelir. Read-only ise değişkene bir atama yapıldıktan sonra tekrar atama yapılamadığı anlamına gelir. Peki val hangisidir? val için senaryolara göre farklı cevapları vardır. Bir class içinde val ile birlikte tanımlanan property, read onlydir. Immutable diyemeyiz çünkü getter fonksiyonu içinde değer ataması yapabiliriz. Eğer bu değer atamaları farklı propertyler olursa, val değerin değişkeni de doğrudan değişmiş oluyor. Fakat genel olarak val propertyler için read only'dir diyebiliriz. Hemen örnek verelim:

fun main() {
    val car = Car()
    car.printCarName()
}

class Car() {
    private var varCarName = "Audi"
    private val valCarName: String
        get() {
            return varCarName
        }

    fun printCarName() {
        varCarName = "BMW"
        println(valCarName) // BMW
        varCarName = "Mercedes"
        println(valCarName) // Mercedes
    }
}

Buradaki ilk çıktı BMW ikincisi ise Mercedes oluyor. Görüldüğü üzere sınıf içerisinde tanımlanan val property'nin değerini değiştirebiliyoruz. Immutable diyebilmemiz için getter fonksiyonunu değiştirememiz gerekiyor. Bunu yapmanın yolu da bu val değişkenleri bir fonksiyon scope'u içinde tanımlamaktır. Bu şekilde arka planda getter ve setter fonksiyonları oluşmayacak ve gerçekten immutable olacaktır.

4 -> Type inference (tip çıkarımı), değişkenlerin tiplerinin otomatik veya bizim yazmamızla belirlenmesidir. Eğer değişkenin değerini verirsek doğrudan verirsek burada otomatik bir tip çıkarımı olur. Onun hangi tip bir değişken olduğunu belirtmemize gerek yoktur. Lokal bir değişkenin başlangıç değerini vermeden tanımlayabilir fakat bu tanımlama sırasında değişkenin tipini de kesinlikle yazmalıyız.

class Car {
    // val carName : String // Başlangıç değeri olmadan sınıf değişkeni tanımlanamıyor.
    val carName : String = "Audi" // Explicit Type Inference
    val carName2 = "Audi" // Implicit Type Inference
    
    fun printCarName() {
        val carName: String // başlangıç değeri olmadan lokal bir değişken tanımlanabiliyor.
    }
}

5 -> Hayır, özel optimazsyonlar ile primitive performansını yakayabiliriz. Örneğin Int, Java'daki int tipine denk gelirken Int?, Integer tipine karşılık gelir. Bu şekilde primitive - referans tip ayrımı yapılabiliyor.

6 -> Tip güvenliği, bir değişken hangi tipte tanımlandıysan o tipteki değişkenleri alabilmesidir. Diğer tipteki değişkenleri alamaz.

val myStr = "Omer"
myStr = 5 // exception (String ifadeye int veremeyiz)

7 -> Nullable yapabilmek için ? ifadesini tipin sonuna koyabiliriz. Örneğin: String -> String? bu şekilde nullable yapmış oluyoruz.

8 -> Nullable bir değişkeni direkt olarak kullanamıyoruz. Bu da bize null safety kavramını getiriyor. Nullable bir değişkeni kullanabilmek için ? ve !! ifadelerine yoğunlaşabiliriz. Eğer bir ifade null değil ise bu işlem yap demek istersek ? ifadesini, eğer bu ifade kesinlikle null değil ben eminim, kullan bunu demek istersek !! operatörünü kullanabiliriz. Fakat değer null ise exception oluşur.

fun main() {
    val myStr: String? = null
    println(myStr?.length) // null döner
    // println(myStr!!.length) // exception oluşur.
}

9 -> Nothing tipini alır. Nothing, hiçbir değeri olmayan bir şeyi temsil etmek için kullanılır. Burada tipini bilmediğimiz için Nothing? olarak işaretlenir.

10 -> Primitive tiplerin değişken adı ve değişkenin değeri bellekte stack alanında saklanır. Referans tiplerin değişken adı stackte, değeri ise heap alanında saklanır. Stack alanına erişim daha hızlı olduğu için primitive tipler daha performanslı çalışır.

11 -> Yer kaplamaz diyemeyiz. Değişkenin adı stackte yine yer kaplar fakat değeri olmadığı için (null) heap alanında yer tutmaz. Sonuç olarak stackte yer tuttuğu için yine de yer kaplar diyebiliriz.

12 -> 8.cevapta verildi. !! ve ? kullanımıyla ilgili...

------------- Sayılar -------------

1 -> Byte, Short, Int, Long, Float ve Double olmak üzere 6 tane sınıf Number sınıfını miras alır. Number tipinde bir değişkene değer verdiğimizde eğer int aralığındaysa default olarak int tipine dönüşür. Eğer noktalı sayı yazarsak default olarak double tipini alır. Bunları toByte(), toShort() gibi fonksiyonlarla istediğimiz veri tipine de dönüştürebiliriz. Örneğin aşağıdaki örnekte maksimum int değerini verdiğimiz için myNumber int tipinde olacaktır. Üstte belirtiğim gibi 0 versekte int olacak, byte aralığını alıyor diye byte olmuyor. Int aralığını geçersek Long tipine dönüşecek. Bu arada çıktıda referans tipli olan Integer ifadesi yazıldığına da dikkat çekerim

fun main() {
    val myNumber: Number = Int.MAX_VALUE
    println(myNumber.javaClass) // class java.lang.Integer
}

2 -> Değer aralıklarına göre belirler. 1.Soruda bu konuya kısaca bakış atmıştık. Bir değişkene int aralığında değer atanıyorsa (-2^31 ve 2^31 -1) bu sayının tipi integer olarak belirlenir. Byte, Short gibi diğer türlerin verilmesini istiyorsak dönüştürme fonksiyonlarını kullanabiliriz (toShort() gibi). Bir değişkene noktalı sayı verdiğimizde default olarak double değerini alır. Float yapabilmek için f ifadesini sayını sonuna verebiliriz.

3 -> 1 (sayı olan 1 :D) ifadesiyle karışmaması için :) Örneğin: val myNumber = 111.1f dediğimizde herhangi bir okuma problemi yaşanmıyor fakat 111.1l yapsaydık sondakinin 1 mi l mi olduğunu tam olarak göremezdik.

4 -> Kayan noktanın ne kadar uzunluğa sahip olacağını belirleyen kavramlardır. Float bir değer için .'dan sonra 9-10 hane yazsak bile bunların hepsi o değer içine atanmıyor. Daha doğrusu yazdırırken göremiyoruz.

Tek Duyarlıklı (Single Precision):

- Tek duyarlıklı, IEEE 754 standardına göre 32-bit uzunluğunda bir kayan nokta sayı formatıdır.
- Tek duyarlıklı format, daha az bellek kullanımı ve daha düşük hesaplama hassasiyeti sağlar.
- Ancak, daha sınırlı bir aralık ve hassasiyet sağlar. Özellikle büyük veya çok küçük sayılarla çalışırken hassasiyet kaybı yaşanabilir.

Çift Duyarlıklı (Double Precision):

- Çift duyarlıklı, IEEE 754 standardına göre 64-bit uzunluğunda bir kayan nokta sayı formatıdır.
- Çift duyarlıklı format, daha fazla bellek kullanımı ve daha yüksek hesaplama hassasiyeti sağlar.
- Daha geniş bir aralık ve daha yüksek hassasiyet sağlar, bu da büyük ve küçük sayılarla çalışırken daha doğru sonuçlar elde etmeyi mümkün kılar.

5 -> ondalık ayıracı için ikisinde de . işareti kullanılır. Aralarındaki farkı ise float ifadesinin sonundaki f veya F harfinden anlarız.

6 -> Float bir değişkene değer atarken . 'dan sonra 7 karakter koyabiliriz. Bundan sonrakileri yazdıramayız. Fakat 7'den fazla karakter verdiğimizde double bir değer ile toplandığında meydana gelecek sayıda o fazladan verdiğimiz değerler de işlem görecektir. Bu yüzden ondalık sayılarda ondalık kısmında 7'den fazla karakter varsa double kullanılması daha uygundur.

7 -> val hexadecimalNumber = 0xFF // Hexadecimal
     println(hexadecimalNumber)

     val binaryNumber = 0b00001011 // Binary
     println(binaryNumber)
    
     val decimalNumber: Int = 123 // Decimal
     println(decimalNumber)

8 -> Hayır oktal sayılar Kotlin'de desteklenmiyor.

9 -> "Geleneksel Notasyon" terimi, matematiksel ifadelerin genellikle kullanılan geleneksel gösterimine atıfta bulunur. Mesela + işareti toplama işaretini ifade eder. * işareti çarpım işaretini gösterir.

10 -> Uzun haneden oluşan sayıların daha okunaklı olması için _ kullanılır. Yorumlanırken _ işaretleri görmezden gelinir.

11 -> == ile iki ifadenin içeriğini kıyaslarız. === ile referanslarını kıyaslarız.

12 -> Byte değer aralığındaki sayılar için farklı bir optimazsyon uygulanıyor ve referansları farklı olsa bile ref kıyaslamasında true döner elde ediyoruz.

    // Byte aralığında true dönecek!
    val myValue2 : Int? = 128
    val myValue3: Int? = 128

    println(myValue2 === myValue3)

Buradaki ifade false dönecek çünkü myValue2 başka 128'i myValue3 başka 128'i işaret edecek. Referansları farklı olduğu için false dönüyor. Fakat -128 ve 127 aralığında bir sayı girersek bu kıyaslama sonucunda true değer elde edeceğiz. Hatta aşağıdaki kod örnekleriyle farklı referansları olduğunu da garanti edebiliriz.

    println(System.identityHashCode(myValue2))
    println(System.identityHashCode(myValue3))

13 -> Temel olarak + - * / % ++ -- operatörlerini sayabiliriz. İlk 4'ü matematiksel operatörler zaten. 5. modül almak için kullanılır. ++ ile bir değişkenin değerini 1 arttırıp o değer içine atarız. -- ile de 1 azaltıp o değer içine atarız.

14 -> < > <= >= == != operatörlerini sayabiliriz. İki sayı arasında sırasıyla küçüktür, büyüktür, küçük eşittir, büyük eşittir, eşittir ve eşit değildir kıyaslaması yapar.

15 -> Bit düzeyinde operatörler, bilgisayar belleğindeki verilerin bit seviyesinde manipüle edilmesini sağlayan operatörlerdir. Örneklerini göstermek için kullanılan operatörlerle birlikte aşağıya yazıyorum.

    val a = 0b1010
    val b = 0b1100

    val andResult = a and b // 1000 = 8 -> (2^0 * 0) + (2^1 * 0) + ...
    val orResult = a or b // 1110 = 14
    val xorResult = a xor b
    val notResult = a.inv()
    val leftShiftResult = a shl 2
    val rightShiftResult = a shr 2

    println(andResult)
    println(orResult)
    println(xorResult)
    println(notResult)
    println(leftShiftResult)
    println(rightShiftResult)

16 -> Bu iş için kullanılan iki adet tipten yararlanabiliriz.

BigInteger: Büyük tamsayılar için kullanılır. BigInteger sınıfı, istediğiniz kadar büyük tamsayıları temsil etmek için kullanılır. Sınırsız büyüklükte tamsayıları temsil edebilir.

BigDecimal: Büyük ondalıklı sayılar için kullanılır. BigDecimal sınıfı, yüksek hassasiyet gerektiren büyük ondalıklı sayıları temsil etmek için kullanılır. Bu sınıf, herhangi bir boyutta ondalıklı sayıları temsil etmek için kullanılabilir.

BigInteger ve BigDecimal sınıflarının sınırları, bellek ve işlemci gücüyle sınırlıdır. Bellek ve işlemci kapasiteniz ne kadar büyükse, temsil edebileceğiniz sayılar da o kadar büyük olabilir.

17 -> Double ve Float veri tiplerinde, sayılar bilgisayarın sınırlı hassasiyeti nedeniyle tam olarak temsil edilemeyebilir. Bu nedenle, bazı durumlarda sayılar yuvarlanabilir. Yuvarlama davranışı, IEEE 754 standardı tarafından tanımlanan bir dizi kurala göre belirlenir. Bu standarta göre, sayılar en yakın değere yuvarlanabilir, yukarı veya aşağı yuvarlanabilir veya sıfıra yuvarlanabilir. Ancak, Kotlin veya Java gibi dillerde, yuvarlama davranışını değiştirmek için doğrudan bir seçenek bulunmamaktadır. Bu durumu 4.cevapta biraz görmüştük.

------------- İşaretsiz Sayılar -------------

1 -> İşaretsiz değişkenler sadece pozitif değer aralığında sayılara sahip olan değişkenlerdir. Örneğin byte aralığı -128 ve 127 arasındadır. UByte aralığı ise 0 ile 255 aralığındadır. Negatif aralığı pozitif aralığa itiyormuşuz gibi düşünebiliriz.

