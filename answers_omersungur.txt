------------- Temel Türler & Null Güvenliği -------------

1 - val değişkenler farklı senaryolara göre ya read-only ya da immutable olabilir. var değişkenler ise mutable'dır, yani değeri sonradan değiştirilebilir. Arasındaki fark temel olarak budur. Performans açısından kıyaslayacak olursak, yine farklı bakış açılarıyla farklı sonuçlar elde ederiz. Val bir property'nin setter fonksiyonu olmadığı için doğrudan atama yapılamıyor. Atama yaparken threadlerden yararlanacağımızı düşünecek olursak bu threadlerin maaliyeti "var" için yapılacak kullanım kadar fazla değildir. var bir property'e değer atarken hangi thread bu işlemi yapıyor ve diğer threadlerin bu değişikliği takip etmesi gibi durumları düşünmeliyiz. Bu açıdan val daha performanslıdır. Fakat başka bir bakış açısıyla şunu da söyleyebiliriz: val propertylerde tekrar değer ataması olmadığı için burada bir if case'i varmış gibi düşünebiliriz. Sürekli kontrol sağlanarak değer atanıp atanmadığını düşünecek olursak val burada daha az performanslı olur. var propertyler için böyle bir kontrol olmadığını düşünebiliriz.

2 - var bir property'nin val gibi davranması için setter fonksiyonunu private yapabiliriz. Bu şekilde dışarıdan bu property'e değer atanamaz. Bunu neden yapmak isteyebiliriz? Tanımlanan bir property sadece o sınıf içinde değiştirilebilir olsun, dışarıdan değiştirilemez olsun istiyorsak kullanabiliriz. Örneğin mutableLiveData yapısını bu şekilde kullanabiliriz, sadece view model içinden değiştirip UI'da erişemeyiz. Örnek kod:

fun main() {
    val user = User()
    user.name = "" // Error! (Cannot assign to 'name': the setter is private in 'User')
}

class User() {
    var name: String = "Omer"
        private set

    fun printName() {
        name = "Ahmet"
    }
}

3 - Immutable, değeri sonradan değiştirilemeyen veya atama yapılamayan kavramına denk gelir. Read-only ise değişkene bir atama yapıldıktan sonra tekrar atama yapılamadığı anlamına gelir. Peki val hangisidir? val için senaryolara göre farklı cevapları vardır. Bir class içinde val ile birlikte tanımlanan property, read onlydir. Immutable diyemeyiz çünkü getter fonksiyonu içinde değer ataması yapabiliriz. Eğer bu değer atamaları farklı propertyler olursa, val değerin değişkeni de doğrudan değişmiş oluyor. Fakat genel olarak val propertyler için read only'dir diyebiliriz. Hemen örnek verelim:

fun main() {
    val car = Car()
    car.printCarName()
}

class Car() {
    private var varCarName = "Audi"
    private val valCarName: String
        get() {
            return varCarName
        }

    fun printCarName() {
        varCarName = "BMW"
        println(valCarName) // BMW
        varCarName = "Mercedes"
        println(valCarName) // Mercedes
    }
}

Buradaki ilk çıktı BMW ikincisi ise Mercedes oluyor. Görüldüğü üzere sınıf içerisinde tanımlanan val property'nin değerini değiştirebiliyoruz. Immutable diyebilmemiz için getter fonksiyonunu değiştirememiz gerekiyor. Bunu yapmanın yolu da bu val değişkenleri bir fonksiyon scope'u içinde tanımlamaktır. Bu şekilde arka planda getter ve setter fonksiyonları oluşmayacak ve gerçekten immutable olacaktır.

4 -> Type inference (tip çıkarımı), değişkenlerin tiplerinin otomatik veya bizim yazmamızla belirlenmesidir. Eğer değişkenin değerini verirsek doğrudan verirsek burada otomatik bir tip çıkarımı olur. Onun hangi tip bir değişken olduğunu belirtmemize gerek yoktur. Lokal bir değişkenin başlangıç değerini vermeden tanımlayabilir fakat bu tanımlama sırasında değişkenin tipini de kesinlikle yazmalıyız.

class Car {
    // val carName : String // Başlangıç değeri olmadan sınıf değişkeni tanımlanamıyor.
    val carName : String = "Audi" // Explicit Type Inference
    val carName2 = "Audi" // Implicit Type Inference
    
    fun printCarName() {
        val carName: String // başlangıç değeri olmadan lokal bir değişken tanımlanabiliyor.
    }
}

5 -> Hayır, özel optimazsyonlar ile primitive performansını yakayabiliriz. Örneğin Int, Java'daki int tipine denk gelirken Int?, Integer tipine karşılık gelir. Bu şekilde primitive - referans tip ayrımı yapılabiliyor.

6 -> Tip güvenliği, bir değişken hangi tipte tanımlandıysan o tipteki değişkenleri alabilmesidir. Diğer tipteki değişkenleri alamaz.

val myStr = "Omer"
myStr = 5 // exception (String ifadeye int veremeyiz)

7 -> Nullable yapabilmek için ? ifadesini tipin sonuna koyabiliriz. Örneğin: String -> String? bu şekilde nullable yapmış oluyoruz.

8 -> Nullable bir değişkeni direkt olarak kullanamıyoruz. Bu da bize null safety kavramını getiriyor. Nullable bir değişkeni kullanabilmek için ? ve !! ifadelerine yoğunlaşabiliriz. Eğer bir ifade null değil ise bu işlem yap demek istersek ? ifadesini, eğer bu ifade kesinlikle null değil ben eminim, kullan bunu demek istersek !! operatörünü kullanabiliriz. Fakat değer null ise exception oluşur.

fun main() {
    val myStr: String? = null
    println(myStr?.length) // null döner
    // println(myStr!!.length) // exception oluşur.
}

9 -> Nothing tipini alır. Nothing, hiçbir değeri olmayan bir şeyi temsil etmek için kullanılır. Burada tipini bilmediğimiz için Nothing? olarak işaretlenir.

10 -> Primitive tiplerin değişken adı ve değişkenin değeri bellekte stack alanında saklanır. Referans tiplerin değişken adı stackte, değeri ise heap alanında saklanır. Stack alanına erişim daha hızlı olduğu için primitive tipler daha performanslı çalışır.

11 -> Yer kaplamaz diyemeyiz. Değişkenin adı stackte yine yer kaplar fakat değeri olmadığı için (null) heap alanında yer tutmaz. Sonuç olarak stackte yer tuttuğu için yine de yer kaplar diyebiliriz.

12 -> 8.cevapta verildi. !! ve ? kullanımıyla ilgili...

------------- Sayılar -------------

1 -> Byte, Short, Int, Long, Float ve Double olmak üzere 6 tane sınıf Number sınıfını miras alır. Number tipinde bir değişkene değer verdiğimizde eğer int aralığındaysa default olarak int tipine dönüşür. Eğer noktalı sayı yazarsak default olarak double tipini alır. Bunları toByte(), toShort() gibi fonksiyonlarla istediğimiz veri tipine de dönüştürebiliriz. Örneğin aşağıdaki örnekte maksimum int değerini verdiğimiz için myNumber int tipinde olacaktır. Üstte belirtiğim gibi 0 versekte int olacak, byte aralığını alıyor diye byte olmuyor. Int aralığını geçersek Long tipine dönüşecek. Bu arada çıktıda referans tipli olan Integer ifadesi yazıldığına da dikkat çekerim

fun main() {
    val myNumber: Number = Int.MAX_VALUE
    println(myNumber.javaClass) // class java.lang.Integer
}

2 -> Değer aralıklarına göre belirler. 1.Soruda bu konuya kısaca bakış atmıştık. Bir değişkene int aralığında değer atanıyorsa (-2^31 ve 2^31 -1) bu sayının tipi integer olarak belirlenir. Byte, Short gibi diğer türlerin verilmesini istiyorsak dönüştürme fonksiyonlarını kullanabiliriz (toShort() gibi). Bir değişkene noktalı sayı verdiğimizde default olarak double değerini alır. Float yapabilmek için f ifadesini sayını sonuna verebiliriz.

3 -> 1 (sayı olan 1 :D) ifadesiyle karışmaması için :) Örneğin: val myNumber = 111.1f dediğimizde herhangi bir okuma problemi yaşanmıyor fakat 111.1l yapsaydık sondakinin 1 mi l mi olduğunu tam olarak göremezdik.