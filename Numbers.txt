
Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?
*Byte,Short,Integer,Long,Float ve Double olarak 6 adet adettir. Her birinin değer aralığı değişiklik gösterdiği için bellekte kapladığı yer miktarı da aynı değildir. 1 rakamını tüm alt sınıflar ile çağırabiliriz. Fakat 128 sayısını Byte ile çağıramayız çünkü Byte 127 den daha büyük bir değer alamaz. Explicit intent kullanarak toShort() yaptığımızda tip artık Short olacaktır. Bu düzeltmeyi yapmadan bir değişkene 1 atadığımızda IDE bunu integer olarak belirler çünkü integer yaygın olarak kullanımda esneklik ve kolaylık sağlar. Bellek kullanım farkı göz ardı edilir. Yine de Byte olarak atandığında çok küçük de olsa performans kazanımı olacaktır.



Eğer bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa, Kotlin tip çıkarımını nasıl yapar?
* Atanan sayı değeri integer aralığında ise otomatik olarak integer, eğer daha fazlaysa Long gibi kendi aralığında bir tip çıkarımı yapar. Text ataması yaparsak otomatik olarak String tipinde çıkarım yapar.

Float değişken oluştururken F ve f harfleri varken, Long değişken oluştururken neden küçük l harfi yoktur?
* Küçük L ( l ) rakam olan 1 e benzediğinden dolayı büyük L ile kullanılır.

Tek duyarlıklı (Single precision) ve Çift duyarlıklı (Double precision) kavramlarını açıklayın.
* Single precision bellekte 32 bit harcar ve GPU alanlarında kullanılır. Double Precision bellekte 64 bit harcar ve matematiksel işlemlerin daha yoğun olması beklendiği CPU tarafından kullanılır. Daha az bellek kullanması istenildiğinde Half precision da kullanılabilir fakat 16 bit harcadığı için bellek hassasiyetini dikkatlice incelemek lazım. Bu performans kazanımı göz ardı edilecek seviyede olduğu için genellik Single precision tercih edilir.

Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak hangi işaretler kullanılır? Bu ayıraçların kullanımında nelere dikkat etmek gerekir?
* Nokta veya virgül kullanılır. Dikkat edilmesi gereken durum eğer ondalık ayracımız backend' den , dönüyorsa ve biz . kullanıyorsak hata alırız. Local ve canlıda hangi ayracın döndüğünü öğrenmek gerekir. Bununla beraber okunuş olarak kolaylık sağlaması bakımından bir değişken değerini 10_000 olarak yazsak bile IDE bunu 10000 olarak görecektir. Keyfi olarak değiştirilebilir.

Double ve Float değişkenler ondalık kısımda kaç basamağa kadar işlem yaparlar? Bu sınırın üzerinde gelen ondalık bilgileri için nasıl davranırlar? Hangi durumlar için Float ve hangi durumlar için Double kullanılmalıdır?
* Float 32 bitlik bir veri türüdür, 7 basamağa kadar işlem yapar ve single precision olarak adlandırılır. Double 64 bitlik bir veri türüdür, 15 basamağa kadar işlem yapar ve double precision olarak adlandırılır . Performans olarak fark olsa da yüksek doğruluk sağladığı için bilimsel hassas hesaplamalar yapmak gerektiğinde Double tercih edilmelidir.

Ondalık(Decimal), Onaltılık (Hexadecimal) ve İkilik (Binary) değişkenleri Kotlin'de nasıl tanımlayabilirsiniz?
* Ondalık değişkenler doğrudan tanımlanabilir. Örnek val a: Double = 3.14
Hexadecimal değişkenler başına 0x ön eki alarak tanımlanır. Örnek val a: Int = 0x10
Binary değişkenler 0b ön eki konularak tanımlanır. Örnek val a: Long = 0b1010



Sekizlik (Octal) değişkenler Java'da nasıl tanımlanır? Kotlin'de Sekizlik değişken tanımlanabilir mi?
* Octal değişkenler Java da "0" ön ekiyle tanımlanır. Kotlin' de octal tanım için bir syntax yoktur , onun yerine ondalık sayı gibi tanımlanır ve ön eki almaz.

"Geleneksel Notasyon" (Conventional Notation) gösterimi nasıl yapılır?
* Bir şeyin standart veya geleneksel bir şekilde yazılması anlamına gelir. Örnek olarak Kotlin topluluğunca kullanılan geleneksel bir gösterim olan  class MyClass{} buna bir örnektir.



Sayısal değişkenlerde alt çizgi (underscore) nasıl kullanılır? Kotlin bunu nasıl yorumlar?
* Değerin okunaklı olmasını sağlar .val a = 1_000_000 değişkeninin 1 milyon olduğunu daha rahat okuyabiliriz. Derleyici tarafından göz ardı edilir sadece görsel iyileştirme sağlar.

== ile neyi karşılaştırırız? === ile neyi karşılaştırırız?
* == değerin kendisini karşılaştırırız. === ile değerin memorydeki referansını kontrol ederiz. True veya false değerleri döndürür.


=== operatörü ile karşılaştırma yaparken Byte değer aralığı neden önemlidir? Kotlin bu aralığa göre neden özel bir davranış sergiler?
* Byte değer aralığında iki variable ı === ile karşılaştırma yaptığımızda bize aynı memory referansını verir. Kotlin kullanım sıklığı yüzünden özel bir davranış sergiler. Değer Byte ın üzerine çıktığında artık farklı bir memory adresine referans eder.









