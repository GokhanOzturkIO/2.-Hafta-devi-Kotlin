Temel Türler & Null Güvenliği
1-val ile var arasındaki fark nedir?
-performans farkı yok denecek kadar azdır. val daha maliyetlidir. var daha performanslıdır. Fakat Thread kullanımında val kullanmak daha mantıklı ve performans konusunda avantajlıdır çünkü birden fazla thread açtıktan sonra var değişkenler kullanmak sürekli bir karşılaştırmaya girer ve hem maliyetten hem de süreden kazancımızı sınırlar, val bu konuda sabit bir değerde olduğundan daha avantajlıdır.

2-Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.
-örnek olarak: 
  class A{
    var isMale: Boolean = true
        private set
} şeklinde tanımlanabilir.

3-"Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?
-read-only -> değeri okunabilen, değişemez anlamına gelmeyen 
immutable -> bir nesnenin değerinin asla ilk değerden farklı olmaması durumu.
val read-only'dir 
class rectangle{
    var shortEdge: Int = 15
    var longEdge: Int = 25

    val calculate: Int
        get(){
            return shortEdge * longEdge
        }
} kodunu incelediğimizde immutable olmamasının nedeni değerinin asla ilk değerden farklı olmasıdır.

4-"Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?
-tip çıkarımı, eşitliğin sağ tarafında değişkenin tipini biz vermesek bile IDE'nin kendisinin tip çıkarımı yaparak bulmasıdır. Bazı durumlarda, derleyici türü doğru şekilde çıkaramayabilir, özellikle karşılaştırılabilir türlerde. Örneğin, List sınıfında bulunan sort işlevi, elemanların karşılaştırılabilir olduğunu belirtmek için türü açıkça belirtmenizi gerektirir: listOf(3, 1, 2).sorted() yerine listOf(3, 1, 2).sorted() as List<Int> şeklinde yazılmalıdır.

5-Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

-Evet, Kotlin'de tüm değişkenler nesne olarak kabul edilir ve "ilkel tipler" (primitive types) diye bir kavram yoktur. Bu, Kotlin'in Java'dan farklı olduğu bir noktadır. Kotlin'de, sayılar, karakterler ve boolean değerler gibi temel veri tipleri bile aslında sınıf gibi davranır.

Arka planda, Kotlin derleyicisi, bu temel veri tiplerini otomatik olarak ilgili sınıflara dönüştürür. Örneğin, bir Int değişkeni tanımladığınızda, bu aslında java.lang.Integer sınıfının bir örneği olarak ele alınır. Benzer şekilde, Boolean türü java.lang.Boolean sınıfına dönüştürülür.

Bu yaklaşım, Kotlin'in nesne yönelimli programlamayı desteklemesini sağlar ve tüm veri tiplerinin birbirine daha tutarlı bir şekilde davranmasını sağlar. Bununla birlikte, derleyici genellikle bu dönüşümleri otomatik olarak gerçekleştirir, bu nedenle genellikle kullanıcı tarafından fark edilmez. Bu da kodun daha temiz ve okunabilir olmasına katkıda bulunur.

Fakat kotlin bytecode ile javaya çevirdiğimizde ilgili tip sınıflarının kodları Java kodunda primitive tip gibi davranır.

6-"Tip Güvenliği" (Type Safety) kavramını açıklayın.

-Kotlin, null referanslarıyla ilgili hataları önlemek için null güvenliği sağlar. Kotlin'de, bir değişkenin null olabileceğini belirtmek için Type? şeklinde bir tür kullanılır. Bu, derleyicinin null referans hatalarını önlemesine yardımcı olur.

Kotlin, tür dönüşümlerini güvenli bir şekilde yapmanızı sağlar. Örneğin, sayısal bir değeri metin bir değere dönüştürürken, derleyicinin uygun bir şekilde işlem yapmasını sağlar.

7-Bir değişkeni nullable yapmak için ne yapmalıyız?

-soru işareti ekleyerek yapabiliriz. örnek:
var name? = null gibi.

8-"Null Güvenliği" (Null Safety) kavramını açıklayın.

-Kotlin null safety sağlayan bir dildir. Bu sayede nullable ve non-nullable olup olamayacağğını ve null referans hatalarını önler. Null Safety, ayrıca null check operatörü (?), Elvis operatörü (?:), ve safe cast operatörü (as?) iile kullanımı mümkündür.

9-Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

-Any? olarak değerlendirir.

10-İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

-null değer alamaması bellek açısından daha basit bir karmaşıklığa sahipken, nullable olması ise bellekte bu değişkenler için ayrılmış alanın her zaman bir değer içereceği anlamına gelmez. ve daha karmaşık bir durum oluşur. Null check işlemini nullable tipler için kullanlması gerekebilir.

11-Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?

-Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından bir fark yoktur. Her iki durumda da bellekte aynı miktarda yer ayrılmış olur. Null değer almış bir değişken, bellekte yer kaplar çünkü null bir değerdir ve bellekte saklanması için alan gerektirir. Dolayısıyla, null değer almış bir değişkenin bellekte yer kaplamadığı şeklinde bir ifade yanıltıcı olur.

12-Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır?

-safe call operator -> ?, bir nesnenin null olabileceğini belirtir.

elvis operator -> ?:, bu işaret sayesinde null değişkeni kontrol edip eğer null ise belirtilen değeri kullanır.

not null assertion opeator -> !!, bu işaret sayesinde bir değişkenin null olmadığını varsayar ve derleyiciye bu konuda güvence verir.