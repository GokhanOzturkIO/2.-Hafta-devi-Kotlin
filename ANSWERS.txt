A)Temel Türler & Null Güvenliği
1-val ile var arasındaki fark nedir?
-performans farkı yok denecek kadar azdır. val daha maliyetlidir. var daha performanslıdır. Fakat Thread kullanımında val kullanmak daha mantıklı ve performans konusunda avantajlıdır çünkü birden fazla thread açtıktan sonra var değişkenler kullanmak sürekli bir karşılaştırmaya girer ve hem maliyetten hem de süreden kazancımızı sınırlar, val bu konuda sabit bir değerde olduğundan daha avantajlıdır.

2-Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.
-örnek olarak: 
  class A{
    var isMale: Boolean = true
        private set
} şeklinde tanımlanabilir.

3-"Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?
-read-only -> değeri okunabilen, değişemez anlamına gelmeyen 
immutable -> bir nesnenin değerinin asla ilk değerden farklı olmaması durumu.
val read-only'dir 
class rectangle{
    var shortEdge: Int = 15
    var longEdge: Int = 25

    val calculate: Int
        get(){
            return shortEdge * longEdge
        }
} kodunu incelediğimizde immutable olmamasının nedeni değerinin asla ilk değerden farklı olmasıdır.

4-"Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?
-tip çıkarımı, eşitliğin sağ tarafında değişkenin tipini biz vermesek bile IDE'nin kendisinin tip çıkarımı yaparak bulmasıdır. Bazı durumlarda, derleyici türü doğru şekilde çıkaramayabilir, özellikle karşılaştırılabilir türlerde. Örneğin, List sınıfında bulunan sort işlevi, elemanların karşılaştırılabilir olduğunu belirtmek için türü açıkça belirtmenizi gerektirir: listOf(3, 1, 2).sorted() yerine listOf(3, 1, 2).sorted() as List<Int> şeklinde yazılmalıdır.

5-Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

-Evet, Kotlin'de tüm değişkenler nesne olarak kabul edilir ve "ilkel tipler" (primitive types) diye bir kavram yoktur. Bu, Kotlin'in Java'dan farklı olduğu bir noktadır. Kotlin'de, sayılar, karakterler ve boolean değerler gibi temel veri tipleri bile aslında sınıf gibi davranır.

Arka planda, Kotlin derleyicisi, bu temel veri tiplerini otomatik olarak ilgili sınıflara dönüştürür. Örneğin, bir Int değişkeni tanımladığınızda, bu aslında java.lang.Integer sınıfının bir örneği olarak ele alınır. Benzer şekilde, Boolean türü java.lang.Boolean sınıfına dönüştürülür.

Bu yaklaşım, Kotlin'in nesne yönelimli programlamayı desteklemesini sağlar ve tüm veri tiplerinin birbirine daha tutarlı bir şekilde davranmasını sağlar. Bununla birlikte, derleyici genellikle bu dönüşümleri otomatik olarak gerçekleştirir, bu nedenle genellikle kullanıcı tarafından fark edilmez. Bu da kodun daha temiz ve okunabilir olmasına katkıda bulunur.

Fakat kotlin bytecode ile javaya çevirdiğimizde ilgili tip sınıflarının kodları Java kodunda primitive tip gibi davranır.

6-"Tip Güvenliği" (Type Safety) kavramını açıklayın.

-Kotlin, null referanslarıyla ilgili hataları önlemek için null güvenliği sağlar. Kotlin'de, bir değişkenin null olabileceğini belirtmek için Type? şeklinde bir tür kullanılır. Bu, derleyicinin null referans hatalarını önlemesine yardımcı olur.

Kotlin, tür dönüşümlerini güvenli bir şekilde yapmanızı sağlar. Örneğin, sayısal bir değeri metin bir değere dönüştürürken, derleyicinin uygun bir şekilde işlem yapmasını sağlar.

7-Bir değişkeni nullable yapmak için ne yapmalıyız?

-soru işareti ekleyerek yapabiliriz. örnek:
var name? = null gibi.

8-"Null Güvenliği" (Null Safety) kavramını açıklayın.

-Kotlin null safety sağlayan bir dildir. Bu sayede nullable ve non-nullable olup olamayacağğını ve null referans hatalarını önler. Null Safety, ayrıca null check operatörü (?), Elvis operatörü (?:), ve safe cast operatörü (as?) iile kullanımı mümkündür.

9-Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

-Any? olarak değerlendirir.

10-İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

-null değer alamaması bellek açısından daha basit bir karmaşıklığa sahipken, nullable olması ise bellekte bu değişkenler için ayrılmış alanın her zaman bir değer içereceği anlamına gelmez. ve daha karmaşık bir durum oluşur. Null check işlemini nullable tipler için kullanlması gerekebilir.

11-Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?

-Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından bir fark yoktur. Her iki durumda da bellekte aynı miktarda yer ayrılmış olur. Null değer almış bir değişken, bellekte yer kaplar çünkü null bir değerdir ve bellekte saklanması için alan gerektirir. Dolayısıyla, null değer almış bir değişkenin bellekte yer kaplamadığı şeklinde bir ifade yanıltıcı olur.

12-Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır?

-safe call operator -> ?, bir nesnenin null olabileceğini belirtir.

elvis operator -> ?:, bu işaret sayesinde null değişkeni kontrol edip eğer null ise belirtilen değeri kullanır.

not null assertion opeator -> !!, bu işaret sayesinde bir değişkenin null olmadığını varsayar ve derleyiciye bu konuda güvence verir.

B)SAYILAR

1- Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?

- Byte: 8-bit işaretli tamsayı değerlerini temsil eder. Değer aralığı -128 ile 127 arasındadır.

Short: 16-bit işaretli tamsayı değerlerini temsil eder. Değer aralığı -32768 ile 32767 arasındadır.

Int: 32-bit işaretli tamsayı değerlerini temsil eder. Değer aralığı -2^31 ile (2^31)-1 arasındadır.

Long: 64-bit işaretli tamsayı değerlerini temsil eder. Değer aralığı -2^63 ile (2^63)-1 arasındadır.

Float: 32-bit kayan noktalı sayı değerlerini temsil eder. Değer aralığı ve hassasiyeti diğer sayı tiplerinden farklıdır.

Double: 64-bit kayan noktalı sayı değerlerini temsil eder. Değer aralığı ve hassasiyeti diğer sayı tiplerinden farklıdır.

bunların değer aralıkları önemlidir çünkü bir değeri doğru aralıkta bulunan değişkende kullanmak bellek optimizasyonu için oldukça önemlidir.

2-Eğer bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa, Kotlin tip çıkarımını nasıl yapar?

-verilen değere göre Int veya Long olarak otomatik belirlenir.

3-Float değişken oluştururken F ve f harfleri varken, Long değişken oluştururken neden küçük l harfi yoktur

-1 harfiyle karıştırılabileceğinden kullanımı yanlış kabul edilir.

4-Tek duyarlıklı (Single precision) ve Çift duyarlıklı (Double precision) kavramlarını açıklayın.

-tek duyarlıklı kavramı: 32 bit 4 byte olarak temsil edilirler, genelde float ile kullanılırlar. Az bellek kullanır, düşük hassasiyettedir.
çift duyarlıklı kavramı: 64 bit 8 byte olarak temsil edilirler, genelde double ile kullanılırlar. Daha fazla bellek tüketir, yüksek hassasiyettedir.

5-Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak hangi işaretler kullanılır? Bu ayıraçların kullanımında nelere dikkat etmek gerekir?

-val doubleNumber: Double = 3.14
val floatNumber: Float = 2.718f gibi örneklerde de görüldüğü üzere nokta ile ayrılmaktadır. float olmasını istediğimiz değişkenin sonuna f koyarız.

6-Double ve Float değişkenler ondalık kısımda kaç basamağa kadar işlem yaparlar? Bu sınırın üzerinde gelen ondalık bilgileri için nasıl davranırlar? Hangi durumlar için Float ve hangi durumlar için Double kullanılmalıdır?

-Float: 32 bitlik bir veri türüdür ve tipik olarak yaklaşık 6-7 basamağa kadar kesinlik sağlar. Bu, 6-7 basamağın ötesindeki ondalık kısımları tam olarak temsil edemez ve hassasiyet kaybı yaşanabilir.

Double: 64 bitlik bir veri türüdür ve genellikle yaklaşık 15-16 basamağa kadar kesinlik sağlar. Bu, daha yüksek bir hassasiyet sunar ve daha geniş bir değer aralığını kapsar.

Eğer kesinlik ve hassasiyet önemliyse, genellikle Double tercih edilir. Örneğin, finansal hesaplamalar, bilimsel hesaplamalar veya büyük sayılarla yapılan hesaplamalar genellikle Double kullanılarak yapılır. Float ise daha az bellek kullanır ve daha kısıtlı bir değer aralığına sahiptir, bu nedenle özellikle bellek kullanımı önemli olan durumlarda veya daha düşük hassasiyet gerektiren hesaplamalarda tercih edilebilir.

Ondalık bilgilerin sınırın üzerinde gelmesi durumunda, bu bilgiler genellikle kesilir veya yuvarlanır. Örneğin, Float tipinde 1.23456789f değeri saklanırken, ondalık kısmın sonraki basamakları kesilerek 1.2345679 şeklinde saklanabilir. Bu nedenle, yüksek hassasiyet gerektiren durumlarda ondalık sayıların doğru bir şekilde temsil edildiğinden emin olmak için Double kullanmak daha uygundur.

7-Ondalık(Decimal), Onaltılık (Hexadecimal) ve İkilik (Binary) değişkenleri Kotlin'de nasıl tanımlayabilirsiniz?

-val decimalNumber: Int = 123
val hexadecimalNumber: Int = 0x1F
val binaryNumber: Int = 0b1010
şeklinde tanımlayabiliriz.

8-Sekizlik (Octal) değişkenler Java'da nasıl tanımlanır? Kotlin'de Sekizlik değişken tanımlanabilir mi?

-Java'da sekizlik (octal) sayıları tanımlamak için sayının başına sıfır eklemeniz yeterlidir. Örneğin:
int octalNumber = 012;
Bu örnekte, 012 sekizlik bir sayıdır çünkü başında sıfır var.

Kotlin'de ise doğrudan sekizlik sayıları tanımlayamazsınız. Kotlin, Java ile uyumlu olmasına rağmen sekizlik sayı tanımlama özelliğini desteklemez. Eğer bir sekizlik sayıyı Kotlin'de kullanmanız gerekiyorsa, önce Java'da tanımlayıp Kotlin kodunuzda kullanabilirsiniz. Örneğin:

val octalNumber = Integer.parseInt("12", 8)
Bu şekilde, Java'da tanımlanmış bir sekizlik sayıyı Kotlin'de kullanabilirsiniz. Ancak, direkt olarak Kotlin syntax'ında sekizlik sayı tanımlaması yapamazsınız.

9-Geleneksel Notasyon" (Conventional Notation) gösterimi nasıl yapılır?

-Kotlin'de geleneksel notasyonu (conventional notation) kullanarak sayıları belirtmek için bir önek veya özel bir işaret kullanılmaz. Geleneksel notasyon, sayıların doğal olarak yazılma biçimidir. Örneğin:
val number = 12345

10-Sayısal değişkenlerde alt çizgi (underscore) nasıl kullanılır? Kotlin bunu nasıl yorumlar?

-val million = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
şeklinde okunabilirliği artırmak için kullanılabilir.
Kotlin, alt çizgileri sayısal değerlerde görmezden gelir. Yani, alt çizgiler sadece sayıyı daha okunabilir hale getirmek için kullanılır ve sayısal değerin kendisini etkilemezler.

11-== ile neyi karşılaştırırız? === ile neyi karşılaştırırız?

- == değişkenlerin değerini karşılaştırmak için
=== değişkenlerin referansını karşılaştırmak için (RAM) kullanılır.

12-=== operatörü ile karşılaştırma yaparken Byte değer aralığı neden önemlidir? Kotlin bu aralığa göre neden özel bir davranış sergiler?

-Kotlin'de === operatörü referansları karşılaştırmak için kullanılır. === operatörü, referansların aynı olup olmadığını kontrol eder, yani iki referans aynı nesneyi gösteriyor mu diye bakar. Ancak, Byte veri türünde bir özel durum vardır.

Kotlin'de Byte veri türü, -128 ile 127 arasındaki değerleri temsil etmek için özel olarak optimize edilmiştir. Bu, -128..127 aralığındaki Byte değerlerinin bellekte sadece bir kopyasının tutulduğu anlamına gelir. Yani, -128 ile 127 arasındaki herhangi iki Byte değeri için === operatörü true dönecektir, çünkü bellekte aynı referansa işaret ederler.

Ancak, bu aralık dışındaki Byte değerleri için farklı referanslar oluşturulur ve === operatörü false döner. Bu davranış, -128..127 aralığındaki sık kullanılan küçük byte değerlerinde bellek kullanımını ve performansı optimize etmeye yardımcı olur. Bu nedenle, Byte değerlerini === operatörü ile karşılaştırırken bu aralığın önemi vardır, çünkü bu aralık içindeki değerler için beklenmedik sonuçlar alabilirsiniz.






